<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<HTML>
 <HEAD>
   <TITLE> [Viperals-svncheckins] r137 - in cms/trunk: . includes includes/nusoap includes/templates includes/templates/modules includes/templates/modules/Forums includes/templates/modules/google_search install modules/Forums modules/Forums/admin
   </TITLE>
   <LINK REL="Index" HREF="http://lists.berlios.de/pipermail/viperals-svncheckins/2005-September/index.html" >
   <LINK REL="made" HREF="mailto:viperals-svncheckins%40lists.berlios.de?Subject=Re%3A%20%5BViperals-svncheckins%5D%20r137%20-%20in%20cms/trunk%3A%20.%20includes%20includes/nusoap%20includes/templates%20includes/templates/modules%20includes/templates/modules/Forums%20includes/templates/modules/google_search%20install%20modules/Forums%20modules/Forums/admin&In-Reply-To=%3C200509210353.j8L3rnvV028976%40sheep.berlios.de%3E">
   <META NAME="robots" CONTENT="index,nofollow">
   <style type="text/css">
       pre {
           white-space: pre-wrap;       /* css-2.1, curent FF, Opera, Safari */
           }
   </style>
   <META http-equiv="Content-Type" content="text/html; charset=us-ascii">
   <LINK REL="Previous"  HREF="000057.html">
   <LINK REL="Next"  HREF="000059.html">
 </HEAD>
 <BODY BGCOLOR="#ffffff">
   <H1>[Viperals-svncheckins] r137 - in cms/trunk: . includes includes/nusoap includes/templates includes/templates/modules includes/templates/modules/Forums includes/templates/modules/google_search install modules/Forums modules/Forums/admin</H1>
    <B>Ryan Marshall at BerliOS</B> 
    <A HREF="mailto:viperals-svncheckins%40lists.berlios.de?Subject=Re%3A%20%5BViperals-svncheckins%5D%20r137%20-%20in%20cms/trunk%3A%20.%20includes%20includes/nusoap%20includes/templates%20includes/templates/modules%20includes/templates/modules/Forums%20includes/templates/modules/google_search%20install%20modules/Forums%20modules/Forums/admin&In-Reply-To=%3C200509210353.j8L3rnvV028976%40sheep.berlios.de%3E"
       TITLE="[Viperals-svncheckins] r137 - in cms/trunk: . includes includes/nusoap includes/templates includes/templates/modules includes/templates/modules/Forums includes/templates/modules/google_search install modules/Forums modules/Forums/admin">viperal at berlios.de
       </A><BR>
    <I>Wed Sep 21 05:53:49 CEST 2005</I>
    <P><UL>
        <LI>Previous message: <A HREF="000057.html">[Viperals-svncheckins] r136 - in cms/trunk: admin includes includes/display includes/forums modules modules/Control_Panel/ucp modules/Members_List modules/calender modules/calender/language modules/calender/language/en
</A></li>
        <LI>Next message: <A HREF="000059.html">[Viperals-svncheckins] r139 - in cms/trunk: includes/forums includes/forums/mcp includes/templates/modules/Forums modules/Forums
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#58">[ date ]</a>
              <a href="thread.html#58">[ thread ]</a>
              <a href="subject.html#58">[ subject ]</a>
              <a href="author.html#58">[ author ]</a>
         </LI>
       </UL>
    <HR>  
<!--beginarticle-->
<PRE>Author: viperal
Date: 2005-09-21 05:53:30 +0200 (Wed, 21 Sep 2005)
New Revision: 137

Added:
   cms/trunk/includes/nusoap/
   cms/trunk/includes/nusoap/changelog
   cms/trunk/includes/nusoap/class.nusoap_base.php
   cms/trunk/includes/nusoap/class.soap_fault.php
   cms/trunk/includes/nusoap/class.soap_parser.php
   cms/trunk/includes/nusoap/class.soap_server.php
   cms/trunk/includes/nusoap/class.soap_transport_http.php
   cms/trunk/includes/nusoap/class.soap_val.php
   cms/trunk/includes/nusoap/class.soapclient.php
   cms/trunk/includes/nusoap/class.wsdl.php
   cms/trunk/includes/nusoap/class.wsdlcache.php
   cms/trunk/includes/nusoap/class.xmlschema.php
   cms/trunk/includes/nusoap/nusoap.php
   cms/trunk/includes/nusoap/nusoapmime.php
   cms/trunk/includes/templates/error_document.html
   cms/trunk/includes/templates/modules/google_search/
   cms/trunk/includes/templates/modules/google_search/index.html
Modified:
   cms/trunk/error.php
   cms/trunk/includes/templates/modules/Forums/search_body.html
   cms/trunk/includes/templates/modules/Forums/search_results.html
   cms/trunk/install/build_data.php
   cms/trunk/install/build_tables.php
   cms/trunk/modules/Forums/admin/index.php
   cms/trunk/modules/Forums/ajax.php
   cms/trunk/modules/Forums/index.php
   cms/trunk/modules/Forums/main.php
   cms/trunk/modules/Forums/posting.php
   cms/trunk/modules/Forums/search.php
   cms/trunk/modules/Forums/viewforum.php
   cms/trunk/modules/Forums/viewtopic.php
Log:


Modified: cms/trunk/error.php
===================================================================
--- cms/trunk/error.php	2005-09-20 21:46:50 UTC (rev 136)
+++ cms/trunk/error.php	2005-09-21 03:53:30 UTC (rev 137)
@@ -60,12 +60,17 @@
 
 $_CLASS['core_template'] =&amp; new core_template();
 
-header(empty($error[$_GET['error']]['header']) ? $error['404']['header'] : $error[$_GET['error']]['header']);
+$_SERVER['REDIRECT_STATUS'] = isset($_SERVER['REDIRECT_STATUS']) ? $_SERVER['REDIRECT_STATUS'] : (isset($_GET['error']) ? $_GET['error'] : 404);
 
-$_CLASS['core_template']-&gt;assign('MESSAGE_TEXT',  (empty($error[$_GET['error']]['lang']) ? $error['404']['lang'] : $error[$_GET['error']]['lang']));
-		
-$_CLASS['core_template']-&gt;display('error.html');
+header(empty($error[$_SERVER['REDIRECT_STATUS']]['header']) ? $error['404']['header'] : $error[$_SERVER['REDIRECT_STATUS']]['header']);
+
+$_CLASS['core_template']-&gt;assign_array(array(
+	'MESSAGE_TEXT'	=&gt; empty($error[$_SERVER['REDIRECT_STATUS']]['lang']) ? $error['404']['lang'] : $error[$_SERVER['REDIRECT_STATUS']]['lang'],
+	'SITE_LINK'		=&gt; '<A HREF="http://">http://</A>'.(empty($_SERVER['SERVER_NAME']) ? $_SERVER['HTTP_HOST'] : $_SERVER['SERVER_NAME']),
+));
 	
+$_CLASS['core_template']-&gt;display('error_document.html');
+	
 die;
 
 ?&gt;
\ No newline at end of file

Added: cms/trunk/includes/nusoap/changelog
===================================================================
--- cms/trunk/includes/nusoap/changelog	2005-09-20 21:46:50 UTC (rev 136)
+++ cms/trunk/includes/nusoap/changelog	2005-09-21 03:53:30 UTC (rev 137)
@@ -0,0 +1,438 @@
+2003-07-21, version 0.6.5
+- soap_transport_http: SOAPAction header is quoted again, fixes problem w/ Weblogic Server
+- applied Jason Levitt patch for proper array serialization, fixes problem w/ Amazon shopping cart services
+- fixed null value serialization
+- applied patch from &quot;BZC ToOn'S&quot; - fixes wsdl serialization when no parameters
+- applied John's patch, implementing compression for the server
+
+2003-07-22, version 0.6.5
+- soap_server: fixed bug causing charset encoding not to be passed to the parser
+- soap_fault: added default encoding to the fault serialization
+- soap_parser: changed the parser to pre-load the parent's result array when processing scalar values. This increases parsing speed.
+
+2003-07-23, version 0.6.5
+- soap_base: fix code that overwrites user-supplied attributes in serialize_val
+- soap_base: use arrays-of-arrays rather than attempting multi-dimensional in serialize_val
+- xmlschema: emit import statements and qualify all elements with prefix in serializeSchema (better interop with validation tools)
+- soapclient: get xml character encoding from HTTP Content-Type header if provided, e.g. text/xml;charset=&quot;UTF-8&quot;
+- soapclient: use headers in call if provided (previously ignored this parameter)
+- soap_server: in parse_request, if neither getallheaders nor $_SERVER are available, use $HTTP_SERVER_VARS to get SOAPAction and xml encoding
+
+2003-07-24, version 0.6.5
+- soap_transport_http: apply patch from Steven Brown &quot;if the server closes connection prematurely, nusoap would spin trying to read data that isn't there&quot;
+
+2003-07-25, version 0.6.5
+- wsdl: apply patch from Sven to workaround single schema limitation
+- wsdl: apply a variant of the patch from Holger to handle empty values for array by serializing an array with 0 elements
+- xmlschema: remove the redundant default namespace attribute on the schema element; everything in xsd is explicitly specified as being from xsd
+- soap_transport_http: fix setCredentials and add TODO comments in sendHTTPS about what to change if this setCredentials stays
+
+2003-07-30, version 0.6.5
+- nusoap_base: change documentation of soap_defencoding to specify it is the encoding for outgoing messages
+- nusoap_base: only change &amp;, &lt;, &gt; to entities, not all HTML entities
+- soap_transport_http: update the Content-Type header in sendRequest, since soap_defencoding could be changed after ctor is called
+- soap_server: use soap_defencoding instead of charset_encoding
+- soap_server: read encoding from _SERVER if available
+- nusoap_base: do entity translation for string parameters with an xsd type specified (thanks David Derr)
+
+2003-07-31, version 0.6.5
+- soap_transport_http: add proxy authentication
+- soap_transport_http: build payload the same way for http and https
+- wsdl: add proxy authentication
+- soapclient: add proxy authentication
+- soapclient: allow proxy information in ctor, so that it can be used for wsdl
+
+2003-08-01, version 0.6.5
+- soap_transport_http: close a persistent connection that's at EOF
+- soap_transport_http: prevent conflicts between setEncoding and usePersistentConnection
+- soap_transport_http: fix use of $headers instead of $this-&gt;incoming_headers in getResponse
+- soapclient: improve handling of persistent connections
+- soapclient: force xml_encoding to upper case
+- soap_server: let the Web server decide whether to close the connection (no Connection: close header)
+- soap_server: force xml_encoding to upper case
+
+2003-08-04, version 0.6.5
+- soap_parser: use XML type information to pick a PHP data type; also decode base64
+- soap_server: read all HTTP headers when using _SERVER or HTTP_SERVER_VARS
+- soap_server: add gzip encoding support for outgoing messages
+- soap_transport_http: deflate is gzcompress/gzuncompress (cf. <A HREF="http://archive.develooper.com/libwww@perl.org/msg04650.html">http://archive.develooper.com/libwww@perl.org/msg04650.html</A>)
+- soap_transport_http: clean use of persistentConnection so it's always a set boolean
+- soapclient: add responseData member to access deflated/gunzipped payload
+
+2003-08-05, version 0.6.5
+- soap_server: look multiple places when setting debug_flag
+
+2003-08-07, version 0.6.5
+- nusoap_base: serialize specified type (e.g. ArrayOfString) even for simple array
+- wsdl: only specify encodingStyle in the input/output soap bindings when it is not empty (thanks Guillaume)
+
+2003-08-15, version 0.6.5
+- soap_parser: fix parsing of elements with no XSD type specified
+- soap_parser: use PHP string type for XSD long and unsignedLong types
+
+2003-08-16, version 0.6.5
+- soap_parser: fix code generating warning (thanks Torsten)
+
+2003-08-19, version 0.6.5
+- soap_parser: fix another line of code generating a warning (thanks Torsten)
+
+2003-08-22, version 0.6.5
+- soap_server: remove all '--' from debug_str; previous code changed '---' to '- --'
+- wsdl, soapclient, soap_parser: patch submitted by Mark Spavin as described by
+                                 the following...
+&gt; Changes for the multiple/nested imports from the wsdl file. This builds an
+&gt; array of files not just the last one and also checks for relative paths to
+&gt; the parent. This will then get the imported files from the remote site
+&gt; instead of your local disk. Local wsdl files should still work (untested).
+&gt;
+&gt; Changes for multiple encoding sytles as previously posted
+
+2003-08-24, version 0.6.5
+- wsdl, soapclient: fix some PHP notices from previous update
+
+2003-08-26, version 0.6.5
+- wsdl: support multiple SOAP ports
+- soapclient, soap_server: when no charset is specified, use UTF-8, even though HTTP specifies US-ASCII.
+- soap_transport_http: do not prepend $host with '<A HREF="ssl://">ssl://</A>' for https (is this required for older cURL versions?)
+
+2003-08-27, version 0.6.5
+- soap_server: support compressed request messages (thanks John Huong)
+- soap_parser: deserialize Apache Vector as an array
+- xmlschema: use $this-&gt;typemap in getPHPType (which is not used)
+- soapclient, wsdl: check for WSDL errors after serializing parameters
+- nusoap_base: add serialization of Apache Map (when not using WSDL)
+- wsdl: add serialization of Apache Map (when using WSDL)
+- wsdl: only change &amp;, &lt;, &gt; to entities, not all HTML entities
+
+2003-08-28, version 0.6.5
+- soap_transport_http: disable cURL verification of peer and server (formerly the cURL default)
+- soap_transport_http: mingle cURL code with straight http, so sendHTTP is no longer needed
+
+2003-08-29, version 0.6.6
+- soap_transport_http: add setContentType
+- soapclient: call setContentType using new getHTTPContentType and getHTTPContentTypeCharset
+
+2003-09-05, version 0.6.6
+- wsdl: add some more code to handle null/nil values (but there's still a way to go)
+
+2003-10-21, version 0.6.6
+- soap_transport_http: only include port in Host header if it was specified in the URL
+- soap_transport_http: add some code to use OpenSSL for PHP <A HREF="ssl://">ssl://</A> scheme, but comment out since it's not ready
+- soap_server: use $_SERVER['PHP_SELF'] if $GLOBALS['PHP_SELF'] is not set
+- wsdl: add WSDL request and response and transport debug to debug
+- wsdl: handle custom type extending xmlschema namespace (GLUE ... Thanks Matt)
+- soap_parser: add param to docs
+- soapclient: add getHTTPBody, getHTTPContentType, getHTTPContentTypeCharset (anticipating MIME subclass)
+
+2003-10-28, version 0.6.6
+- nusoap_base: add expandEntities method
+- wsdl: use expandEntities
+- soap_fault: use expandEntities
+- soap_transport_http: Allow credentials to be included in URL, rather than requiring setCredentials
+- soap_transport_http: Merge HTTP headers that span multiple lines
+- soap_parser: Properly set errors in ctor
+- soapclient: Pass headers to parseResponse and parse them in that method
+
+2003-10-30, version 0.6.6
+- xmlschema: Add some information for the related type to an element
+
+2003-12-09, version 0.6.6
+- nusoap_base: Add some namespace methods previously in xmlschema
+- xmlschema: Improve parsing of complexType, element and simpleType
+- xmlschema: Improve serialization
+- xmlschema: Track imports
+- xmlschema: Track elementFormDefault and form attributes
+- wsdl: Support multiple &lt;schema&gt; (note that setting $server-&gt;wsdl-&gt;schemaTargetNamespace no longer does anything!  Use configureWSDL instead.)
+- wsdl: Use form attribute of element to control namespace specification
+- wsdl: Support chained imports (A imports B which imports C)
+- wsdl: Include port in endpoint address when serializing
+- soap_server: Fix use of style (rpc|document) and use (encoded|literal)
+- soap_server: Support _SERVER[CONTENT_TYPE] in addition to _SERVER[HTTP_CONTENT_TYPE]
+- soap_server: Support wsdl with multiple &lt;schema&gt;
+- soap_client: Remove a var_dump
+- soap_client: Add style and use parameters to call method to support doc/lit without WSDL
+- soap_transport_http: Check that $this-&gt;fp exists when doing persistent connections
+
+2003-12-17, version 0.6.6
+- soap_server: pass namespaces to xmlschema constructor
+- wsdl: post-process after all imports
+- wsdl: remove some debug, add some error handling
+- xmlschema: allow enclosing namespaces to be specified in constructor
+- xmlschema: improve handling of compositors and simple types
+
+2004-01-08, version 0.6.6
+- soap_server: when requested WSDL is in a file, return to client using passthru (thanks Ingo Fischer)
+- soapclient: have proxy inherit more client state
+- soapclient: allow timeout and response timeout to be specified in the constructor
+- wsdl: allow timeout and response timeout to be specified in the constructor
+- soap_transport_http: allow response timeout to be specified in send and sendHTTPS
+
+2004-01-28, version 0.6.6
+- wsdl: add namespace for array and scalar when form is qualified
+- wsdl: fix a bug in which data type of complexType elements were ignored in serialization
+- wsdl: enhance handling of URLs with file scheme
+- wsdl: add addSimpleType
+- xmlschema: add addSimpleType
+- xmlschema: always set phpType elements
+- soapclient: allow a wsdl instance to be specified in constructor
+- soap_server: allow a wsdl instance to be specified in constructor (not tested!)
+- soap_server: fix default SOAPAction created in register method
+- soap_transport_http: accept chunking with LF separators in addition to CRLF.
+- wsdlcache: added class
+- nusoapmime: fix comments
+
+2004-02-23, version 0.6.6
+- soap_transport_http: don't try to unchunk cURL data, since cURL already does it
+- soap_transport_http: append CVS revision to version in User-Agent
+- wsdl: serialize boolean as true|false, not 1|0, to agree with XML Schema
+- soap_server: always exit() after returning WSDL
+- soap_server: use the WSDL URL scheme as the default endpoint URL scheme
+- soap_server: append CVS revision to version in X-SOAP-Server
+- nusoap_base: add (CVS) revision
+- wsdlcache: synchronize using a per-WSDL lock file (Thanks Ingo)
+- wsdlcache: add cache lifetime, after which cache contents are invalidated (Thanks Ingo)
+
+2004-03-15, version 0.6.6
+- nusoap_base: add isArraySimpleOrStruct method
+- soap_server: improve WSDL URL scheme determination
+- soap_server: only deflate/gzip payloads &gt; 1024 bytes
+- soap_server: fix parameter order in fault method (always used as faultcode, faultstring)
+- soap_server: refactor parse_request into multiple functions (for sanity)
+- soap_server: set the namespace on the Response element to the same as the request
+- soap_server: name the return value element 'return' by default
+- soap_server: added and documented data fields, so that service programmers can use them if desired
+- soap_parser: standardize parsing error message
+- soap_parser: fix document and responseHeaders so they are the correct XML text (as documented)
+- soap_transport_http: fix read from persistent connection
+- soapclient: clean up debugging for persistent connection
+- wsdl: enforce correct naming of messages parts when an associative array is used for parameters
+- wsdl: better serialization of null values
+- wsdl: standardize parsing error message
+- xmlschema: standardize parsing error message
+
+2004-03-24, version 0.6.7
+- soap_transport_http: add digest authentication (based on code by Kevin A. Miller)
+- xmlschema: improve parsing of import elements
+- wsdl: do schema imports even if there are no wsdl imports
+
+2004-04-12, version 0.6.7
+- wsdl: serialize multiple elements when maxOccurs=&quot;unbounded&quot; and value is an array
+- wsdl: serialize soapval values (used to force an XML type, e.g. when WSDL uses an abstract type)
+- nusoapmime: do not require nusoap.php (it is now the programmer's responsibility)
+
+2004-04-21, version 0.6.7
+- soap_parser: parse repeated element name into an array (de-serializes doc/lit array into a PHP array when there is more than 1 array element)
+- soap_server: do not wrap response in a response element for a document style service
+
+2004-04-30, version 0.6.7
+- soap_transport_http: allow digest auth params to be separated by &quot;,&quot; as well as &quot;, &quot;
+- soap_transport_http: re-initialize incoming headers for each response
+- soap_server: add methodreturnisliteralxml property to allow service function to return XML as a string
+- soapclient: improve rpc/literal support
+- soapclient: allow XML string as call params in addition to array
+- soapclient: support document style and literal encoding when not using WSDL
+
+2004-05-05, version 0.6.7
+- wsdl: serialize PHP objects for WSDL XML Schema complexTypes, in addition to associative arrays
+- wsdl: fix WSDL generation when there is no encodingStyle
+- soap_transport_http: suppress fsockopen warnings
+- soap_transport_http: detect socket timeouts when reading (0 bytes returned)
+- soap_transport_http: read chunked content &quot;in-line&quot; so it works on a persistent connection
+- nusoap_base: serialize boolean as true|false, not 1|0, to agree with XML Schema
+- nusoap_base: serialize array of struct differently than array of array
+
+2004-06-25, version 0.6.8
+- soap_server: prefer gzip to deflate, since IE does not like our deflate
+- soap_server: move webDescription to the wsdl class
+- soap_server: allow class and instance method calls for service (thanks Ingo Fischer and Roland Knall)
+- wsdl: get webDescription from the soap_server class
+- wsdl: allow compression from the server
+- wsdl: fix serialization of soapval without a type
+- wsdl: propagate debug value from query string to SOAP endpoint in programmatic WSDL generation
+- nusoap_base: add anyType, anySimpleType for 2001 XML Schema
+- nusoap_base: provide additional debug functions
+- soap_transport_http: ignore Content-Length when chunked encoding is used
+- soap_transport_http: remove ':' from username for Basic authentication (cf. RFC 2617)
+- soap_transport_http: urldecode username and password taken from URL
+- soap_transport_http: use raw inflate/deflate for IE/IIS compatibility, rather than having Zlib headers according to HTTP 1.1 spec
+- soap_transport_http: attempt to handle the case when both the service application and Web server compress the response
+- soapclient: when creating proxy methods, replace '.' in operation name with '__' in function name
+- soapclient: initialize requestHeaders in proxy
+- general: use new debug methods; never access debug_str directly
+
+2004-09-30, version 0.6.8
+- soapclient: do not allow getProxy call when WSDL is not used
+- soapclient: use ISO-8859-1 as the charset if not specified in the Content-Type header
+- soapclient: when an empty string is specified for the call namespace, do not put the method element in a namespace
+- soapclient: let soap_transport_http check for SSL support
+- soapclient: have proxy inherit soap_defencoding from the client from which it is generated
+- soapclient: do not assume that 'ns1' is an unused namespace prefix; always generate namespace prefixes randomly
+- soap_parser: compare any encoding in the XML declaration to the charset from the HTTP Content-Type header (thanks Ingo Fischer)
+- soap_parser: improve parse repeated element name into an array (de-serializes doc/lit array into a PHP array when there is more than 1 array element)
+- soap_server: use ISO-8859-1 as the charset if not specified in the Content-Type header
+- soap_server: allow suppression of automatic UTF-8 decoding
+- soap_server: fix a bug when call_user_func_array() is used
+- soap_transport_http: correct digest authentication through a proxy
+- wsdl: serialize SOAP-ENC types similarly to XSD types
+- xmlschema: force unprefixed type into default namespace
+- xmlschema: fix serialization of definition of simple types
+
+2004-10-01, version 0.6.8
+- soap_parser: handle default namespace attributes
+- soap_server: add default_utf8 field
+- soap_server: support literal encoding (with RPC style)
+- soap_transport_http: parse HTTP status and generate error for 300, 302-307, 400, 401-417, 501-505 (thanks for the idea Ghislain)
+- soap_transport_http: follow HTTP redirection (HTTP status 301 and Location header) (thanks for the idea Ghislain)
+- xmlschema: allow any attributes to be specified in an element of a complexType, e.g., abstract, default, form, minOccurs, maxOccurs, nillable (thanks Jirka Pech for the original patch)
+
+2004-10-02, version 0.6.8
+- soapclient: read/write cookies (thanks Ingo)
+- soap_server: change faultcode on non-resendable faults to Client
+- soap_transport_http: read/write cookies (thanks Ingo)
+
+2004-10-05, version 0.6.8
+- wsdl: add addElement method
+- wsdl: support the document style in the register method
+- xmlschema: parse unnamed simpleTypes, rather than ignoring them
+- xmlschema: include untyped elements when parsing a complexType
+- xmlschema: add addElement method
+
+2004-10-14, version 0.6.8
+- soapclient: support client certificates
+- soap_parser: deserialize attributes, prefixing names with &quot;!&quot;
+- soap_server: notify the client with HTML when WSDL is requested but not supported by service
+- soap_transport_http: support client certificates
+- wsdl: support defaults for elements of a complexType
+- wsdl: serialize elements from complexType extension base
+- wsdl: serialize data (associative array elements) as attributes according to XML Schema
+- xmlschema: record extension base if present for a complexType
+
+2004-12-15, version 0.6.8
+- nusoap_base: add 2000 XML Schema (rare, but used by Akamai)
+- soap_parser: avoid deserializing more common attributes that are not data
+- soap_parser: be lax when HTTP specifies ISO-8859-1 (the default) and XML specifies UTF-8 (the norm)
+- soap_server: account for the fact that get_class_methods returns methods in all lower case (thanks Steve Haldane)
+- soap_transport_http: parse digest info that includes '=' in the data (thanks Jinsuk Kim)
+- wsdl: feably handle some cases for literal serialization of form=&quot;unqualified&quot; elements
+- wsdl: don't serialize the decimal portion of a PHP double when the XML type is long
+- wsdl: fix serialization of attributes for complexType that is an extension
+- wsdlcache: enhance diagnostics
+- xmlschema: handle untyped elements
+- xmlschema: handle WSDL for SOAP Array that uses the base attribute plus a sequence of element
+
+2005-01-22, version 0.6.8
+- wsdl: allow an element in one schema to have a type from another schema
+
+2005-01-24, version 0.6.8
+- xmlschema: correctly parse nested complexType definitions
+
+2005-02-14, version 0.6.8
+- nusoap_base: fix a bug in which attributes were sometimes not serialized with a value
+- nusoap_base: improve serialization of null values (thanks Dominique Stender)
+- soap_parser: parse null values by handling the nil attribute (thanks Dominique Stender)
+- soap_server: set character encoding for a fault to be the same as for the server (thanks Mark Scott)
+- soap_server: correctly check for null value returned from method when WSDL is used (without WSDL, cannot distinguish whether NULL or void return is desired)
+- soapclient: for document style, call should always return an array rooted at the response part (all bets are off when there are multiple parts)
+- xmlschema: save enumeration values parsed from WSDL
+
+2005-02-10, version 0.6.9
+- soapclient: only set SOAP headers when they are specified in call params (so setHeaders still works)
+
+2005-04-04, version 0.6.9
+- soap_server: use get_class instead of is_a (thanks Thomas Noel)
+- soapclient: use get_class instead of is_a (thanks Thomas Noel)
+- soapclient: add setEndpoint method
+- soap_transport_http: fix client certificates (thanks Doug Anarino and Eryan Eriobowo)
+
+2005-04-29, version 0.6.9
+- nusoap_base: add global variable and methods for setting debug level
+- nusoap_base: use xsd:anyType instead of xsd:ur-type to serialize arrays with multiple element types (thanks Ingo Fischer)
+- nusoap_base: expand entities in attributes (thanks Gaetano Giunta)
+- soapclient: call parent constructor
+- soapval: call parent constructor
+- soap_fault: call parent constructor
+- soap_parser: call parent constructor
+- soap_server: assume get_class_methods always returns lower case for PHP 4.x only
+- soap_server: call parent constructor
+- soap_transport_http: do nothing in setEncoding if gzdeflate is not present (thanks Franck Touanen for pointing this out)
+- soap_transport_http: fix check for server request for digest authentication (thanks Mark Spavin)
+- soap_transport_http: call parent constructor
+- wsdl: fix documentation page popup of one method after another (thanks Owen)
+- wsdl: call parent constructor
+- wsdl: expand entities in attributes (thanks Gaetano Giunta)
+- xmlschema: call parent constructor
+
+2005-06-03, version 0.6.9
+- nusoap_base: serialize empty arrays as having elements xsd:anyType[0]
+- nusoap_base: add encodingStyle parameter to serializeEnvelope
+- nusoap_base: serialize xsi:type with nil values
+- nusoap_base: improve debug and comments
+- soap_parser: correctly parse an empty array to an empty array, not an empty string
+- soap_parser: improve debug and comments
+- soap_server: specify encodingStyle for envelope when WSDL is used
+- soapclient: factor out new getProxyClassCode method
+- soapclient: specify encodingStyle for envelope
+- soapclient: improve debug and comments
+- wsdl: add namespace for Apache SOAP types if a variable of such type is serialized
+- wsdl: serialize nil value for nillable elements when no value is provided
+- wsdl: serialize xsi:type with nil values
+- wsdl: copy attributes as well as elements to an element from its complexType
+- wsdl: specify encodingStyle for operations
+- wsdl: improve debug and comments
+- xmlschema: improve debug and comments
+
+2005-06-03, version 0.7.0
+- nusoap_base: improve debug and comments
+- nusoap_base: fix version, which should have been 0.7.0 since 2005-03-04
+
+2005-06-06, version 0.7.1
+- nusoap_base: adjust numeric element names for serialization, instead of forcing them to 'soapVal'
+- nusoapmime: add type=text/xml to multipart/related (thanks Emmanuel Cordonnier)
+- soap_fault: fix serialization of detail
+- soap_server: check required parameters for register method
+- soap_server: when getallheaders is used, massage header names
+- soap_server: use SOAPAction to determine operation when doc/lit service does not wrap parameters in an element with the method name (thanks Peter Hrastnik)
+- soap_transport_http: correctly handle multiple HTTP/1.1 100 responses for https (thanks Jan Slabon)
+- wsdl: fixed documentation for addComplexType (thanks Csintalan &#193;d&#225;m)
+- wsdl: serialize array data when maxOccurs = 'unbounded' OR maxOccurs &gt; 1 (thanks Dominique Schreckling)
+- wsdl: when serializing a string == 'false' as a boolean, set the value to false
+- wsdl: when serializing a complexType, require the PHP value supplied to be an array
+
+2005-07-01, version 0.7.1
+- nusoap_base: Allow SOAP headers to be supplied as an array like parameters
+- soap_parser: de-serialize simpleContent that accompanies complexContent
+- soap_server: append debug information when programmatically-defined WSDL is returned
+- soap_transport_http: Add debug when an outgoing header is set
+- soapclient: Allow SOAP headers to be supplied as an array like parameters
+- xmlschema: serialize attributes more generally, rather than assuming they are for SOAP 1.1 Array
+- wsdl: when serializing, look up types by namespace, not prefix (simple programmatic doc/lit WSDL now seems to work)
+- wsdl: process namespace declarations first when parsing an element
+
+2005-07-27, version 0.7.1
+- nusoap_base: do not override supplied element name with class name when serializing an object in serialize_val
+- nusoap_base: remove <A HREF="http://soapinterop.org/xsd">http://soapinterop.org/xsd</A> (si) from namespaces array
+- nusoapmime: add nusoapservermime class to implement MIME attachments on the server
+- soap_fault: improve documentation
+- soap_server: improve documentation
+- soap_server: make consistent use of _SERVER and HTTP_SERVER_VARS
+- soap_server: make all incoming HTTP header keys lower case
+- soap_server: add hook functions to support subclassing for MIME attachments
+- soap_transport_http: remove an unnecessary global statement
+- soapclient: when creating a proxy, make $params within each function an associative array
+- soapval: improve documentation
+- wsdl: when serializing complexType elements, used typed serialization if there is either a type or a reference for the element
+- wsdl: allow PHP objects to be serialized as SOAP structs in serializeType
+- wsdl: for WSDL and XML Schema imports, don't forget to use the TCP port number (thanks Luca GIOPPO)
+- wsdl: make consistent use of _SERVER and HTTP_SERVER_VARS
+- xmlschema: improve documentation
+
+2005-07-31, version 0.7.2
+- nusoap_base: correctly serialize attributes in serialize_val (thanks Hidran Arias)
+- soap_parser: when resolving references, do not assume that buildVal returns an array (thanks Akshell)
+- soap_parser: removed decode_entities, which does not work (thanks Martin Sarsale)
+- soap_server: fix a bug parsing headers from _SERVER and HTTP_SERVER_VARS (thanks Bert Catsburg)
+- soap_server: parse all &quot;headers&quot; from HTTP_SERVER_VARS (not just HTTP_*)
+- soap_server: use PHP_SELF instead of SCRIPT_NAME for WSDL endpoint
+- soap_server: when generating a fault while debug_flag is true, put debug into faultdetail
+- wsdl: add enumeration parameter to addSimpleType
+- xmlschema: add enumeration parameter to addSimpleType

Added: cms/trunk/includes/nusoap/class.nusoap_base.php
===================================================================
--- cms/trunk/includes/nusoap/class.nusoap_base.php	2005-09-20 21:46:50 UTC (rev 136)
+++ cms/trunk/includes/nusoap/class.nusoap_base.php	2005-09-21 03:53:30 UTC (rev 137)
@@ -0,0 +1,905 @@
+&lt;?php
+
+/*
+$Id: class.nusoap_base.php,v 1.43 2005/08/04 01:27:42 snichol Exp $
+
+NuSOAP - Web Services Toolkit for PHP
+
+Copyright (c) 2002 NuSphere Corporation
+
+This library is free software; you can redistribute it and/or
+modify it under the terms of the GNU Lesser General Public
+License as published by the Free Software Foundation; either
+version 2.1 of the License, or (at your option) any later version.
+
+This library is distributed in the hope that it will be useful,
+but WITHOUT ANY WARRANTY; without even the implied warranty of
+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+Lesser General Public License for more details.
+
+You should have received a copy of the GNU Lesser General Public
+License along with this library; if not, write to the Free Software
+Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
+
+If you have any questions or comments, please email:
+
+Dietrich Ayala
<A HREF="https://lists.berlios.de/mailman/listinfo/viperals-svncheckins">+dietrich at ganx4.com</A>
+<A HREF="http://dietrich.ganx4.com/nusoap">http://dietrich.ganx4.com/nusoap</A>
+
+NuSphere Corporation
+<A HREF="http://www.nusphere.com">http://www.nusphere.com</A>
+
+*/
+
+/* load classes
+
+// necessary classes
+require_once('class.soapclient.php');
+require_once('class.soap_val.php');
+require_once('class.soap_parser.php');
+require_once('class.soap_fault.php');
+
+// transport classes
+require_once('class.soap_transport_http.php');
+
+// optional add-on classes
+require_once('class.xmlschema.php');
+require_once('class.wsdl.php');
+
+// server class
+require_once('class.soap_server.php');*/
+
+// class variable emulation
+// cf. <A HREF="http://www.webkreator.com/php/techniques/php-static-class-variables.html">http://www.webkreator.com/php/techniques/php-static-class-variables.html</A>
+$GLOBALS['_transient']['static']['nusoap_base']-&gt;globalDebugLevel = 9;
+
+/**
+*
+* nusoap_base
+*
+* @author   Dietrich Ayala &lt;<A HREF="https://lists.berlios.de/mailman/listinfo/viperals-svncheckins">dietrich at ganx4.com</A>&gt;
+* @version  $Id: class.nusoap_base.php,v 1.43 2005/08/04 01:27:42 snichol Exp $
+* @access   public
+*/
+class nusoap_base {
+	/**
+	 * Identification for HTTP headers.
+	 *
+	 * @var string
+	 * @access private
+	 */
+	var $title = 'NuSOAP';
+	/**
+	 * Version for HTTP headers.
+	 *
+	 * @var string
+	 * @access private
+	 */
+	var $version = '0.7.2';
+	/**
+	 * CVS revision for HTTP headers.
+	 *
+	 * @var string
+	 * @access private
+	 */
+	var $revision = '$Revision: 1.43 $';
+    /**
+     * Current error string (manipulated by getError/setError)
+	 *
+	 * @var string
+	 * @access private
+	 */
+	var $error_str = '';
+    /**
+     * Current debug string (manipulated by debug/appendDebug/clearDebug/getDebug/getDebugAsXMLComment)
+	 *
+	 * @var string
+	 * @access private
+	 */
+    var $debug_str = '';
+    /**
+	 * toggles automatic encoding of special characters as entities
+	 * (should always be true, I think)
+	 *
+	 * @var boolean
+	 * @access private
+	 */
+	var $charencoding = true;
+	/**
+	 * the debug level for this instance
+	 *
+	 * @var	integer
+	 * @access private
+	 */
+	var $debugLevel;
+
+    /**
+	* set schema version
+	*
+	* @var      string
+	* @access   public
+	*/
+	var $XMLSchemaVersion = '<A HREF="http://www.w3.org/2001/XMLSchema">http://www.w3.org/2001/XMLSchema</A>';
+	
+    /**
+	* charset encoding for outgoing messages
+	*
+	* @var      string
+	* @access   public
+	*/
+    var $soap_defencoding = 'ISO-8859-1';
+	//var $soap_defencoding = 'UTF-8';
+
+	/**
+	* namespaces in an array of prefix =&gt; uri
+	*
+	* this is &quot;seeded&quot; by a set of constants, but it may be altered by code
+	*
+	* @var      array
+	* @access   public
+	*/
+	var $namespaces = array(
+		'SOAP-ENV' =&gt; '<A HREF="http://schemas.xmlsoap.org/soap/envelope/">http://schemas.xmlsoap.org/soap/envelope/</A>',
+		'xsd' =&gt; '<A HREF="http://www.w3.org/2001/XMLSchema">http://www.w3.org/2001/XMLSchema</A>',
+		'xsi' =&gt; '<A HREF="http://www.w3.org/2001/XMLSchema-instance">http://www.w3.org/2001/XMLSchema-instance</A>',
+		'SOAP-ENC' =&gt; '<A HREF="http://schemas.xmlsoap.org/soap/encoding/">http://schemas.xmlsoap.org/soap/encoding/</A>'
+		);
+
+	/**
+	* namespaces used in the current context, e.g. during serialization
+	*
+	* @var      array
+	* @access   private
+	*/
+	var $usedNamespaces = array();
+
+	/**
+	* XML Schema types in an array of uri =&gt; (array of xml type =&gt; php type)
+	* is this legacy yet?
+	* no, this is used by the xmlschema class to verify type =&gt; namespace mappings.
+	* @var      array
+	* @access   public
+	*/
+	var $typemap = array(
+	'<A HREF="http://www.w3.org/2001/XMLSchema">http://www.w3.org/2001/XMLSchema</A>' =&gt; array(
+		'string'=&gt;'string','boolean'=&gt;'boolean','float'=&gt;'double','double'=&gt;'double','decimal'=&gt;'double',
+		'duration'=&gt;'','dateTime'=&gt;'string','time'=&gt;'string','date'=&gt;'string','gYearMonth'=&gt;'',
+		'gYear'=&gt;'','gMonthDay'=&gt;'','gDay'=&gt;'','gMonth'=&gt;'','hexBinary'=&gt;'string','base64Binary'=&gt;'string',
+		// abstract &quot;any&quot; types
+		'anyType'=&gt;'string','anySimpleType'=&gt;'string',
+		// derived datatypes
+		'normalizedString'=&gt;'string','token'=&gt;'string','language'=&gt;'','NMTOKEN'=&gt;'','NMTOKENS'=&gt;'','Name'=&gt;'','NCName'=&gt;'','ID'=&gt;'',
+		'IDREF'=&gt;'','IDREFS'=&gt;'','ENTITY'=&gt;'','ENTITIES'=&gt;'','integer'=&gt;'integer','nonPositiveInteger'=&gt;'integer',
+		'negativeInteger'=&gt;'integer','long'=&gt;'integer','int'=&gt;'integer','short'=&gt;'integer','byte'=&gt;'integer','nonNegativeInteger'=&gt;'integer',
+		'unsignedLong'=&gt;'','unsignedInt'=&gt;'','unsignedShort'=&gt;'','unsignedByte'=&gt;'','positiveInteger'=&gt;''),
+	'<A HREF="http://www.w3.org/2000/10/XMLSchema">http://www.w3.org/2000/10/XMLSchema</A>' =&gt; array(
+		'i4'=&gt;'','int'=&gt;'integer','boolean'=&gt;'boolean','string'=&gt;'string','double'=&gt;'double',
+		'float'=&gt;'double','dateTime'=&gt;'string',
+		'timeInstant'=&gt;'string','base64Binary'=&gt;'string','base64'=&gt;'string','ur-type'=&gt;'array'),
+	'<A HREF="http://www.w3.org/1999/XMLSchema">http://www.w3.org/1999/XMLSchema</A>' =&gt; array(
+		'i4'=&gt;'','int'=&gt;'integer','boolean'=&gt;'boolean','string'=&gt;'string','double'=&gt;'double',
+		'float'=&gt;'double','dateTime'=&gt;'string',
+		'timeInstant'=&gt;'string','base64Binary'=&gt;'string','base64'=&gt;'string','ur-type'=&gt;'array'),
+	'<A HREF="http://soapinterop.org/xsd">http://soapinterop.org/xsd</A>' =&gt; array('SOAPStruct'=&gt;'struct'),
+	'<A HREF="http://schemas.xmlsoap.org/soap/encoding/">http://schemas.xmlsoap.org/soap/encoding/</A>' =&gt; array('base64'=&gt;'string','array'=&gt;'array','Array'=&gt;'array'),
+    '<A HREF="http://xml.apache.org/xml-soap">http://xml.apache.org/xml-soap</A>' =&gt; array('Map')
+	);
+
+	/**
+	* XML entities to convert
+	*
+	* @var      array
+	* @access   public
+	* @deprecated
+	* @see	expandEntities
+	*/
+	var $xmlEntities = array('quot' =&gt; '&quot;','amp' =&gt; '&amp;',
+		'lt' =&gt; '&lt;','gt' =&gt; '&gt;','apos' =&gt; &quot;'&quot;);
+
+	/**
+	* constructor
+	*
+	* @access	public
+	*/
+	function nusoap_base() {
+		$this-&gt;debugLevel = $GLOBALS['_transient']['static']['nusoap_base']-&gt;globalDebugLevel;
+	}
+
+	/**
+	* gets the global debug level, which applies to future instances
+	*
+	* @return	integer	Debug level 0-9, where 0 turns off
+	* @access	public
+	*/
+	function getGlobalDebugLevel() {
+		return $GLOBALS['_transient']['static']['nusoap_base']-&gt;globalDebugLevel;
+	}
+
+	/**
+	* sets the global debug level, which applies to future instances
+	*
+	* @param	int	$level	Debug level 0-9, where 0 turns off
+	* @access	public
+	*/
+	function setGlobalDebugLevel($level) {
+		$GLOBALS['_transient']['static']['nusoap_base']-&gt;globalDebugLevel = $level;
+	}
+
+	/**
+	* gets the debug level for this instance
+	*
+	* @return	int	Debug level 0-9, where 0 turns off
+	* @access	public
+	*/
+	function getDebugLevel() {
+		return $this-&gt;debugLevel;
+	}
+
+	/**
+	* sets the debug level for this instance
+	*
+	* @param	int	$level	Debug level 0-9, where 0 turns off
+	* @access	public
+	*/
+	function setDebugLevel($level) {
+		$this-&gt;debugLevel = $level;
+	}
+
+	/**
+	* adds debug data to the instance debug string with formatting
+	*
+	* @param    string $string debug data
+	* @access   private
+	*/
+	function debug($string){
+		if ($this-&gt;debugLevel &gt; 0) {
+			$this-&gt;appendDebug($this-&gt;getmicrotime().' '.get_class($this).&quot;: $string\n&quot;);
+		}
+	}
+
+	/**
+	* adds debug data to the instance debug string without formatting
+	*
+	* @param    string $string debug data
+	* @access   public
+	*/
+	function appendDebug($string){
+		if ($this-&gt;debugLevel &gt; 0) {
+			// it would be nice to use a memory stream here to use
+			// memory more efficiently
+			$this-&gt;debug_str .= $string;
+		}
+	}
+
+	/**
+	* clears the current debug data for this instance
+	*
+	* @access   public
+	*/
+	function clearDebug() {
+		// it would be nice to use a memory stream here to use
+		// memory more efficiently
+		$this-&gt;debug_str = '';
+	}
+
+	/**
+	* gets the current debug data for this instance
+	*
+	* @return   debug data
+	* @access   public
+	*/
+	function &amp;getDebug() {
+		// it would be nice to use a memory stream here to use
+		// memory more efficiently
+		return $this-&gt;debug_str;
+	}
+
+	/**
+	* gets the current debug data for this instance as an XML comment
+	* this may change the contents of the debug data
+	*
+	* @return   debug data as an XML comment
+	* @access   public
+	*/
+	function &amp;getDebugAsXMLComment() {
+		// it would be nice to use a memory stream here to use
+		// memory more efficiently
+		while (strpos($this-&gt;debug_str, '--')) {
+			$this-&gt;debug_str = str_replace('--', '- -', $this-&gt;debug_str);
+		}
+    	return &quot;&lt;!--\n&quot; . $this-&gt;debug_str . &quot;\n--&gt;&quot;;
+	}
+
+	/**
+	* expands entities, e.g. changes '&lt;' to '&lt;'.
+	*
+	* @param	string	$val	The string in which to expand entities.
+	* @access	private
+	*/
+	function expandEntities($val) {
+		if ($this-&gt;charencoding) {
+	    	$val = str_replace('&amp;', '&amp;', $val);
+	    	$val = str_replace(&quot;'&quot;, '&apos;', $val);
+	    	$val = str_replace('&quot;', '&quot;', $val);
+	    	$val = str_replace('&lt;', '&lt;', $val);
+	    	$val = str_replace('&gt;', '&gt;', $val);
+	    }
+	    return $val;
+	}
+
+	/**
+	* returns error string if present
+	*
+	* @return   mixed error string or false
+	* @access   public
+	*/
+	function getError(){
+		if($this-&gt;error_str != ''){
+			return $this-&gt;error_str;
+		}
+		return false;
+	}
+
+	/**
+	* sets error string
+	*
+	* @return   boolean $string error string
+	* @access   private
+	*/
+	function setError($str){
+		$this-&gt;error_str = $str;
+	}
+
+	/**
+	* detect if array is a simple array or a struct (associative array)
+	*
+	* @param	mixed	$val	The PHP array
+	* @return	string	(arraySimple|arrayStruct)
+	* @access	private
+	*/
+	function isArraySimpleOrStruct($val) {
+        $keyList = array_keys($val);
+		foreach ($keyList as $keyListValue) {
+			if (!is_int($keyListValue)) {
+				return 'arrayStruct';
+			}
+		}
+		return 'arraySimple';
+	}
+
+	/**
+	* serializes PHP values in accordance w/ section 5. Type information is
+	* not serialized if $use == 'literal'.
+	*
+	* @param	mixed	$val	The value to serialize
+	* @param	string	$name	The name (local part) of the XML element
+	* @param	string	$type	The XML schema type (local part) for the element
+	* @param	string	$name_ns	The namespace for the name of the XML element
+	* @param	string	$type_ns	The namespace for the type of the element
+	* @param	array	$attributes	The attributes to serialize as name=&gt;value pairs
+	* @param	string	$use	The WSDL &quot;use&quot; (encoded|literal)
+	* @return	string	The serialized element, possibly with child elements
+    * @access	public
+	*/
+	function serialize_val($val,$name=false,$type=false,$name_ns=false,$type_ns=false,$attributes=false,$use='encoded'){
+		$this-&gt;debug(&quot;in serialize_val: name=$name, type=$type, name_ns=$name_ns, type_ns=$type_ns, use=$use&quot;);
+		$this-&gt;appendDebug('value=' . $this-&gt;varDump($val));
+		$this-&gt;appendDebug('attributes=' . $this-&gt;varDump($attributes));
+		
+    	if(is_object($val) &amp;&amp; get_class($val) == 'soapval'){
+        	return $val-&gt;serialize($use);
+        }
+		// force valid name if necessary
+		if (is_numeric($name)) {
+			$name = '__numeric_' . $name;
+		} elseif (! $name) {
+			$name = 'noname';
+		}
+		// if name has ns, add ns prefix to name
+		$xmlns = '';
+        if($name_ns){
+			$prefix = 'nu'.rand(1000,9999);
+			$name = $prefix.':'.$name;
+			$xmlns .= &quot; xmlns:$prefix=\&quot;$name_ns\&quot;&quot;;
+		}
+		// if type is prefixed, create type prefix
+		if($type_ns != '' &amp;&amp; $type_ns == $this-&gt;namespaces['xsd']){
+			// need to fix this. shouldn't default to xsd if no ns specified
+		    // w/o checking against typemap
+			$type_prefix = 'xsd';
+		} elseif($type_ns){
+			$type_prefix = 'ns'.rand(1000,9999);
+			$xmlns .= &quot; xmlns:$type_prefix=\&quot;$type_ns\&quot;&quot;;
+		}
+		// serialize attributes if present
+		$atts = '';
+		if($attributes){
+			foreach($attributes as $k =&gt; $v){
+				$atts .= &quot; $k=\&quot;&quot;.$this-&gt;expandEntities($v).'&quot;';
+			}
+		}
+		// serialize null value
+		if (is_null($val)) {
+			if ($use == 'literal') {
+				// TODO: depends on minOccurs
+	        	return &quot;&lt;$name$xmlns $atts/&gt;&quot;;
+        	} else {
+				if (isset($type) &amp;&amp; isset($type_prefix)) {
+					$type_str = &quot; xsi:type=\&quot;$type_prefix:$type\&quot;&quot;;
+				} else {
+					$type_str = '';
+				}
+	        	return &quot;&lt;$name$xmlns$type_str $atts xsi:nil=\&quot;true\&quot;/&gt;&quot;;
+        	}
+		}
+        // serialize if an xsd built-in primitive type
+        if($type != '' &amp;&amp; isset($this-&gt;typemap[$this-&gt;XMLSchemaVersion][$type])){
+        	if (is_bool($val)) {
+        		if ($type == 'boolean') {
+	        		$val = $val ? 'true' : 'false';
+	        	} elseif (! $val) {
+	        		$val = 0;
+	        	}
+			} else if (is_string($val)) {
+				$val = $this-&gt;expandEntities($val);
+			}
+			if ($use == 'literal') {
+	        	return &quot;&lt;$name$xmlns $atts&gt;$val&lt;/$name&gt;&quot;;
+        	} else {
+	        	return &quot;&lt;$name$xmlns $atts xsi:type=\&quot;xsd:$type\&quot;&gt;$val&lt;/$name&gt;&quot;;
+        	}
+        }
+		// detect type and serialize
+		$xml = '';
+		switch(true) {
+			case (is_bool($val) || $type == 'boolean'):
+        		if ($type == 'boolean') {
+	        		$val = $val ? 'true' : 'false';
+	        	} elseif (! $val) {
+	        		$val = 0;
+	        	}
+				if ($use == 'literal') {
+					$xml .= &quot;&lt;$name$xmlns $atts&gt;$val&lt;/$name&gt;&quot;;
+				} else {
+					$xml .= &quot;&lt;$name$xmlns xsi:type=\&quot;xsd:boolean\&quot;$atts&gt;$val&lt;/$name&gt;&quot;;
+				}
+				break;
+			case (is_int($val) || is_long($val) || $type == 'int'):
+				if ($use == 'literal') {
+					$xml .= &quot;&lt;$name$xmlns $atts&gt;$val&lt;/$name&gt;&quot;;
+				} else {
+					$xml .= &quot;&lt;$name$xmlns xsi:type=\&quot;xsd:int\&quot;$atts&gt;$val&lt;/$name&gt;&quot;;
+				}
+				break;
+			case (is_float($val)|| is_double($val) || $type == 'float'):
+				if ($use == 'literal') {
+					$xml .= &quot;&lt;$name$xmlns $atts&gt;$val&lt;/$name&gt;&quot;;
+				} else {
+					$xml .= &quot;&lt;$name$xmlns xsi:type=\&quot;xsd:float\&quot;$atts&gt;$val&lt;/$name&gt;&quot;;
+				}
+				break;
+			case (is_string($val) || $type == 'string'):
+				$val = $this-&gt;expandEntities($val);
+				if ($use == 'literal') {
+					$xml .= &quot;&lt;$name$xmlns $atts&gt;$val&lt;/$name&gt;&quot;;
+				} else {
+					$xml .= &quot;&lt;$name$xmlns xsi:type=\&quot;xsd:string\&quot;$atts&gt;$val&lt;/$name&gt;&quot;;
+				}
+				break;
+			case is_object($val):
+				if (! $name) {
+					$name = get_class($val);
+					$this-&gt;debug(&quot;In serialize_val, used class name $name as element name&quot;);
+				} else {
+					$this-&gt;debug(&quot;In serialize_val, do not override name $name for element name for class &quot; . get_class($val));
+				}
+				foreach(get_object_vars($val) as $k =&gt; $v){
+					$pXml = isset($pXml) ? $pXml.$this-&gt;serialize_val($v,$k,false,false,false,false,$use) : $this-&gt;serialize_val($v,$k,false,false,false,false,$use);
+				}
+				$xml .= '&lt;'.$name.'&gt;'.$pXml.'&lt;/'.$name.'&gt;';
+				break;
+			break;
+			case (is_array($val) || $type):
+				// detect if struct or array
+				$valueType = $this-&gt;isArraySimpleOrStruct($val);
+                if($valueType=='arraySimple' || ereg('^ArrayOf',$type)){
+					$i = 0;
+					if(is_array($val) &amp;&amp; count($val)&gt; 0){
+						foreach($val as $v){
+	                    	if(is_object($v) &amp;&amp; get_class($v) ==  'soapval'){
+								$tt_ns = $v-&gt;type_ns;
+								$tt = $v-&gt;type;
+							} elseif (is_array($v)) {
+								$tt = $this-&gt;isArraySimpleOrStruct($v);
+							} else {
+								$tt = gettype($v);
+	                        }
+							$array_types[$tt] = 1;
+							// TODO: for literal, the name should be $name
+							$xml .= $this-&gt;serialize_val($v,'item',false,false,false,false,$use);
+							++$i;
+						}
+						if(count($array_types) &gt; 1){
+							$array_typename = 'xsd:anyType';
+						} elseif(isset($tt) &amp;&amp; isset($this-&gt;typemap[$this-&gt;XMLSchemaVersion][$tt])) {
+							if ($tt == 'integer') {
+								$tt = 'int';
+							}
+							$array_typename = 'xsd:'.$tt;
+						} elseif(isset($tt) &amp;&amp; $tt == 'arraySimple'){
+							$array_typename = 'SOAP-ENC:Array';
+						} elseif(isset($tt) &amp;&amp; $tt == 'arrayStruct'){
+							$array_typename = 'unnamed_struct_use_soapval';
+						} else {
+							// if type is prefixed, create type prefix
+							if ($tt_ns != '' &amp;&amp; $tt_ns == $this-&gt;namespaces['xsd']){
+								 $array_typename = 'xsd:' . $tt;
+							} elseif ($tt_ns) {
+								$tt_prefix = 'ns' . rand(1000, 9999);
+								$array_typename = &quot;$tt_prefix:$tt&quot;;
+								$xmlns .= &quot; xmlns:$tt_prefix=\&quot;$tt_ns\&quot;&quot;;
+							} else {
+								$array_typename = $tt;
+							}
+						}
+						$array_type = $i;
+						if ($use == 'literal') {
+							$type_str = '';
+						} else if (isset($type) &amp;&amp; isset($type_prefix)) {
+							$type_str = &quot; xsi:type=\&quot;$type_prefix:$type\&quot;&quot;;
+						} else {
+							$type_str = &quot; xsi:type=\&quot;SOAP-ENC:Array\&quot; SOAP-ENC:arrayType=\&quot;&quot;.$array_typename.&quot;[$array_type]\&quot;&quot;;
+						}
+					// empty array
+					} else {
+						if ($use == 'literal') {
+							$type_str = '';
+						} else if (isset($type) &amp;&amp; isset($type_prefix)) {
+							$type_str = &quot; xsi:type=\&quot;$type_prefix:$type\&quot;&quot;;
+						} else {
+							$type_str = &quot; xsi:type=\&quot;SOAP-ENC:Array\&quot; SOAP-ENC:arrayType=\&quot;xsd:anyType[0]\&quot;&quot;;
+						}
+					}
+					// TODO: for array in literal, there is no wrapper here
+					$xml = &quot;&lt;$name$xmlns$type_str$atts&gt;&quot;.$xml.&quot;&lt;/$name&gt;&quot;;
+				} else {
+					// got a struct
+					if(isset($type) &amp;&amp; isset($type_prefix)){
+						$type_str = &quot; xsi:type=\&quot;$type_prefix:$type\&quot;&quot;;
+					} else {
+						$type_str = '';
+					}
+					if ($use == 'literal') {
+						$xml .= &quot;&lt;$name$xmlns $atts&gt;&quot;;
+					} else {
+						$xml .= &quot;&lt;$name$xmlns$type_str$atts&gt;&quot;;
+					}
+					foreach($val as $k =&gt; $v){
+						// Apache Map
+						if ($type == 'Map' &amp;&amp; $type_ns == '<A HREF="http://xml.apache.org/xml-soap">http://xml.apache.org/xml-soap</A>') {
+							$xml .= '&lt;item&gt;';
+							$xml .= $this-&gt;serialize_val($k,'key',false,false,false,false,$use);
+							$xml .= $this-&gt;serialize_val($v,'value',false,false,false,false,$use);
+							$xml .= '&lt;/item&gt;';
+						} else {
+							$xml .= $this-&gt;serialize_val($v,$k,false,false,false,false,$use);
+						}
+					}
+					$xml .= &quot;&lt;/$name&gt;&quot;;
+				}
+				break;
+			default:
+				$xml .= 'not detected, got '.gettype($val).' for '.$val;
+				break;
+		}
+		return $xml;
+	}
+
+    /**
+    * serializes a message
+    *
+    * @param string $body the XML of the SOAP body
+    * @param mixed $headers optional string of XML with SOAP header content, or array of soapval objects for SOAP headers
+    * @param array $namespaces optional the namespaces used in generating the body and headers
+    * @param string $style optional (rpc|document)
+    * @param string $use optional (encoded|literal)
+    * @param string $encodingStyle optional (usually '<A HREF="http://schemas.xmlsoap.org/soap/encoding/">http://schemas.xmlsoap.org/soap/encoding/</A>' for encoded)
+    * @return string the message
+    * @access public
+    */
+    function serializeEnvelope($body,$headers=false,$namespaces=array(),$style='rpc',$use='encoded',$encodingStyle='<A HREF="http://schemas.xmlsoap.org/soap/encoding/">http://schemas.xmlsoap.org/soap/encoding/</A>'){
+    // TODO: add an option to automatically run utf8_encode on $body and $headers
+    // if $this-&gt;soap_defencoding is UTF-8.  Not doing this automatically allows
+    // one to send arbitrary UTF-8 characters, not just characters that map to ISO-8859-1
+
+	$this-&gt;debug(&quot;In serializeEnvelope length=&quot; . strlen($body) . &quot; body (max 1000 characters)=&quot; . substr($body, 0, 1000) . &quot; style=$style use=$use encodingStyle=$encodingStyle&quot;);
+	$this-&gt;debug(&quot;headers:&quot;);
+	$this-&gt;appendDebug($this-&gt;varDump($headers));
+	$this-&gt;debug(&quot;namespaces:&quot;);
+	$this-&gt;appendDebug($this-&gt;varDump($namespaces));
+
+	// serialize namespaces
+    $ns_string = '';
+	foreach(array_merge($this-&gt;namespaces,$namespaces) as $k =&gt; $v){
+		$ns_string .= &quot; xmlns:$k=\&quot;$v\&quot;&quot;;
+	}
+	if($encodingStyle) {
+		$ns_string = &quot; SOAP-ENV:encodingStyle=\&quot;$encodingStyle\&quot;$ns_string&quot;;
+	}
+
+	// serialize headers
+	if($headers){
+		if (is_array($headers)) {
+			$xml = '';
+			foreach ($headers as $header) {
+				$xml .= $this-&gt;serialize_val($header, false, false, false, false, false, $use);
+			}
+			$headers = $xml;
+			$this-&gt;debug(&quot;In serializeEnvelope, serialzied array of headers to $headers&quot;);
+		}
+		$headers = &quot;&lt;SOAP-ENV:Header&gt;&quot;.$headers.&quot;&lt;/SOAP-ENV:Header&gt;&quot;;
+	}
+	// serialize envelope
+	return
+	'&lt;?xml version=&quot;1.0&quot; encoding=&quot;'.$this-&gt;soap_defencoding .'&quot;?'.&quot;&gt;&quot;.
+	'&lt;SOAP-ENV:Envelope'.$ns_string.&quot;&gt;&quot;.
+	$headers.
+	&quot;&lt;SOAP-ENV:Body&gt;&quot;.
+		$body.
+	&quot;&lt;/SOAP-ENV:Body&gt;&quot;.
+	&quot;&lt;/SOAP-ENV:Envelope&gt;&quot;;
+    }
+
+	/**
+	 * formats a string to be inserted into an HTML stream
+	 *
+	 * @param string $str The string to format
+	 * @return string The formatted string
+	 * @access public
+	 * @deprecated
+	 */
+    function formatDump($str){
+		$str = htmlspecialchars($str);
+		return nl2br($str);
+    }
+
+	/**
+	* contracts (changes namespace to prefix) a qualified name
+	*
+	* @param    string $qname qname
+	* @return	string contracted qname
+	* @access   private
+	*/
+	function contractQname($qname){
+		// get element namespace
+		//$this-&gt;xdebug(&quot;Contract $qname&quot;);
+		if (strrpos($qname, ':')) {
+			// get unqualified name
+			$name = substr($qname, strrpos($qname, ':') + 1);
+			// get ns
+			$ns = substr($qname, 0, strrpos($qname, ':'));
+			$p = $this-&gt;getPrefixFromNamespace($ns);
+			if ($p) {
+				return $p . ':' . $name;
+			}
+			return $qname;
+		} else {
+			return $qname;
+		}
+	}
+
+	/**
+	* expands (changes prefix to namespace) a qualified name
+	*
+	* @param    string $string qname
+	* @return	string expanded qname
+	* @access   private
+	*/
+	function expandQname($qname){
+		// get element prefix
+		if(strpos($qname,':') &amp;&amp; !ereg('^<A HREF="http://">http://</A>',$qname)){
+			// get unqualified name
+			$name = substr(strstr($qname,':'),1);
+			// get ns prefix
+			$prefix = substr($qname,0,strpos($qname,':'));
+			if(isset($this-&gt;namespaces[$prefix])){
+				return $this-&gt;namespaces[$prefix].':'.$name;
+			} else {
+				return $qname;
+			}
+		} else {
+			return $qname;
+		}
+	}
+
+    /**
+    * returns the local part of a prefixed string
+    * returns the original string, if not prefixed
+    *
+    * @param string $str The prefixed string
+    * @return string The local part
+    * @access public
+    */
+	function getLocalPart($str){
+		if($sstr = strrchr($str,':')){
+			// get unqualified name
+			return substr( $sstr, 1 );
+		} else {
+			return $str;
+		}
+	}
+
+	/**
+    * returns the prefix part of a prefixed string
+    * returns false, if not prefixed
+    *
+    * @param string $str The prefixed string
+    * @return mixed The prefix or false if there is no prefix
+    * @access public
+    */
+	function getPrefix($str){
+		if($pos = strrpos($str,':')){
+			// get prefix
+			return substr($str,0,$pos);
+		}
+		return false;
+	}
+
+	/**
+    * pass it a prefix, it returns a namespace
+    *
+    * @param string $prefix The prefix
+    * @return mixed The namespace, false if no namespace has the specified prefix
+    * @access public
+    */
+	function getNamespaceFromPrefix($prefix){
+		if (isset($this-&gt;namespaces[$prefix])) {
+			return $this-&gt;namespaces[$prefix];
+		}
+		//$this-&gt;setError(&quot;No namespace registered for prefix '$prefix'&quot;);
+		return false;
+	}
+
+	/**
+    * returns the prefix for a given namespace (or prefix)
+    * or false if no prefixes registered for the given namespace
+    *
+    * @param string $ns The namespace
+    * @return mixed The prefix, false if the namespace has no prefixes
+    * @access public
+    */
+	function getPrefixFromNamespace($ns) {
+		foreach ($this-&gt;namespaces as $p =&gt; $n) {
+			if ($ns == $n || $ns == $p) {
+			    $this-&gt;usedNamespaces[$p] = $n;
+				return $p;
+			}
+		}
+		return false;
+	}
+
+	/**
+    * returns the time in ODBC canonical form with microseconds
+    *
+    * @return string The time in ODBC canonical form with microseconds
+    * @access public
+    */
+	function getmicrotime() {
+		if (function_exists('gettimeofday')) {
+			$tod = gettimeofday();
+			$sec = $tod['sec'];
+			$usec = $tod['usec'];
+		} else {
+			$sec = time();
+			$usec = 0;
+		}
+		return strftime('%Y-%m-%d %H:%M:%S', $sec) . '.' . sprintf('%06d', $usec);
+	}
+
+	/**
+	 * Returns a string with the output of var_dump
+	 *
+	 * @param mixed $data The variable to var_dump
+	 * @return string The output of var_dump
+	 * @access public
+	 */
+    function varDump($data) {
+		ob_start();
+		var_dump($data);
+		$ret_val = ob_get_contents();
+		ob_end_clean();
+		return $ret_val;
+	}
+}
+
+// XML Schema Datatype Helper Functions
+
+//xsd:dateTime helpers
+
+/**
+* convert unix timestamp to ISO 8601 compliant date string
+*
+* @param    string $timestamp Unix time stamp
+* @access   public
+*/
+function timestamp_to_iso8601($timestamp,$utc=true){
+	$datestr = date('Y-m-d\TH:i:sO',$timestamp);
+	if($utc){
+		$eregStr =
+		'([0-9]{4})-'.	// centuries &amp; years CCYY-
+		'([0-9]{2})-'.	// months MM-
+		'([0-9]{2})'.	// days DD
+		'T'.			// separator T
+		'([0-9]{2}):'.	// hours hh:
+		'([0-9]{2}):'.	// minutes mm:
+		'([0-9]{2})(\.[0-9]*)?'. // seconds ss.ss...
+		'(Z|[+\-][0-9]{2}:?[0-9]{2})?'; // Z to indicate UTC, -/+HH:MM:SS.SS... for local tz's
+
+		if(ereg($eregStr,$datestr,$regs)){
+			return sprintf('%04d-%02d-%02dT%02d:%02d:%02dZ',$regs[1],$regs[2],$regs[3],$regs[4],$regs[5],$regs[6]);
+		}
+		return false;
+	} else {
+		return $datestr;
+	}
+}
+
+/**
+* convert ISO 8601 compliant date string to unix timestamp
+*
+* @param    string $datestr ISO 8601 compliant date string
+* @access   public
+*/
+function iso8601_to_timestamp($datestr){
+	$eregStr =
+	'([0-9]{4})-'.	// centuries &amp; years CCYY-
+	'([0-9]{2})-'.	// months MM-
+	'([0-9]{2})'.	// days DD
+	'T'.			// separator T
+	'([0-9]{2}):'.	// hours hh:
+	'([0-9]{2}):'.	// minutes mm:
+	'([0-9]{2})(\.[0-9]+)?'. // seconds ss.ss...
+	'(Z|[+\-][0-9]{2}:?[0-9]{2})?'; // Z to indicate UTC, -/+HH:MM:SS.SS... for local tz's
+	if(ereg($eregStr,$datestr,$regs)){
+		// not utc
+		if($regs[8] != 'Z'){
+			$op = substr($regs[8],0,1);
+			$h = substr($regs[8],1,2);
+			$m = substr($regs[8],strlen($regs[8])-2,2);
+			if($op == '-'){
+				$regs[4] = $regs[4] + $h;
+				$regs[5] = $regs[5] + $m;
+			} elseif($op == '+'){
+				$regs[4] = $regs[4] - $h;
+				$regs[5] = $regs[5] - $m;
+			}
+		}
+		return strtotime(&quot;$regs[1]-$regs[2]-$regs[3] $regs[4]:$regs[5]:$regs[6]Z&quot;);
+	} else {
+		return false;
+	}
+}
+
+/**
+* sleeps some number of microseconds
+*
+* @param    string $usec the number of microseconds to sleep
+* @access   public
+* @deprecated
+*/
+function usleepWindows($usec)
+{
+	$start = gettimeofday();
+	
+	do
+	{
+		$stop = gettimeofday();
+		$timePassed = 1000000 * ($stop['sec'] - $start['sec'])
+		+ $stop['usec'] - $start['usec'];
+	}
+	while ($timePassed &lt; $usec);
+}
+
+
+?&gt;
\ No newline at end of file

Added: cms/trunk/includes/nusoap/class.soap_fault.php
===================================================================
--- cms/trunk/includes/nusoap/class.soap_fault.php	2005-09-20 21:46:50 UTC (rev 136)
+++ cms/trunk/includes/nusoap/class.soap_fault.php	2005-09-21 03:53:30 UTC (rev 137)
@@ -0,0 +1,86 @@
+&lt;?php
+
+
+
+
+/**
+* Contains information for a SOAP fault.
+* Mainly used for returning faults from deployed functions
+* in a server instance.
+* @author   Dietrich Ayala &lt;<A HREF="https://lists.berlios.de/mailman/listinfo/viperals-svncheckins">dietrich at ganx4.com</A>&gt;
+* @version  $Id: class.soap_fault.php,v 1.12 2005/07/27 19:24:42 snichol Exp $
+* @access public
+*/
+class soap_fault extends nusoap_base {
+	/**
+	 * The fault code (client|server)
+	 * @var string
+	 * @access private
+	 */
+	var $faultcode;
+	/**
+	 * The fault actor
+	 * @var string
+	 * @access private
+	 */
+	var $faultactor;
+	/**
+	 * The fault string, a description of the fault
+	 * @var string
+	 * @access private
+	 */
+	var $faultstring;
+	/**
+	 * The fault detail, typically a string or array of string
+	 * @var mixed
+	 * @access private
+	 */
+	var $faultdetail;
+
+	/**
+	* constructor
+    *
+    * @param string $faultcode (client | server)
+    * @param string $faultactor only used when msg routed between multiple actors
+    * @param string $faultstring human readable error message
+    * @param mixed $faultdetail detail, typically a string or array of string
+	*/
+	function soap_fault($faultcode,$faultactor='',$faultstring='',$faultdetail=''){
+		parent::nusoap_base();
+		$this-&gt;faultcode = $faultcode;
+		$this-&gt;faultactor = $faultactor;
+		$this-&gt;faultstring = $faultstring;
+		$this-&gt;faultdetail = $faultdetail;
+	}
+
+	/**
+	* serialize a fault
+	*
+	* @return	string	The serialization of the fault instance.
+	* @access   public
+	*/
+	function serialize(){
+		$ns_string = '';
+		foreach($this-&gt;namespaces as $k =&gt; $v){
+			$ns_string .= &quot;\n  xmlns:$k=\&quot;$v\&quot;&quot;;
+		}
+		$return_msg =
+			'&lt;?xml version=&quot;1.0&quot; encoding=&quot;'.$this-&gt;soap_defencoding.'&quot;?&gt;'.
+			'&lt;SOAP-ENV:Envelope SOAP-ENV:encodingStyle=&quot;<A HREF="http://schemas.xmlsoap.org/soap/encoding/">http://schemas.xmlsoap.org/soap/encoding/</A>&quot;'.$ns_string.&quot;&gt;\n&quot;.
+				'&lt;SOAP-ENV:Body&gt;'.
+				'&lt;SOAP-ENV:Fault&gt;'.
+					$this-&gt;serialize_val($this-&gt;faultcode, 'faultcode').
+					$this-&gt;serialize_val($this-&gt;faultactor, 'faultactor').
+					$this-&gt;serialize_val($this-&gt;faultstring, 'faultstring').
+					$this-&gt;serialize_val($this-&gt;faultdetail, 'detail').
+				'&lt;/SOAP-ENV:Fault&gt;'.
+				'&lt;/SOAP-ENV:Body&gt;'.
+			'&lt;/SOAP-ENV:Envelope&gt;';
+		return $return_msg;
+	}
+}
+
+
+
+
+?&gt;
\ No newline at end of file

Added: cms/trunk/includes/nusoap/class.soap_parser.php
===================================================================
--- cms/trunk/includes/nusoap/class.soap_parser.php	2005-09-20 21:46:50 UTC (rev 136)
+++ cms/trunk/includes/nusoap/class.soap_parser.php	2005-09-21 03:53:30 UTC (rev 137)
@@ -0,0 +1,599 @@
+&lt;?php
+
+
+
+
+/**
+*
+* soap_parser class parses SOAP XML messages into native PHP values
+*
+* @author   Dietrich Ayala &lt;<A HREF="https://lists.berlios.de/mailman/listinfo/viperals-svncheckins">dietrich at ganx4.com</A>&gt;
+* @version  $Id: class.soap_parser.php,v 1.36 2005/08/04 01:27:42 snichol Exp $
+* @access   public
+*/
+class soap_parser extends nusoap_base {
+
+	var $xml = '';
+	var $xml_encoding = '';
+	var $method = '';
+	var $root_struct = '';
+	var $root_struct_name = '';
+	var $root_struct_namespace = '';
+	var $root_header = '';
+    var $document = '';			// incoming SOAP body (text)
+	// determines where in the message we are (envelope,header,body,method)
+	var $status = '';
+	var $position = 0;
+	var $depth = 0;
+	var $default_namespace = '';
+	var $namespaces = array();
+	var $message = array();
+    var $parent = '';
+	var $fault = false;
+	var $fault_code = '';
+	var $fault_str = '';
+	var $fault_detail = '';
+	var $depth_array = array();
+	var $debug_flag = true;
+	var $soapresponse = NULL;
+	var $responseHeaders = '';	// incoming SOAP headers (text)
+	var $body_position = 0;
+	// for multiref parsing:
+	// array of id =&gt; pos
+	var $ids = array();
+	// array of id =&gt; hrefs =&gt; pos
+	var $multirefs = array();
+	// toggle for auto-decoding element content
+	var $decode_utf8 = true;
+
+	/**
+	* constructor that actually does the parsing
+	*
+	* @param    string $xml SOAP message
+	* @param    string $encoding character encoding scheme of message
+	* @param    string $method method for which XML is parsed (unused?)
+	* @param    string $decode_utf8 whether to decode UTF-8 to ISO-8859-1
+	* @access   public
+	*/
+	function soap_parser($xml,$encoding='UTF-8',$method='',$decode_utf8=true){
+		parent::nusoap_base();
+		$this-&gt;xml = $xml;
+		$this-&gt;xml_encoding = $encoding;
+		$this-&gt;method = $method;
+		$this-&gt;decode_utf8 = $decode_utf8;
+
+		// Check whether content has been read.
+		if(!empty($xml)){
+			// Check XML encoding
+			$pos_xml = strpos($xml, '&lt;?xml');
+			if ($pos_xml !== FALSE) {
+				$xml_decl = substr($xml, $pos_xml, strpos($xml, '?&gt;', $pos_xml + 2) - $pos_xml + 1);
+				if (preg_match(&quot;/encoding=[\&quot;']([^\&quot;']*)[\&quot;']/&quot;, $xml_decl, $res)) {
+					$xml_encoding = $res[1];
+					if (strtoupper($xml_encoding) != $encoding) {
+						$err = &quot;Charset from HTTP Content-Type '&quot; . $encoding . &quot;' does not match encoding from XML declaration '&quot; . $xml_encoding . &quot;'&quot;;
+						$this-&gt;debug($err);
+						if ($encoding != 'ISO-8859-1' || strtoupper($xml_encoding) != 'UTF-8') {
+							$this-&gt;setError($err);
+							return;
+						}
+						// when HTTP says ISO-8859-1 (the default) and XML says UTF-8 (the typical), assume the other endpoint is just sloppy and proceed
+					} else {
+						$this-&gt;debug('Charset from HTTP Content-Type matches encoding from XML declaration');
+					}
+				} else {
+					$this-&gt;debug('No encoding specified in XML declaration');
+				}
+			} else {
+				$this-&gt;debug('No XML declaration');
+			}
+			$this-&gt;debug('Entering soap_parser(), length='.strlen($xml).', encoding='.$encoding);
+			// Create an XML parser - why not xml_parser_create_ns?
+			$this-&gt;parser = xml_parser_create($this-&gt;xml_encoding);
+			// Set the options for parsing the XML data.
+			//xml_parser_set_option($parser, XML_OPTION_SKIP_WHITE, 1);
+			xml_parser_set_option($this-&gt;parser, XML_OPTION_CASE_FOLDING, 0);
+			xml_parser_set_option($this-&gt;parser, XML_OPTION_TARGET_ENCODING, $this-&gt;xml_encoding);
+			// Set the object for the parser.
+			xml_set_object($this-&gt;parser, $this);
+			// Set the element handlers for the parser.
+			xml_set_element_handler($this-&gt;parser, 'start_element','end_element');
+			xml_set_character_data_handler($this-&gt;parser,'character_data');
+
+			// Parse the XML file.
+			if(!xml_parse($this-&gt;parser,$xml,true)){
+			    // Display an error message.
+			    $err = sprintf('XML error parsing SOAP payload on line %d: %s',
+			    xml_get_current_line_number($this-&gt;parser),
+			    xml_error_string(xml_get_error_code($this-&gt;parser)));
+				$this-&gt;debug($err);
+				$this-&gt;debug(&quot;XML payload:\n&quot; . $xml);
+				$this-&gt;setError($err);
+			} else {
+				$this-&gt;debug('parsed successfully, found root struct: '.$this-&gt;root_struct.' of name '.$this-&gt;root_struct_name);
+				// get final value
+				$this-&gt;soapresponse = $this-&gt;message[$this-&gt;root_struct]['result'];
+				// get header value: no, because this is documented as XML string
+//				if($this-&gt;root_header != '' &amp;&amp; isset($this-&gt;message[$this-&gt;root_header]['result'])){
+//					$this-&gt;responseHeaders = $this-&gt;message[$this-&gt;root_header]['result'];
+//				}
+				// resolve hrefs/ids
+				if(sizeof($this-&gt;multirefs) &gt; 0){
+					foreach($this-&gt;multirefs as $id =&gt; $hrefs){
+						$this-&gt;debug('resolving multirefs for id: '.$id);
+						$idVal = $this-&gt;buildVal($this-&gt;ids[$id]);
+						if (is_array($idVal) &amp;&amp; isset($idVal['!id'])) {
+							unset($idVal['!id']);
+						}
+						foreach($hrefs as $refPos =&gt; $ref){
+							$this-&gt;debug('resolving href at pos '.$refPos);
+							$this-&gt;multirefs[$id][$refPos] = $idVal;
+						}
+					}
+				}
+			}
+			xml_parser_free($this-&gt;parser);
+		} else {
+			$this-&gt;debug('xml was empty, didn\'t parse!');
+			$this-&gt;setError('xml was empty, didn\'t parse!');
+		}
+	}
+
+	/**
+	* start-element handler
+	*
+	* @param    resource $parser XML parser object
+	* @param    string $name element name
+	* @param    array $attrs associative array of attributes
+	* @access   private
+	*/
+	function start_element($parser, $name, $attrs) {
+		// position in a total number of elements, starting from 0
+		// update class level pos
+		$pos = $this-&gt;position++;
+		// and set mine
+		$this-&gt;message[$pos] = array('pos' =&gt; $pos,'children'=&gt;'','cdata'=&gt;'');
+		// depth = how many levels removed from root?
+		// set mine as current global depth and increment global depth value
+		$this-&gt;message[$pos]['depth'] = $this-&gt;depth++;
+
+		// else add self as child to whoever the current parent is
+		if($pos != 0){
+			$this-&gt;message[$this-&gt;parent]['children'] .= '|'.$pos;
+		}
+		// set my parent
+		$this-&gt;message[$pos]['parent'] = $this-&gt;parent;
+		// set self as current parent
+		$this-&gt;parent = $pos;
+		// set self as current value for this depth
+		$this-&gt;depth_array[$this-&gt;depth] = $pos;
+		// get element prefix
+		if(strpos($name,':')){
+			// get ns prefix
+			$prefix = substr($name,0,strpos($name,':'));
+			// get unqualified name
+			$name = substr(strstr($name,':'),1);
+		}
+		// set status
+		if($name == 'Envelope'){
+			$this-&gt;status = 'envelope';
+		} elseif($name == 'Header'){
+			$this-&gt;root_header = $pos;
+			$this-&gt;status = 'header';
+		} elseif($name == 'Body'){
+			$this-&gt;status = 'body';
+			$this-&gt;body_position = $pos;
+		// set method
+		} elseif($this-&gt;status == 'body' &amp;&amp; $pos == ($this-&gt;body_position+1)){
+			$this-&gt;status = 'method';
+			$this-&gt;root_struct_name = $name;
+			$this-&gt;root_struct = $pos;
+			$this-&gt;message[$pos]['type'] = 'struct';
+			$this-&gt;debug(&quot;found root struct $this-&gt;root_struct_name, pos $this-&gt;root_struct&quot;);
+		}
+		// set my status
+		$this-&gt;message[$pos]['status'] = $this-&gt;status;
+		// set name
+		$this-&gt;message[$pos]['name'] = htmlspecialchars($name);
+		// set attrs
+		$this-&gt;message[$pos]['attrs'] = $attrs;
+
+		// loop through atts, logging ns and type declarations
+        $attstr = '';
+		foreach($attrs as $key =&gt; $value){
+        	$key_prefix = $this-&gt;getPrefix($key);
+			$key_localpart = $this-&gt;getLocalPart($key);
+			// if ns declarations, add to class level array of valid namespaces
+            if($key_prefix == 'xmlns'){
+				if(ereg('^<A HREF="http://www.w3.org/[0-9">http://www.w3.org/[0-9</A>]{4}/XMLSchema$',$value)){
+					$this-&gt;XMLSchemaVersion = $value;
+					$this-&gt;namespaces['xsd'] = $this-&gt;XMLSchemaVersion;
+					$this-&gt;namespaces['xsi'] = $this-&gt;XMLSchemaVersion.'-instance';
+				}
+                $this-&gt;namespaces[$key_localpart] = $value;
+				// set method namespace
+				if($name == $this-&gt;root_struct_name){
+					$this-&gt;methodNamespace = $value;
+				}
+			// if it's a type declaration, set type
+            } elseif($key_localpart == 'type'){
+            	$value_prefix = $this-&gt;getPrefix($value);
+                $value_localpart = $this-&gt;getLocalPart($value);
+				$this-&gt;message[$pos]['type'] = $value_localpart;
+				$this-&gt;message[$pos]['typePrefix'] = $value_prefix;
+                if(isset($this-&gt;namespaces[$value_prefix])){
+                	$this-&gt;message[$pos]['type_namespace'] = $this-&gt;namespaces[$value_prefix];
+                } else if(isset($attrs['xmlns:'.$value_prefix])) {
+					$this-&gt;message[$pos]['type_namespace'] = $attrs['xmlns:'.$value_prefix];
+                }
+				// should do something here with the namespace of specified type?
+			} elseif($key_localpart == 'arrayType'){
+				$this-&gt;message[$pos]['type'] = 'array';
+				/* do arrayType ereg here
+				[1]    arrayTypeValue    ::=    atype asize
+				[2]    atype    ::=    QName rank*
+				[3]    rank    ::=    '[' (',')* ']'
+				[4]    asize    ::=    '[' length~ ']'
+				[5]    length    ::=    nextDimension* Digit+
+				[6]    nextDimension    ::=    Digit+ ','
+				*/
+				$expr = '([A-Za-z0-9_]+):([A-Za-z]+[A-Za-z0-9_]+)\[([0-9]+),?([0-9]*)\]';
+				if(ereg($expr,$value,$regs)){
+					$this-&gt;message[$pos]['typePrefix'] = $regs[1];
+					$this-&gt;message[$pos]['arrayTypePrefix'] = $regs[1];
+	                if (isset($this-&gt;namespaces[$regs[1]])) {
+	                	$this-&gt;message[$pos]['arrayTypeNamespace'] = $this-&gt;namespaces[$regs[1]];
+	                } else if (isset($attrs['xmlns:'.$regs[1]])) {
+						$this-&gt;message[$pos]['arrayTypeNamespace'] = $attrs['xmlns:'.$regs[1]];
+	                }
+					$this-&gt;message[$pos]['arrayType'] = $regs[2];
+					$this-&gt;message[$pos]['arraySize'] = $regs[3];
+					$this-&gt;message[$pos]['arrayCols'] = $regs[4];
+				}
+			// specifies nil value (or not)
+			} elseif ($key_localpart == 'nil'){
+				$this-&gt;message[$pos]['nil'] = ($value == 'true' || $value == '1');
+			// some other attribute
+			} elseif ($key != 'href' &amp;&amp; $key != 'xmlns' &amp;&amp; $key_localpart != 'encodingStyle' &amp;&amp; $key_localpart != 'root') {
+				$this-&gt;message[$pos]['xattrs']['!' . $key] = $value;
+			}
+
+			if ($key == 'xmlns') {
+				$this-&gt;default_namespace = $value;
+			}
+			// log id
+			if($key == 'id'){
+				$this-&gt;ids[$value] = $pos;
+			}
+			// root
+			if($key_localpart == 'root' &amp;&amp; $value == 1){
+				$this-&gt;status = 'method';
+				$this-&gt;root_struct_name = $name;
+				$this-&gt;root_struct = $pos;
+				$this-&gt;debug(&quot;found root struct $this-&gt;root_struct_name, pos $pos&quot;);
+			}
+            // for doclit
+            $attstr .= &quot; $key=\&quot;$value\&quot;&quot;;
+		}
+        // get namespace - must be done after namespace atts are processed
+		if(isset($prefix)){
+			$this-&gt;message[$pos]['namespace'] = $this-&gt;namespaces[$prefix];
+			$this-&gt;default_namespace = $this-&gt;namespaces[$prefix];
+		} else {
+			$this-&gt;message[$pos]['namespace'] = $this-&gt;default_namespace;
+		}
+        if($this-&gt;status == 'header'){
+        	if ($this-&gt;root_header != $pos) {
+	        	$this-&gt;responseHeaders .= &quot;&lt;&quot; . (isset($prefix) ? $prefix . ':' : '') . &quot;$name$attstr&gt;&quot;;
+	        }
+        } elseif($this-&gt;root_struct_name != ''){
+        	$this-&gt;document .= &quot;&lt;&quot; . (isset($prefix) ? $prefix . ':' : '') . &quot;$name$attstr&gt;&quot;;
+        }
+	}
+
+	/**
+	* end-element handler
+	*
+	* @param    resource $parser XML parser object
+	* @param    string $name element name
+	* @access   private
+	*/
+	function end_element($parser, $name) {
+		// position of current element is equal to the last value left in depth_array for my depth
+		$pos = $this-&gt;depth_array[$this-&gt;depth--];
+
+        // get element prefix
+		if(strpos($name,':')){
+			// get ns prefix
+			$prefix = substr($name,0,strpos($name,':'));
+			// get unqualified name
+			$name = substr(strstr($name,':'),1);
+		}
+		
+		// build to native type
+		if(isset($this-&gt;body_position) &amp;&amp; $pos &gt; $this-&gt;body_position){
+			// deal w/ multirefs
+			if(isset($this-&gt;message[$pos]['attrs']['href'])){
+				// get id
+				$id = substr($this-&gt;message[$pos]['attrs']['href'],1);
+				// add placeholder to href array
+				$this-&gt;multirefs[$id][$pos] = 'placeholder';
+				// add set a reference to it as the result value
+				$this-&gt;message[$pos]['result'] =&amp; $this-&gt;multirefs[$id][$pos];
+            // build complexType values
+			} elseif($this-&gt;message[$pos]['children'] != ''){
+				// if result has already been generated (struct/array)
+				if(!isset($this-&gt;message[$pos]['result'])){
+					$this-&gt;message[$pos]['result'] = $this-&gt;buildVal($pos);
+				}
+			// build complexType values of attributes and possibly simpleContent
+			} elseif (isset($this-&gt;message[$pos]['xattrs'])) {
+				if (isset($this-&gt;message[$pos]['nil']) &amp;&amp; $this-&gt;message[$pos]['nil']) {
+					$this-&gt;message[$pos]['xattrs']['!'] = null;
+				} elseif (isset($this-&gt;message[$pos]['cdata']) &amp;&amp; trim($this-&gt;message[$pos]['cdata']) != '') {
+	            	if (isset($this-&gt;message[$pos]['type'])) {
+						$this-&gt;message[$pos]['xattrs']['!'] = $this-&gt;decodeSimple($this-&gt;message[$pos]['cdata'], $this-&gt;message[$pos]['type'], isset($this-&gt;message[$pos]['type_namespace']) ? $this-&gt;message[$pos]['type_namespace'] : '');
+					} else {
+						$parent = $this-&gt;message[$pos]['parent'];
+						if (isset($this-&gt;message[$parent]['type']) &amp;&amp; ($this-&gt;message[$parent]['type'] == 'array') &amp;&amp; isset($this-&gt;message[$parent]['arrayType'])) {
+							$this-&gt;message[$pos]['xattrs']['!'] = $this-&gt;decodeSimple($this-&gt;message[$pos]['cdata'], $this-&gt;message[$parent]['arrayType'], isset($this-&gt;message[$parent]['arrayTypeNamespace']) ? $this-&gt;message[$parent]['arrayTypeNamespace'] : '');
+						} else {
+							$this-&gt;message[$pos]['xattrs']['!'] = $this-&gt;message[$pos]['cdata'];
+						}
+					}
+				}
+				$this-&gt;message[$pos]['result'] = $this-&gt;message[$pos]['xattrs'];
+			// set value of simpleType (or nil complexType)
+			} else {
+            	//$this-&gt;debug('adding data for scalar value '.$this-&gt;message[$pos]['name'].' of value '.$this-&gt;message[$pos]['cdata']);
+				if (isset($this-&gt;message[$pos]['nil']) &amp;&amp; $this-&gt;message[$pos]['nil']) {
+					$this-&gt;message[$pos]['xattrs']['!'] = null;
+				} elseif (isset($this-&gt;message[$pos]['type'])) {
+					$this-&gt;message[$pos]['result'] = $this-&gt;decodeSimple($this-&gt;message[$pos]['cdata'], $this-&gt;message[$pos]['type'], isset($this-&gt;message[$pos]['type_namespace']) ? $this-&gt;message[$pos]['type_namespace'] : '');
+				} else {
+					$parent = $this-&gt;message[$pos]['parent'];
+					if (isset($this-&gt;message[$parent]['type']) &amp;&amp; ($this-&gt;message[$parent]['type'] == 'array') &amp;&amp; isset($this-&gt;message[$parent]['arrayType'])) {
+						$this-&gt;message[$pos]['result'] = $this-&gt;decodeSimple($this-&gt;message[$pos]['cdata'], $this-&gt;message[$parent]['arrayType'], isset($this-&gt;message[$parent]['arrayTypeNamespace']) ? $this-&gt;message[$parent]['arrayTypeNamespace'] : '');
+					} else {
+						$this-&gt;message[$pos]['result'] = $this-&gt;message[$pos]['cdata'];
+					}
+				}
+
+				/* add value to parent's result, if parent is struct/array
+				$parent = $this-&gt;message[$pos]['parent'];
+				if($this-&gt;message[$parent]['type'] != 'map'){
+					if(strtolower($this-&gt;message[$parent]['type']) == 'array'){
+						$this-&gt;message[$parent]['result'][] = $this-&gt;message[$pos]['result'];
+					} else {
+						$this-&gt;message[$parent]['result'][$this-&gt;message[$pos]['name']] = $this-&gt;message[$pos]['result'];
+					}
+				}
+				*/
+			}
+		}
+		
+        // for doclit
+        if($this-&gt;status == 'header'){
+        	if ($this-&gt;root_header != $pos) {
+	        	$this-&gt;responseHeaders .= &quot;&lt;/&quot; . (isset($prefix) ? $prefix . ':' : '') . &quot;$name&gt;&quot;;
+	        }
+        } elseif($pos &gt;= $this-&gt;root_struct){
+        	$this-&gt;document .= &quot;&lt;/&quot; . (isset($prefix) ? $prefix . ':' : '') . &quot;$name&gt;&quot;;
+        }
+		// switch status
+		if($pos == $this-&gt;root_struct){
+			$this-&gt;status = 'body';
+			$this-&gt;root_struct_namespace = $this-&gt;message[$pos]['namespace'];
+		} elseif($name == 'Body'){
+			$this-&gt;status = 'envelope';
+		 } elseif($name == 'Header'){
+			$this-&gt;status = 'envelope';
+		} elseif($name == 'Envelope'){
+			//
+		}
+		// set parent back to my parent
+		$this-&gt;parent = $this-&gt;message[$pos]['parent'];
+	}
+
+	/**
+	* element content handler
+	*
+	* @param    resource $parser XML parser object
+	* @param    string $data element content
+	* @access   private
+	*/
+	function character_data($parser, $data){
+		$pos = $this-&gt;depth_array[$this-&gt;depth];
+		if ($this-&gt;xml_encoding=='UTF-8'){
+			// TODO: add an option to disable this for folks who want
+			// raw UTF-8 that, e.g., might not map to iso-8859-1
+			// TODO: this can also be handled with xml_parser_set_option($this-&gt;parser, XML_OPTION_TARGET_ENCODING, &quot;ISO-8859-1&quot;);
+			if($this-&gt;decode_utf8){
+				$data = utf8_decode($data);
+			}
+		}
+        $this-&gt;message[$pos]['cdata'] .= $data;
+        // for doclit
+        if($this-&gt;status == 'header'){
+        	$this-&gt;responseHeaders .= $data;
+        } else {
+        	$this-&gt;document .= $data;
+        }
+	}
+
+	/**
+	* get the parsed message
+	*
+	* @return	mixed
+	* @access   public
+	*/
+	function get_response(){
+		return $this-&gt;soapresponse;
+	}
+
+	/**
+	* get the parsed headers
+	*
+	* @return	string XML or empty if no headers
+	* @access   public
+	*/
+	function getHeaders(){
+	    return $this-&gt;responseHeaders;
+	}
+
+	/**
+	* decodes simple types into PHP variables
+	*
+	* @param    string $value value to decode
+	* @param    string $type XML type to decode
+	* @param    string $typens XML type namespace to decode
+	* @return	mixed PHP value
+	* @access   private
+	*/
+	function decodeSimple($value, $type, $typens) {
+		// TODO: use the namespace!
+		if ((!isset($type)) || $type == 'string' || $type == 'long' || $type == 'unsignedLong') {
+			return (string) $value;
+		}
+		if ($type == 'int' || $type == 'integer' || $type == 'short' || $type == 'byte') {
+			return (int) $value;
+		}
+		if ($type == 'float' || $type == 'double' || $type == 'decimal') {
+			return (double) $value;
+		}
+		if ($type == 'boolean') {
+			if (strtolower($value) == 'false' || strtolower($value) == 'f') {
+				return false;
+			}
+			return (boolean) $value;
+		}
+		if ($type == 'base64' || $type == 'base64Binary') {
+			$this-&gt;debug('Decode base64 value');
+			return base64_decode($value);
+		}
+		// obscure numeric types
+		if ($type == 'nonPositiveInteger' || $type == 'negativeInteger'
+			|| $type == 'nonNegativeInteger' || $type == 'positiveInteger'
+			|| $type == 'unsignedInt'
+			|| $type == 'unsignedShort' || $type == 'unsignedByte') {
+			return (int) $value;
+		}
+		// bogus: parser treats array with no elements as a simple type
+		if ($type == 'array') {
+			return array();
+		}
+		// everything else
+		return (string) $value;
+	}
+
+	/**
+	* builds response structures for compound values (arrays/structs)
+	* and scalars
+	*
+	* @param    integer $pos position in node tree
+	* @return	mixed	PHP value
+	* @access   private
+	*/
+	function buildVal($pos){
+		if(!isset($this-&gt;message[$pos]['type'])){
+			$this-&gt;message[$pos]['type'] = '';
+		}
+		$this-&gt;debug('in buildVal() for '.$this-&gt;message[$pos]['name'].&quot;(pos $pos) of type &quot;.$this-&gt;message[$pos]['type']);
+		// if there are children...
+		if($this-&gt;message[$pos]['children'] != ''){
+			$this-&gt;debug('in buildVal, there are children');
+			$children = explode('|',$this-&gt;message[$pos]['children']);
+			array_shift($children); // knock off empty
+			// md array
+			if(isset($this-&gt;message[$pos]['arrayCols']) &amp;&amp; $this-&gt;message[$pos]['arrayCols'] != ''){
+            	$r=0; // rowcount
+            	$c=0; // colcount
+            	foreach($children as $child_pos){
+					$this-&gt;debug(&quot;in buildVal, got an MD array element: $r, $c&quot;);
+					$params[$r][] = $this-&gt;message[$child_pos]['result'];
+				    $c++;
+				    if($c == $this-&gt;message[$pos]['arrayCols']){
+				    	$c = 0;
+						$r++;
+				    }
+                }
+            // array
+			} elseif($this-&gt;message[$pos]['type'] == 'array' || $this-&gt;message[$pos]['type'] == 'Array'){
+                $this-&gt;debug('in buildVal, adding array '.$this-&gt;message[$pos]['name']);
+                foreach($children as $child_pos){
+                	$params[] = &amp;$this-&gt;message[$child_pos]['result'];
+                }
+            // apache Map type: java hashtable
+            } elseif($this-&gt;message[$pos]['type'] == 'Map' &amp;&amp; $this-&gt;message[$pos]['type_namespace'] == '<A HREF="http://xml.apache.org/xml-soap">http://xml.apache.org/xml-soap</A>'){
+                $this-&gt;debug('in buildVal, Java Map '.$this-&gt;message[$pos]['name']);
+                foreach($children as $child_pos){
+                	$kv = explode(&quot;|&quot;,$this-&gt;message[$child_pos]['children']);
+                   	$params[$this-&gt;message[$kv[1]]['result']] = &amp;$this-&gt;message[$kv[2]]['result'];
+                }
+            // generic compound type
+            //} elseif($this-&gt;message[$pos]['type'] == 'SOAPStruct' || $this-&gt;message[$pos]['type'] == 'struct') {
+		    } else {
+	    		// Apache Vector type: treat as an array
+                $this-&gt;debug('in buildVal, adding Java Vector '.$this-&gt;message[$pos]['name']);
+				if ($this-&gt;message[$pos]['type'] == 'Vector' &amp;&amp; $this-&gt;message[$pos]['type_namespace'] == '<A HREF="http://xml.apache.org/xml-soap">http://xml.apache.org/xml-soap</A>') {
+					$notstruct = 1;
+				} else {
+					$notstruct = 0;
+	            }
+            	//
+            	foreach($children as $child_pos){
+            		if($notstruct){
+            			$params[] = &amp;$this-&gt;message[$child_pos]['result'];
+            		} else {
+            			if (isset($params[$this-&gt;message[$child_pos]['name']])) {
+            				// de-serialize repeated element name into an array
+            				if ((!is_array($params[$this-&gt;message[$child_pos]['name']])) || (!isset($params[$this-&gt;message[$child_pos]['name']][0]))) {
+            					$params[$this-&gt;message[$child_pos]['name']] = array($params[$this-&gt;message[$child_pos]['name']]);
+            				}
+            				$params[$this-&gt;message[$child_pos]['name']][] = &amp;$this-&gt;message[$child_pos]['result'];
+            			} else {
+					    	$params[$this-&gt;message[$child_pos]['name']] = &amp;$this-&gt;message[$child_pos]['result'];
+					    }
+                	}
+                }
+			}
+			if (isset($this-&gt;message[$pos]['xattrs'])) {
+                $this-&gt;debug('in buildVal, handling attributes');
+				foreach ($this-&gt;message[$pos]['xattrs'] as $n =&gt; $v) {
+					$params[$n] = $v;
+				}
+			}
+			// handle simpleContent
+			if (isset($this-&gt;message[$pos]['cdata']) &amp;&amp; trim($this-&gt;message[$pos]['cdata']) != '') {
+                $this-&gt;debug('in buildVal, handling simpleContent');
+            	if (isset($this-&gt;message[$pos]['type'])) {
+					$params['!'] = $this-&gt;decodeSimple($this-&gt;message[$pos]['cdata'], $this-&gt;message[$pos]['type'], isset($this-&gt;message[$pos]['type_namespace']) ? $this-&gt;message[$pos]['type_namespace'] : '');
+				} else {
+					$parent = $this-&gt;message[$pos]['parent'];
+					if (isset($this-&gt;message[$parent]['type']) &amp;&amp; ($this-&gt;message[$parent]['type'] == 'array') &amp;&amp; isset($this-&gt;message[$parent]['arrayType'])) {
+						$params['!'] = $this-&gt;decodeSimple($this-&gt;message[$pos]['cdata'], $this-&gt;message[$parent]['arrayType'], isset($this-&gt;message[$parent]['arrayTypeNamespace']) ? $this-&gt;message[$parent]['arrayTypeNamespace'] : '');
+					} else {
+						$params['!'] = $this-&gt;message[$pos]['cdata'];
+					}
+				}
+			}
+			return is_array($params) ? $params : array();
+		} else {
+        	$this-&gt;debug('in buildVal, no children, building scalar');
+			$cdata = isset($this-&gt;message[$pos]['cdata']) ? $this-&gt;message[$pos]['cdata'] : '';
+        	if (isset($this-&gt;message[$pos]['type'])) {
+				return $this-&gt;decodeSimple($cdata, $this-&gt;message[$pos]['type'], isset($this-&gt;message[$pos]['type_namespace']) ? $this-&gt;message[$pos]['type_namespace'] : '');
+			}
+			$parent = $this-&gt;message[$pos]['parent'];
+			if (isset($this-&gt;message[$parent]['type']) &amp;&amp; ($this-&gt;message[$parent]['type'] == 'array') &amp;&amp; isset($this-&gt;message[$parent]['arrayType'])) {
+				return $this-&gt;decodeSimple($cdata, $this-&gt;message[$parent]['arrayType'], isset($this-&gt;message[$parent]['arrayTypeNamespace']) ? $this-&gt;message[$parent]['arrayTypeNamespace'] : '');
+			}
+           	return $this-&gt;message[$pos]['cdata'];
+		}
+	}
+}
+
+
+
+
+?&gt;
\ No newline at end of file

Added: cms/trunk/includes/nusoap/class.soap_server.php
===================================================================
--- cms/trunk/includes/nusoap/class.soap_server.php	2005-09-20 21:46:50 UTC (rev 136)
+++ cms/trunk/includes/nusoap/class.soap_server.php	2005-09-21 03:53:30 UTC (rev 137)
@@ -0,0 +1,1038 @@
+&lt;?php
+
+
+
+
+/**
+*
+* soap_server allows the user to create a SOAP server
+* that is capable of receiving messages and returning responses
+*
+* NOTE: WSDL functionality is experimental
+*
+* @author   Dietrich Ayala &lt;<A HREF="https://lists.berlios.de/mailman/listinfo/viperals-svncheckins">dietrich at ganx4.com</A>&gt;
+* @version  $Id: class.soap_server.php,v 1.48 2005/08/04 01:27:42 snichol Exp $
+* @access   public
+*/
+class soap_server extends nusoap_base {
+	/**
+	 * HTTP headers of request
+	 * @var array
+	 * @access private
+	 */
+	var $headers = array();
+	/**
+	 * HTTP request
+	 * @var string
+	 * @access private
+	 */
+	var $request = '';
+	/**
+	 * SOAP headers from request (incomplete namespace resolution; special characters not escaped) (text)
+	 * @var string
+	 * @access public
+	 */
+	var $requestHeaders = '';
+	/**
+	 * SOAP body request portion (incomplete namespace resolution; special characters not escaped) (text)
+	 * @var string
+	 * @access public
+	 */
+	var $document = '';
+	/**
+	 * SOAP payload for request (text)
+	 * @var string
+	 * @access public
+	 */
+	var $requestSOAP = '';
+	/**
+	 * requested method namespace URI
+	 * @var string
+	 * @access private
+	 */
+	var $methodURI = '';
+	/**
+	 * name of method requested
+	 * @var string
+	 * @access private
+	 */
+	var $methodname = '';
+	/**
+	 * method parameters from request
+	 * @var array
+	 * @access private
+	 */
+	var $methodparams = array();
+	/**
+	 * SOAP Action from request
+	 * @var string
+	 * @access private
+	 */
+	var $SOAPAction = '';
+	/**
+	 * character set encoding of incoming (request) messages
+	 * @var string
+	 * @access public
+	 */
+	var $xml_encoding = '';
+	/**
+	 * toggles whether the parser decodes element content w/ utf8_decode()
+	 * @var boolean
+	 * @access public
+	 */
+    var $decode_utf8 = true;
+
+	/**
+	 * HTTP headers of response
+	 * @var array
+	 * @access public
+	 */
+	var $outgoing_headers = array();
+	/**
+	 * HTTP response
+	 * @var string
+	 * @access private
+	 */
+	var $response = '';
+	/**
+	 * SOAP headers for response (text)
+	 * @var string
+	 * @access public
+	 */
+	var $responseHeaders = '';
+	/**
+	 * SOAP payload for response (text)
+	 * @var string
+	 * @access private
+	 */
+	var $responseSOAP = '';
+	/**
+	 * method return value to place in response
+	 * @var mixed
+	 * @access private
+	 */
+	var $methodreturn = false;
+	/**
+	 * whether $methodreturn is a string of literal XML
+	 * @var boolean
+	 * @access public
+	 */
+	var $methodreturnisliteralxml = false;
+	/**
+	 * SOAP fault for response (or false)
+	 * @var mixed
+	 * @access private
+	 */
+	var $fault = false;
+	/**
+	 * text indication of result (for debugging)
+	 * @var string
+	 * @access private
+	 */
+	var $result = 'successful';
+
+	/**
+	 * assoc array of operations =&gt; opData; operations are added by the register()
+	 * method or by parsing an external WSDL definition
+	 * @var array
+	 * @access private
+	 */
+	var $operations = array();
+	/**
+	 * wsdl instance (if one)
+	 * @var mixed
+	 * @access private
+	 */
+	var $wsdl = false;
+	/**
+	 * URL for WSDL (if one)
+	 * @var mixed
+	 * @access private
+	 */
+	var $externalWSDLURL = false;
+	/**
+	 * whether to append debug to response as XML comment
+	 * @var boolean
+	 * @access public
+	 */
+	var $debug_flag = false;
+
+
+	/**
+	* constructor
+    * the optional parameter is a path to a WSDL file that you'd like to bind the server instance to.
+	*
+    * @param mixed $wsdl file path or URL (string), or wsdl instance (object)
+	* @access   public
+	*/
+	function soap_server($wsdl=false){
+		parent::nusoap_base();
+		// turn on debugging?
+		global $debug;
+		global $HTTP_SERVER_VARS;
+
+		if (isset($_SERVER)) {
+			$this-&gt;debug(&quot;_SERVER is defined:&quot;);
+			$this-&gt;appendDebug($this-&gt;varDump($_SERVER));
+		} elseif (isset($HTTP_SERVER_VARS)) {
+			$this-&gt;debug(&quot;HTTP_SERVER_VARS is defined:&quot;);
+			$this-&gt;appendDebug($this-&gt;varDump($HTTP_SERVER_VARS));
+		} else {
+			$this-&gt;debug(&quot;Neither _SERVER nor HTTP_SERVER_VARS is defined.&quot;);
+		}
+
+		if (isset($debug)) {
+			$this-&gt;debug(&quot;In soap_server, set debug_flag=$debug based on global flag&quot;);
+			$this-&gt;debug_flag = $debug;
+		} elseif (isset($_SERVER['QUERY_STRING'])) {
+			$qs = explode('&amp;', $_SERVER['QUERY_STRING']);
+			foreach ($qs as $v) {
+				if (substr($v, 0, 6) == 'debug=') {
+					$this-&gt;debug(&quot;In soap_server, set debug_flag=&quot; . substr($v, 6) . &quot; based on query string #1&quot;);
+					$this-&gt;debug_flag = substr($v, 6);
+				}
+			}
+		} elseif (isset($HTTP_SERVER_VARS['QUERY_STRING'])) {
+			$qs = explode('&amp;', $HTTP_SERVER_VARS['QUERY_STRING']);
+			foreach ($qs as $v) {
+				if (substr($v, 0, 6) == 'debug=') {
+					$this-&gt;debug(&quot;In soap_server, set debug_flag=&quot; . substr($v, 6) . &quot; based on query string #2&quot;);
+					$this-&gt;debug_flag = substr($v, 6);
+				}
+			}
+		}
+
+		// wsdl
+		if($wsdl){
+			$this-&gt;debug(&quot;In soap_server, WSDL is specified&quot;);
+			if (is_object($wsdl) &amp;&amp; (get_class($wsdl) == 'wsdl')) {
+				$this-&gt;wsdl = $wsdl;
+				$this-&gt;externalWSDLURL = $this-&gt;wsdl-&gt;wsdl;
+				$this-&gt;debug('Use existing wsdl instance from ' . $this-&gt;externalWSDLURL);
+			} else {
+				$this-&gt;debug('Create wsdl from ' . $wsdl);
+				$this-&gt;wsdl = new wsdl($wsdl);
+				$this-&gt;externalWSDLURL = $wsdl;
+			}
+			$this-&gt;appendDebug($this-&gt;wsdl-&gt;getDebug());
+			$this-&gt;wsdl-&gt;clearDebug();
+			if($err = $this-&gt;wsdl-&gt;getError()){
+				die('WSDL ERROR: '.$err);
+			}
+		}
+	}
+
+	/**
+	* processes request and returns response
+	*
+	* @param    string $data usually is the value of $HTTP_RAW_POST_DATA
+	* @access   public
+	*/
+	function service($data){
+		global $HTTP_SERVER_VARS;
+
+		if (isset($_SERVER['QUERY_STRING'])) {
+			$qs = $_SERVER['QUERY_STRING'];
+		} elseif (isset($HTTP_SERVER_VARS['QUERY_STRING'])) {
+			$qs = $HTTP_SERVER_VARS['QUERY_STRING'];
+		} else {
+			$qs = '';
+		}
+		$this-&gt;debug(&quot;In service, query string=$qs&quot;);
+
+		if (ereg('wsdl', $qs) ){
+			$this-&gt;debug(&quot;In service, this is a request for WSDL&quot;);
+			if($this-&gt;externalWSDLURL){
+              if (strpos($this-&gt;externalWSDLURL,&quot;://&quot;)!==false) { // assume URL
+				header('Location: '.$this-&gt;externalWSDLURL);
+              } else { // assume file
+                header(&quot;Content-Type: text/xml\r\n&quot;);
+                $fp = fopen($this-&gt;externalWSDLURL, 'r');
+                fpassthru($fp);
+              }
+			} elseif ($this-&gt;wsdl) {
+				header(&quot;Content-Type: text/xml; charset=ISO-8859-1\r\n&quot;);
+				print $this-&gt;wsdl-&gt;serialize($this-&gt;debug_flag);
+				if ($this-&gt;debug_flag) {
+					$this-&gt;debug('wsdl:');
+					$this-&gt;appendDebug($this-&gt;varDump($this-&gt;wsdl));
+					print $this-&gt;getDebugAsXMLComment();
+				}
+			} else {
+				header(&quot;Content-Type: text/html; charset=ISO-8859-1\r\n&quot;);
+				print &quot;This service does not provide WSDL&quot;;
+			}
+		} elseif ($data == '' &amp;&amp; $this-&gt;wsdl) {
+			$this-&gt;debug(&quot;In service, there is no data, so return Web description&quot;);
+			print $this-&gt;wsdl-&gt;webDescription();
+		} else {
+			$this-&gt;debug(&quot;In service, invoke the request&quot;);
+			$this-&gt;parse_request($data);
+			if (! $this-&gt;fault) {
+				$this-&gt;invoke_method();
+			}
+			if (! $this-&gt;fault) {
+				$this-&gt;serialize_return();
+			}
+			$this-&gt;send_response();
+		}
+	}
+
+	/**
+	* parses HTTP request headers.
+	*
+	* The following fields are set by this function (when successful)
+	*
+	* headers
+	* request
+	* xml_encoding
+	* SOAPAction
+	*
+	* @access   private
+	*/
+	function parse_http_headers() {
+		global $HTTP_SERVER_VARS;
+
+		$this-&gt;request = '';
+		$this-&gt;SOAPAction = '';
+		if(function_exists('getallheaders')){
+			$this-&gt;debug(&quot;In parse_http_headers, use getallheaders&quot;);
+			$headers = getallheaders();
+			foreach($headers as $k=&gt;$v){
+				$k = strtolower($k);
+				$this-&gt;headers[$k] = $v;
+				$this-&gt;request .= &quot;$k: $v\r\n&quot;;
+				$this-&gt;debug(&quot;$k: $v&quot;);
+			}
+			// get SOAPAction header
+			if(isset($this-&gt;headers['soapaction'])){
+				$this-&gt;SOAPAction = str_replace('&quot;','',$this-&gt;headers['soapaction']);
+			}
+			// get the character encoding of the incoming request
+			if(isset($this-&gt;headers['content-type']) &amp;&amp; strpos($this-&gt;headers['content-type'],'=')){
+				$enc = str_replace('&quot;','',substr(strstr($this-&gt;headers[&quot;content-type&quot;],'='),1));
+				if(eregi('^(ISO-8859-1|US-ASCII|UTF-8)$',$enc)){
+					$this-&gt;xml_encoding = strtoupper($enc);
+				} else {
+					$this-&gt;xml_encoding = 'US-ASCII';
+				}
+			} else {
+				// should be US-ASCII for HTTP 1.0 or ISO-8859-1 for HTTP 1.1
+				$this-&gt;xml_encoding = 'ISO-8859-1';
+			}
+		} elseif(isset($_SERVER) &amp;&amp; is_array($_SERVER)){
+			$this-&gt;debug(&quot;In parse_http_headers, use _SERVER&quot;);
+			foreach ($_SERVER as $k =&gt; $v) {
+				if (substr($k, 0, 5) == 'HTTP_') {
+					$k = str_replace(' ', '-', strtolower(str_replace('_', ' ', substr($k, 5)))); 	                                         $k = strtolower(substr($k, 5));
+				} else {
+					$k = str_replace(' ', '-', strtolower(str_replace('_', ' ', $k))); 	                                         $k = strtolower($k);
+				}
+				if ($k == 'soapaction') {
+					// get SOAPAction header
+					$k = 'SOAPAction';
+					$v = str_replace('&quot;', '', $v);
+					$v = str_replace('\\', '', $v);
+					$this-&gt;SOAPAction = $v;
+				} else if ($k == 'content-type') {
+					// get the character encoding of the incoming request
+					if (strpos($v, '=')) {
+						$enc = substr(strstr($v, '='), 1);
+						$enc = str_replace('&quot;', '', $enc);
+						$enc = str_replace('\\', '', $enc);
+						if (eregi('^(ISO-8859-1|US-ASCII|UTF-8)$', $enc)) {
+							$this-&gt;xml_encoding = strtoupper($enc);
+						} else {
+							$this-&gt;xml_encoding = 'US-ASCII';
+						}
+					} else {
+						// should be US-ASCII for HTTP 1.0 or ISO-8859-1 for HTTP 1.1
+						$this-&gt;xml_encoding = 'ISO-8859-1';
+					}
+				}
+				$this-&gt;headers[$k] = $v;
+				$this-&gt;request .= &quot;$k: $v\r\n&quot;;
+				$this-&gt;debug(&quot;$k: $v&quot;);
+			}
+		} elseif (is_array($HTTP_SERVER_VARS)) {
+			$this-&gt;debug(&quot;In parse_http_headers, use HTTP_SERVER_VARS&quot;);
+			foreach ($HTTP_SERVER_VARS as $k =&gt; $v) {
+				if (substr($k, 0, 5) == 'HTTP_') {
+					$k = str_replace(' ', '-', strtolower(str_replace('_', ' ', substr($k, 5)))); 	                                         $k = strtolower(substr($k, 5));
+				} else {
+					$k = str_replace(' ', '-', strtolower(str_replace('_', ' ', $k))); 	                                         $k = strtolower($k);
+				}
+				if ($k == 'soapaction') {
+					// get SOAPAction header
+					$k = 'SOAPAction';
+					$v = str_replace('&quot;', '', $v);
+					$v = str_replace('\\', '', $v);
+					$this-&gt;SOAPAction = $v;
+				} else if ($k == 'content-type') {
+					// get the character encoding of the incoming request
+					if (strpos($v, '=')) {
+						$enc = substr(strstr($v, '='), 1);
+						$enc = str_replace('&quot;', '', $enc);
+						$enc = str_replace('\\', '', $enc);
+						if (eregi('^(ISO-8859-1|US-ASCII|UTF-8)$', $enc)) {
+							$this-&gt;xml_encoding = strtoupper($enc);
+						} else {
+							$this-&gt;xml_encoding = 'US-ASCII';
+						}
+					} else {
+						// should be US-ASCII for HTTP 1.0 or ISO-8859-1 for HTTP 1.1
+						$this-&gt;xml_encoding = 'ISO-8859-1';
+					}
+				}
+				$this-&gt;headers[$k] = $v;
+				$this-&gt;request .= &quot;$k: $v\r\n&quot;;
+				$this-&gt;debug(&quot;$k: $v&quot;);
+			}
+		} else {
+			$this-&gt;debug(&quot;In parse_http_headers, HTTP headers not accessible&quot;);
+			$this-&gt;setError(&quot;HTTP headers not accessible&quot;);
+		}
+	}
+
+	/**
+	* parses a request
+	*
+	* The following fields are set by this function (when successful)
+	*
+	* headers
+	* request
+	* xml_encoding
+	* SOAPAction
+	* request
+	* requestSOAP
+	* methodURI
+	* methodname
+	* methodparams
+	* requestHeaders
+	* document
+	*
+	* This sets the fault field on error
+	*
+	* @param    string $data XML string
+	* @access   private
+	*/
+	function parse_request($data='') {
+		$this-&gt;debug('entering parse_request()');
+		$this-&gt;parse_http_headers();
+		$this-&gt;debug('got character encoding: '.$this-&gt;xml_encoding);
+		// uncompress if necessary
+		if (isset($this-&gt;headers['content-encoding']) &amp;&amp; $this-&gt;headers['content-encoding'] != '') {
+			$this-&gt;debug('got content encoding: ' . $this-&gt;headers['content-encoding']);
+			if ($this-&gt;headers['content-encoding'] == 'deflate' || $this-&gt;headers['content-encoding'] == 'gzip') {
+		    	// if decoding works, use it. else assume data wasn't gzencoded
+				if (function_exists('gzuncompress')) {
+					if ($this-&gt;headers['content-encoding'] == 'deflate' &amp;&amp; $degzdata = @gzuncompress($data)) {
+						$data = $degzdata;
+					} elseif ($this-&gt;headers['content-encoding'] == 'gzip' &amp;&amp; $degzdata = gzinflate(substr($data, 10))) {
+						$data = $degzdata;
+					} else {
+						$this-&gt;fault('Client', 'Errors occurred when trying to decode the data');
+						return;
+					}
+				} else {
+					$this-&gt;fault('Client', 'This Server does not support compressed data');
+					return;
+				}
+			}
+		}
+		$this-&gt;request .= &quot;\r\n&quot;.$data;
+		$data = $this-&gt;parseRequest($this-&gt;headers, $data);
+		$this-&gt;requestSOAP = $data;
+		$this-&gt;debug('leaving parse_request');
+	}
+
+	/**
+	* invokes a PHP function for the requested SOAP method
+	*
+	* The following fields are set by this function (when successful)
+	*
+	* methodreturn
+	*
+	* Note that the PHP function that is called may also set the following
+	* fields to affect the response sent to the client
+	*
+	* responseHeaders
+	* outgoing_headers
+	*
+	* This sets the fault field on error
+	*
+	* @access   private
+	*/
+	function invoke_method() {
+		$this-&gt;debug('in invoke_method, methodname=' . $this-&gt;methodname . ' methodURI=' . $this-&gt;methodURI . ' SOAPAction=' . $this-&gt;SOAPAction);
+
+		if ($this-&gt;wsdl) {
+			if ($this-&gt;opData = $this-&gt;wsdl-&gt;getOperationData($this-&gt;methodname)) {
+				$this-&gt;debug('in invoke_method, found WSDL operation=' . $this-&gt;methodname);
+				$this-&gt;appendDebug('opData=' . $this-&gt;varDump($this-&gt;opData));
+			} elseif ($this-&gt;opData = $this-&gt;wsdl-&gt;getOperationDataForSoapAction($this-&gt;SOAPAction)) {
+				// Note: hopefully this case will only be used for doc/lit, since rpc services should have wrapper element
+				$this-&gt;debug('in invoke_method, found WSDL soapAction=' . $this-&gt;SOAPAction . ' for operation=' . $this-&gt;opData['name']);
+				$this-&gt;appendDebug('opData=' . $this-&gt;varDump($this-&gt;opData));
+				$this-&gt;methodname = $this-&gt;opData['name'];
+			} else {
+				$this-&gt;debug('in invoke_method, no WSDL for operation=' . $this-&gt;methodname);
+				$this-&gt;fault('Client', &quot;Operation '&quot; . $this-&gt;methodname . &quot;' is not defined in the WSDL for this service&quot;);
+				return;
+			}
+		} else {
+			$this-&gt;debug('in invoke_method, no WSDL to validate method');
+		}
+
+		// if a . is present in $this-&gt;methodname, we see if there is a class in scope,
+		// which could be referred to. We will also distinguish between two deliminators,
+		// to allow methods to be called a the class or an instance
+		$class = '';
+		$method = '';
+		if (strpos($this-&gt;methodname, '..') &gt; 0) {
+			$delim = '..';
+		} else if (strpos($this-&gt;methodname, '.') &gt; 0) {
+			$delim = '.';
+		} else {
+			$delim = '';
+		}
+
+		if (strlen($delim) &gt; 0 &amp;&amp; substr_count($this-&gt;methodname, $delim) == 1 &amp;&amp;
+			class_exists(substr($this-&gt;methodname, 0, strpos($this-&gt;methodname, $delim)))) {
+			// get the class and method name
+			$class = substr($this-&gt;methodname, 0, strpos($this-&gt;methodname, $delim));
+			$method = substr($this-&gt;methodname, strpos($this-&gt;methodname, $delim) + strlen($delim));
+			$this-&gt;debug(&quot;in invoke_method, class=$class method=$method delim=$delim&quot;);
+		}
+
+		// does method exist?
+		if ($class == '') {
+			if (!function_exists($this-&gt;methodname)) {
+				$this-&gt;debug(&quot;in invoke_method, function '$this-&gt;methodname' not found!&quot;);
+				$this-&gt;result = 'fault: method not found';
+				$this-&gt;fault('Client',&quot;method '$this-&gt;methodname' not defined in service&quot;);
+				return;
+			}
+		} else {
+			$method_to_compare = (substr(phpversion(), 0, 2) == '4.') ? strtolower($method) : $method;
+			if (!in_array($method_to_compare, get_class_methods($class))) {
+				$this-&gt;debug(&quot;in invoke_method, method '$this-&gt;methodname' not found in class '$class'!&quot;);
+				$this-&gt;result = 'fault: method not found';
+				$this-&gt;fault('Client',&quot;method '$this-&gt;methodname' not defined in service&quot;);
+				return;
+			}
+		}
+
+		// evaluate message, getting back parameters
+		// verify that request parameters match the method's signature
+		if(! $this-&gt;verify_method($this-&gt;methodname,$this-&gt;methodparams)){
+			// debug
+			$this-&gt;debug('ERROR: request not verified against method signature');
+			$this-&gt;result = 'fault: request failed validation against method signature';
+			// return fault
+			$this-&gt;fault('Client',&quot;Operation '$this-&gt;methodname' not defined in service.&quot;);
+			return;
+		}
+
+		// if there are parameters to pass
+		$this-&gt;debug('in invoke_method, params:');
+		$this-&gt;appendDebug($this-&gt;varDump($this-&gt;methodparams));
+		$this-&gt;debug(&quot;in invoke_method, calling '$this-&gt;methodname'&quot;);
+		if (!function_exists('call_user_func_array')) {
+			if ($class == '') {
+				$this-&gt;debug('in invoke_method, calling function using eval()');
+				$funcCall = &quot;\$this-&gt;methodreturn = $this-&gt;methodname(&quot;;
+			} else {
+				if ($delim == '..') {
+					$this-&gt;debug('in invoke_method, calling class method using eval()');
+					$funcCall = &quot;\$this-&gt;methodreturn = &quot;.$class.&quot;::&quot;.$method.&quot;(&quot;;
+				} else {
+					$this-&gt;debug('in invoke_method, calling instance method using eval()');
+					// generate unique instance name
+					$instname = &quot;\$inst_&quot;.time();
+					$funcCall = $instname.&quot; = new &quot;.$class.&quot;(); &quot;;
+					$funcCall .= &quot;\$this-&gt;methodreturn = &quot;.$instname.&quot;-&gt;&quot;.$method.&quot;(&quot;;
+				}
+			}
+			if ($this-&gt;methodparams) {
+				foreach ($this-&gt;methodparams as $param) {
+					if (is_array($param)) {
+						$this-&gt;fault('Client', 'NuSOAP does not handle complexType parameters correctly when using eval; call_user_func_array must be available');
+						return;
+					}
+					$funcCall .= &quot;\&quot;$param\&quot;,&quot;;
+				}
+				$funcCall = substr($funcCall, 0, -1);
+			}
+			$funcCall .= ');';
+			$this-&gt;debug('in invoke_method, function call: '.$funcCall);
+			@eval($funcCall);
+		} else {
+			if ($class == '') {
+				$this-&gt;debug('in invoke_method, calling function using call_user_func_array()');
+				$call_arg = &quot;$this-&gt;methodname&quot;;	// straight assignment changes $this-&gt;methodname to lower case after call_user_func_array()
+			} elseif ($delim == '..') {
+				$this-&gt;debug('in invoke_method, calling class method using call_user_func_array()');
+				$call_arg = array ($class, $method);
+			} else {
+				$this-&gt;debug('in invoke_method, calling instance method using call_user_func_array()');
+				$instance = new $class ();
+				$call_arg = array(&amp;$instance, $method);
+			}
+			$this-&gt;methodreturn = call_user_func_array($call_arg, $this-&gt;methodparams);
+		}
+        $this-&gt;debug('in invoke_method, methodreturn:');
+        $this-&gt;appendDebug($this-&gt;varDump($this-&gt;methodreturn));
+		$this-&gt;debug(&quot;in invoke_method, called method $this-&gt;methodname, received $this-&gt;methodreturn of type &quot;.gettype($this-&gt;methodreturn));
+	}
+
+	/**
+	* serializes the return value from a PHP function into a full SOAP Envelope
+	*
+	* The following fields are set by this function (when successful)
+	*
+	* responseSOAP
+	*
+	* This sets the fault field on error
+	*
+	* @access   private
+	*/
+	function serialize_return() {
+		$this-&gt;debug('Entering serialize_return methodname: ' . $this-&gt;methodname . ' methodURI: ' . $this-&gt;methodURI);
+		// if fault
+		if (isset($this-&gt;methodreturn) &amp;&amp; (get_class($this-&gt;methodreturn) == 'soap_fault')) {
+			$this-&gt;debug('got a fault object from method');
+			$this-&gt;fault = $this-&gt;methodreturn;
+			return;
+		} elseif ($this-&gt;methodreturnisliteralxml) {
+			$return_val = $this-&gt;methodreturn;
+		// returned value(s)
+		} else {
+			$this-&gt;debug('got a(n) '.gettype($this-&gt;methodreturn).' from method');
+			$this-&gt;debug('serializing return value');
+			if($this-&gt;wsdl){
+				// weak attempt at supporting multiple output params
+				if(sizeof($this-&gt;opData['output']['parts']) &gt; 1){
+			    	$opParams = $this-&gt;methodreturn;
+			    } else {
+			    	// TODO: is this really necessary?
+			    	$opParams = array($this-&gt;methodreturn);
+			    }
+			    $return_val = $this-&gt;wsdl-&gt;serializeRPCParameters($this-&gt;methodname,'output',$opParams);
+			    $this-&gt;appendDebug($this-&gt;wsdl-&gt;getDebug());
+			    $this-&gt;wsdl-&gt;clearDebug();
+				if($errstr = $this-&gt;wsdl-&gt;getError()){
+					$this-&gt;debug('got wsdl error: '.$errstr);
+					$this-&gt;fault('Server', 'unable to serialize result');
+					return;
+				}
+			} else {
+				if (isset($this-&gt;methodreturn)) {
+					$return_val = $this-&gt;serialize_val($this-&gt;methodreturn, 'return');
+				} else {
+					$return_val = '';
+					$this-&gt;debug('in absence of WSDL, assume void return for backward compatibility');
+				}
+			}
+		}
+		$this-&gt;debug('return value:');
+		$this-&gt;appendDebug($this-&gt;varDump($return_val));
+
+		$this-&gt;debug('serializing response');
+		if ($this-&gt;wsdl) {
+			$this-&gt;debug('have WSDL for serialization: style is ' . $this-&gt;opData['style']);
+			if ($this-&gt;opData['style'] == 'rpc') {
+				$this-&gt;debug('style is rpc for serialization: use is ' . $this-&gt;opData['output']['use']);
+				if ($this-&gt;opData['output']['use'] == 'literal') {
+					$payload = '&lt;'.$this-&gt;methodname.'Response xmlns=&quot;'.$this-&gt;methodURI.'&quot;&gt;'.$return_val.'&lt;/'.$this-&gt;methodname.&quot;Response&gt;&quot;;
+				} else {
+					$payload = '&lt;ns1:'.$this-&gt;methodname.'Response xmlns:ns1=&quot;'.$this-&gt;methodURI.'&quot;&gt;'.$return_val.'&lt;/ns1:'.$this-&gt;methodname.&quot;Response&gt;&quot;;
+				}
+			} else {
+				$this-&gt;debug('style is not rpc for serialization: assume document');
+				$payload = $return_val;
+			}
+		} else {
+			$this-&gt;debug('do not have WSDL for serialization: assume rpc/encoded');
+			$payload = '&lt;ns1:'.$this-&gt;methodname.'Response xmlns:ns1=&quot;'.$this-&gt;methodURI.'&quot;&gt;'.$return_val.'&lt;/ns1:'.$this-&gt;methodname.&quot;Response&gt;&quot;;
+		}
+		$this-&gt;result = 'successful';
+		if($this-&gt;wsdl){
+			//if($this-&gt;debug_flag){
+            	$this-&gt;appendDebug($this-&gt;wsdl-&gt;getDebug());
+            //	}
+			if (isset($opData['output']['encodingStyle'])) {
+				$encodingStyle = $opData['output']['encodingStyle'];
+			} else {
+				$encodingStyle = '';
+			}
+			// Added: In case we use a WSDL, return a serialized env. WITH the usedNamespaces.
+			$this-&gt;responseSOAP = $this-&gt;serializeEnvelope($payload,$this-&gt;responseHeaders,$this-&gt;wsdl-&gt;usedNamespaces,$this-&gt;opData['style'],$encodingStyle);
+		} else {
+			$this-&gt;responseSOAP = $this-&gt;serializeEnvelope($payload,$this-&gt;responseHeaders);
+		}
+		$this-&gt;debug(&quot;Leaving serialize_return&quot;);
+	}
+
+	/**
+	* sends an HTTP response
+	*
+	* The following fields are set by this function (when successful)
+	*
+	* outgoing_headers
+	* response
+	*
+	* @access   private
+	*/
+	function send_response() {
+		$this-&gt;debug('Enter send_response');
+		if ($this-&gt;fault) {
+			$payload = $this-&gt;fault-&gt;serialize();
+			$this-&gt;outgoing_headers[] = &quot;HTTP/1.0 500 Internal Server Error&quot;;
+			$this-&gt;outgoing_headers[] = &quot;Status: 500 Internal Server Error&quot;;
+		} else {
+			$payload = $this-&gt;responseSOAP;
+			// Some combinations of PHP+Web server allow the Status
+			// to come through as a header.  Since OK is the default
+			// just do nothing.
+			// $this-&gt;outgoing_headers[] = &quot;HTTP/1.0 200 OK&quot;;
+			// $this-&gt;outgoing_headers[] = &quot;Status: 200 OK&quot;;
+		}
+        // add debug data if in debug mode
+		if(isset($this-&gt;debug_flag) &amp;&amp; $this-&gt;debug_flag){
+        	$payload .= $this-&gt;getDebugAsXMLComment();
+        }
+		$this-&gt;outgoing_headers[] = &quot;Server: $this-&gt;title Server v$this-&gt;version&quot;;
+		ereg('\$Revisio' . 'n: ([^ ]+)', $this-&gt;revision, $rev);
+		$this-&gt;outgoing_headers[] = &quot;X-SOAP-Server: $this-&gt;title/$this-&gt;version (&quot;.$rev[1].&quot;)&quot;;
+		// Let the Web server decide about this
+		//$this-&gt;outgoing_headers[] = &quot;Connection: Close\r\n&quot;;
+		$payload = $this-&gt;getHTTPBody($payload);
+		$type = $this-&gt;getHTTPContentType();
+		$charset = $this-&gt;getHTTPContentTypeCharset();
+		$this-&gt;outgoing_headers[] = &quot;Content-Type: $type&quot; . ($charset ? '; charset=' . $charset : '');
+		//begin code to compress payload - by John
+		// NOTE: there is no way to know whether the Web server will also compress
+		// this data.
+		if (strlen($payload) &gt; 1024 &amp;&amp; isset($this-&gt;headers) &amp;&amp; isset($this-&gt;headers['accept-encoding'])) {	
+			if (strstr($this-&gt;headers['accept-encoding'], 'gzip')) {
+				if (function_exists('gzencode')) {
+					if (isset($this-&gt;debug_flag) &amp;&amp; $this-&gt;debug_flag) {
+						$payload .= &quot;&lt;!-- Content being gzipped --&gt;&quot;;
+					}
+					$this-&gt;outgoing_headers[] = &quot;Content-Encoding: gzip&quot;;
+					$payload = gzencode($payload);
+				} else {
+					if (isset($this-&gt;debug_flag) &amp;&amp; $this-&gt;debug_flag) {
+						$payload .= &quot;&lt;!-- Content will not be gzipped: no gzencode --&gt;&quot;;
+					}
+				}
+			} elseif (strstr($this-&gt;headers['accept-encoding'], 'deflate')) {
+				// Note: MSIE requires gzdeflate output (no Zlib header and checksum),
+				// instead of gzcompress output,
+				// which conflicts with HTTP 1.1 spec (<A HREF="http://www.w3.org/Protocols/rfc2616/rfc2616-sec3.html#sec3.5">http://www.w3.org/Protocols/rfc2616/rfc2616-sec3.html#sec3.5</A>)
+				if (function_exists('gzdeflate')) {
+					if (isset($this-&gt;debug_flag) &amp;&amp; $this-&gt;debug_flag) {
+						$payload .= &quot;&lt;!-- Content being deflated --&gt;&quot;;
+					}
+					$this-&gt;outgoing_headers[] = &quot;Content-Encoding: deflate&quot;;
+					$payload = gzdeflate($payload);
+				} else {
+					if (isset($this-&gt;debug_flag) &amp;&amp; $this-&gt;debug_flag) {
+						$payload .= &quot;&lt;!-- Content will not be deflated: no gzcompress --&gt;&quot;;
+					}
+				}
+			}
+		}
+		//end code
+		$this-&gt;outgoing_headers[] = &quot;Content-Length: &quot;.strlen($payload);
+		reset($this-&gt;outgoing_headers);
+		foreach($this-&gt;outgoing_headers as $hdr){
+			header($hdr, false);
+		}
+		print $payload;
+		$this-&gt;response = join(&quot;\r\n&quot;,$this-&gt;outgoing_headers).&quot;\r\n\r\n&quot;.$payload;
+	}
+
+	/**
+	* takes the value that was created by parsing the request
+	* and compares to the method's signature, if available.
+	*
+	* @param	string	$operation	The operation to be invoked
+	* @param	array	$request	The array of parameter values
+	* @return	boolean	Whether the operation was found
+	* @access   private
+	*/
+	function verify_method($operation,$request){
+		if(isset($this-&gt;wsdl) &amp;&amp; is_object($this-&gt;wsdl)){
+			if($this-&gt;wsdl-&gt;getOperationData($operation)){
+				return true;
+			}
+	    } elseif(isset($this-&gt;operations[$operation])){
+			return true;
+		}
+		return false;
+	}
+
+	/**
+	* processes SOAP message received from client
+	*
+	* @param	array	$headers	The HTTP headers
+	* @param	string	$data		unprocessed request data from client
+	* @return	mixed	value of the message, decoded into a PHP type
+	* @access   private
+	*/
+    function parseRequest($headers, $data) {
+		$this-&gt;debug('Entering parseRequest() for data of length ' . strlen($data) . ' and type ' . $headers['content-type']);
+		if (!strstr($headers['content-type'], 'text/xml')) {
+			$this-&gt;setError('Request not of type text/xml');
+			return false;
+		}
+		if (strpos($headers['content-type'], '=')) {
+			$enc = str_replace('&quot;', '', substr(strstr($headers[&quot;content-type&quot;], '='), 1));
+			$this-&gt;debug('Got response encoding: ' . $enc);
+			if(eregi('^(ISO-8859-1|US-ASCII|UTF-8)$',$enc)){
+				$this-&gt;xml_encoding = strtoupper($enc);
+			} else {
+				$this-&gt;xml_encoding = 'US-ASCII';
+			}
+		} else {
+			// should be US-ASCII for HTTP 1.0 or ISO-8859-1 for HTTP 1.1
+			$this-&gt;xml_encoding = 'ISO-8859-1';
+		}
+		$this-&gt;debug('Use encoding: ' . $this-&gt;xml_encoding . ' when creating soap_parser');
+		// parse response, get soap parser obj
+		$parser = new soap_parser($data,$this-&gt;xml_encoding,'',$this-&gt;decode_utf8);
+		// parser debug
+		$this-&gt;debug(&quot;parser debug: \n&quot;.$parser-&gt;getDebug());
+		// if fault occurred during message parsing
+		if($err = $parser-&gt;getError()){
+			$this-&gt;result = 'fault: error in msg parsing: '.$err;
+			$this-&gt;fault('Client',&quot;error in msg parsing:\n&quot;.$err);
+		// else successfully parsed request into soapval object
+		} else {
+			// get/set methodname
+			$this-&gt;methodURI = $parser-&gt;root_struct_namespace;
+			$this-&gt;methodname = $parser-&gt;root_struct_name;
+			$this-&gt;debug('methodname: '.$this-&gt;methodname.' methodURI: '.$this-&gt;methodURI);
+			$this-&gt;debug('calling parser-&gt;get_response()');
+			$this-&gt;methodparams = $parser-&gt;get_response();
+			// get SOAP headers
+			$this-&gt;requestHeaders = $parser-&gt;getHeaders();
+            // add document for doclit support
+            $this-&gt;document = $parser-&gt;document;
+		}
+	 }
+
+	/**
+	* gets the HTTP body for the current response.
+	*
+	* @param string $soapmsg The SOAP payload
+	* @return string The HTTP body, which includes the SOAP payload
+	* @access private
+	*/
+	function getHTTPBody($soapmsg) {
+		return $soapmsg;
+	}
+	
+	/**
+	* gets the HTTP content type for the current response.
+	*
+	* Note: getHTTPBody must be called before this.
+	*
+	* @return string the HTTP content type for the current response.
+	* @access private
+	*/
+	function getHTTPContentType() {
+		return 'text/xml';
+	}
+	
+	/**
+	* gets the HTTP content type charset for the current response.
+	* returns false for non-text content types.
+	*
+	* Note: getHTTPBody must be called before this.
+	*
+	* @return string the HTTP content type charset for the current response.
+	* @access private
+	*/
+	function getHTTPContentTypeCharset() {
+		return $this-&gt;soap_defencoding;
+	}
+
+	/**
+	* add a method to the dispatch map (this has been replaced by the register method)
+	*
+	* @param    string $methodname
+	* @param    string $in array of input values
+	* @param    string $out array of output values
+	* @access   public
+	* @deprecated
+	*/
+	function add_to_map($methodname,$in,$out){
+			$this-&gt;operations[$methodname] = array('name' =&gt; $methodname,'in' =&gt; $in,'out' =&gt; $out);
+	}
+
+	/**
+	* register a service function with the server
+	*
+	* @param    string $name the name of the PHP function, class.method or class..method
+	* @param    array $in assoc array of input values: key = param name, value = param type
+	* @param    array $out assoc array of output values: key = param name, value = param type
+	* @param	mixed $namespace the element namespace for the method or false
+	* @param	mixed $soapaction the soapaction for the method or false
+	* @param	mixed $style optional (rpc|document) or false Note: when 'document' is specified, parameter and return wrappers are created for you automatically
+	* @param	mixed $use optional (encoded|literal) or false
+	* @param	string $documentation optional Description to include in WSDL
+	* @param	string $encodingStyle optional (usually '<A HREF="http://schemas.xmlsoap.org/soap/encoding/">http://schemas.xmlsoap.org/soap/encoding/</A>' for encoded)
+	* @access   public
+	*/
+	function register($name,$in=array(),$out=array(),$namespace=false,$soapaction=false,$style=false,$use=false,$documentation='',$encodingStyle=''){
+		global $HTTP_SERVER_VARS;
+
+		if($this-&gt;externalWSDLURL){
+			die('You cannot bind to an external WSDL file, and register methods outside of it! Please choose either WSDL or no WSDL.');
+		}
+		if (! $name) {
+			die('You must specify a name when you register an operation');
+		}
+		if (!is_array($in)) {
+			die('You must provide an array for operation inputs');
+		}
+		if (!is_array($out)) {
+			die('You must provide an array for operation outputs');
+		}
+		if(false == $namespace) {
+		}
+		if(false == $soapaction) {
+			if (isset($_SERVER)) {
+				$SERVER_NAME = $_SERVER['SERVER_NAME'];
+				$SCRIPT_NAME = isset($_SERVER['PHP_SELF']) ? $_SERVER['PHP_SELF'] : $_SERVER['SCRIPT_NAME'];
+			} elseif (isset($HTTP_SERVER_VARS)) {
+				$SERVER_NAME = $HTTP_SERVER_VARS['SERVER_NAME'];
+				$SCRIPT_NAME = isset($HTTP_SERVER_VARS['PHP_SELF']) ? $HTTP_SERVER_VARS['PHP_SELF'] : $HTTP_SERVER_VARS['SCRIPT_NAME'];
+			} else {
+				$this-&gt;setError(&quot;Neither _SERVER nor HTTP_SERVER_VARS is available&quot;);
+			}
+			$soapaction = &quot;<A HREF="http://$SERVER_NAME$SCRIPT_NAME/$name">http://$SERVER_NAME$SCRIPT_NAME/$name</A>&quot;;
+		}
+		if(false == $style) {
+			$style = &quot;rpc&quot;;
+		}
+		if(false == $use) {
+			$use = &quot;encoded&quot;;
+		}
+		if ($use == 'encoded' &amp;&amp; $encodingStyle = '') {
+			$encodingStyle = '<A HREF="http://schemas.xmlsoap.org/soap/encoding/">http://schemas.xmlsoap.org/soap/encoding/</A>';
+		}
+
+		$this-&gt;operations[$name] = array(
+	    'name' =&gt; $name,
+	    'in' =&gt; $in,
+	    'out' =&gt; $out,
+	    'namespace' =&gt; $namespace,
+	    'soapaction' =&gt; $soapaction,
+	    'style' =&gt; $style);
+        if($this-&gt;wsdl){
+        	$this-&gt;wsdl-&gt;addOperation($name,$in,$out,$namespace,$soapaction,$style,$use,$documentation,$encodingStyle);
+	    }
+		return true;
+	}
+
+	/**
+	* Specify a fault to be returned to the client.
+	* This also acts as a flag to the server that a fault has occured.
+	*
+	* @param	string $faultcode
+	* @param	string $faultstring
+	* @param	string $faultactor
+	* @param	string $faultdetail
+	* @access   public
+	*/
+	function fault($faultcode,$faultstring,$faultactor='',$faultdetail=''){
+		if ($faultdetail == '' &amp;&amp; $this-&gt;debug_flag) {
+			$faultdetail = $this-&gt;getDebug();
+		}
+		$this-&gt;fault = new soap_fault($faultcode,$faultactor,$faultstring,$faultdetail);
+		$this-&gt;fault-&gt;soap_defencoding = $this-&gt;soap_defencoding;
+	}
+
+    /**
+    * Sets up wsdl object.
+    * Acts as a flag to enable internal WSDL generation
+    *
+    * @param string $serviceName, name of the service
+    * @param mixed $namespace optional 'tns' service namespace or false
+    * @param mixed $endpoint optional URL of service endpoint or false
+    * @param string $style optional (rpc|document) WSDL style (also specified by operation)
+    * @param string $transport optional SOAP transport
+    * @param mixed $schemaTargetNamespace optional 'types' targetNamespace for service schema or false
+    */
+    function configureWSDL($serviceName,$namespace = false,$endpoint = false,$style='rpc', $transport = '<A HREF="http://schemas.xmlsoap.org/soap/http">http://schemas.xmlsoap.org/soap/http</A>', $schemaTargetNamespace = false)
+    {
+    	global $HTTP_SERVER_VARS;
+
+		if (isset($_SERVER)) {
+			$SERVER_NAME = $_SERVER['SERVER_NAME'];
+			$SERVER_PORT = $_SERVER['SERVER_PORT'];
+			$SCRIPT_NAME = isset($_SERVER['PHP_SELF']) ? $_SERVER['PHP_SELF'] : $_SERVER['SCRIPT_NAME'];
+			$HTTPS = $_SERVER['HTTPS'];
+		} elseif (isset($HTTP_SERVER_VARS)) {
+			$SERVER_NAME = $HTTP_SERVER_VARS['SERVER_NAME'];
+			$SERVER_PORT = $HTTP_SERVER_VARS['SERVER_PORT'];
+			$SCRIPT_NAME = isset($HTTP_SERVER_VARS['PHP_SELF']) ? $HTTP_SERVER_VARS['PHP_SELF'] : $HTTP_SERVER_VARS['SCRIPT_NAME'];
+			$HTTPS = $HTTP_SERVER_VARS['HTTPS'];
+		} else {
+			$this-&gt;setError(&quot;Neither _SERVER nor HTTP_SERVER_VARS is available&quot;);
+		}
+		if ($SERVER_PORT == 80) {
+			$SERVER_PORT = '';
+		} else {
+			$SERVER_PORT = ':' . $SERVER_PORT;
+		}
+        if(false == $namespace) {
+            $namespace = &quot;<A HREF="http://$SERVER_NAME/soap/$serviceName">http://$SERVER_NAME/soap/$serviceName</A>&quot;;
+        }
+        
+        if(false == $endpoint) {
+        	if ($HTTPS == '1' || $HTTPS == 'on') {
+        		$SCHEME = 'https';
+        	} else {
+        		$SCHEME = 'http';
+        	}
+            $endpoint = &quot;$<A HREF="SCHEME://$SERVER_NAME$SERVER_PORT$SCRIPT_NAME">SCHEME://$SERVER_NAME$SERVER_PORT$SCRIPT_NAME</A>&quot;;
+        }
+        
+        if(false == $schemaTargetNamespace) {
+            $schemaTargetNamespace = $namespace;
+        }
+        
+		$this-&gt;wsdl = new wsdl;
+		$this-&gt;wsdl-&gt;serviceName = $serviceName;
+        $this-&gt;wsdl-&gt;endpoint = $endpoint;
+		$this-&gt;wsdl-&gt;namespaces['tns'] = $namespace;
+		$this-&gt;wsdl-&gt;namespaces['soap'] = '<A HREF="http://schemas.xmlsoap.org/wsdl/soap/">http://schemas.xmlsoap.org/wsdl/soap/</A>';
+		$this-&gt;wsdl-&gt;namespaces['wsdl'] = '<A HREF="http://schemas.xmlsoap.org/wsdl/">http://schemas.xmlsoap.org/wsdl/</A>';
+		if ($schemaTargetNamespace != $namespace) {
+			$this-&gt;wsdl-&gt;namespaces['types'] = $schemaTargetNamespace;
+		}
+        $this-&gt;wsdl-&gt;schemas[$schemaTargetNamespace][0] = new xmlschema('', '', $this-&gt;wsdl-&gt;namespaces);
+        $this-&gt;wsdl-&gt;schemas[$schemaTargetNamespace][0]-&gt;schemaTargetNamespace = $schemaTargetNamespace;
+        $this-&gt;wsdl-&gt;schemas[$schemaTargetNamespace][0]-&gt;imports['<A HREF="http://schemas.xmlsoap.org/soap/encoding/">http://schemas.xmlsoap.org/soap/encoding/</A>'][0] = array('location' =&gt; '', 'loaded' =&gt; true);
+        $this-&gt;wsdl-&gt;schemas[$schemaTargetNamespace][0]-&gt;imports['<A HREF="http://schemas.xmlsoap.org/wsdl/">http://schemas.xmlsoap.org/wsdl/</A>'][0] = array('location' =&gt; '', 'loaded' =&gt; true);
+        $this-&gt;wsdl-&gt;bindings[$serviceName.'Binding'] = array(
+        	'name'=&gt;$serviceName.'Binding',
+            'style'=&gt;$style,
+            'transport'=&gt;$transport,
+            'portType'=&gt;$serviceName.'PortType');
+        $this-&gt;wsdl-&gt;ports[$serviceName.'Port'] = array(
+        	'binding'=&gt;$serviceName.'Binding',
+            'location'=&gt;$endpoint,
+            'bindingType'=&gt;'<A HREF="http://schemas.xmlsoap.org/wsdl/soap/">http://schemas.xmlsoap.org/wsdl/soap/</A>');
+    }
+}
+
+
+
+
+?&gt;
\ No newline at end of file

Added: cms/trunk/includes/nusoap/class.soap_transport_http.php
===================================================================
--- cms/trunk/includes/nusoap/class.soap_transport_http.php	2005-09-20 21:46:50 UTC (rev 136)
+++ cms/trunk/includes/nusoap/class.soap_transport_http.php	2005-09-21 03:53:30 UTC (rev 137)
@@ -0,0 +1,1038 @@
+&lt;?php
+
+
+
+
+/**
+* transport class for sending/receiving data via HTTP and HTTPS
+* NOTE: PHP must be compiled with the CURL extension for HTTPS support
+*
+* @author   Dietrich Ayala &lt;<A HREF="https://lists.berlios.de/mailman/listinfo/viperals-svncheckins">dietrich at ganx4.com</A>&gt;
+* @version  $Id: class.soap_transport_http.php,v 1.57 2005/07/27 19:24:42 snichol Exp $
+* @access public
+*/
+class soap_transport_http extends nusoap_base {
+
+	var $url = '';
+	var $uri = '';
+	var $digest_uri = '';
+	var $scheme = '';
+	var $host = '';
+	var $port = '';
+	var $path = '';
+	var $request_method = 'POST';
+	var $protocol_version = '1.0';
+	var $encoding = '';
+	var $outgoing_headers = array();
+	var $incoming_headers = array();
+	var $incoming_cookies = array();
+	var $outgoing_payload = '';
+	var $incoming_payload = '';
+	var $useSOAPAction = true;
+	var $persistentConnection = false;
+	var $ch = false;	// cURL handle
+	var $username = '';
+	var $password = '';
+	var $authtype = '';
+	var $digestRequest = array();
+	var $certRequest = array();	// keys must be cainfofile (optional), sslcertfile, sslkeyfile, passphrase, verifypeer (optional), verifyhost (optional)
+								// cainfofile: certificate authority file, e.g. '$pathToPemFiles/rootca.pem'
+								// sslcertfile: SSL certificate file, e.g. '$pathToPemFiles/mycert.pem'
+								// sslkeyfile: SSL key file, e.g. '$pathToPemFiles/mykey.pem'
+								// passphrase: SSL key password/passphrase
+								// verifypeer: default is 1
+								// verifyhost: default is 1
+
+	/**
+	* constructor
+	*/
+	function soap_transport_http($url){
+		parent::nusoap_base();
+		$this-&gt;setURL($url);
+		ereg('\$Revisio' . 'n: ([^ ]+)', $this-&gt;revision, $rev);
+		$this-&gt;outgoing_headers['User-Agent'] = $this-&gt;title.'/'.$this-&gt;version.' ('.$rev[1].')';
+		$this-&gt;debug('set User-Agent: ' . $this-&gt;outgoing_headers['User-Agent']);
+	}
+
+	function setURL($url) {
+		$this-&gt;url = $url;
+
+		$u = parse_url($url);
+		foreach($u as $k =&gt; $v){
+			$this-&gt;debug(&quot;$k = $v&quot;);
+			$this-&gt;$k = $v;
+		}
+		
+		// add any GET params to path
+		if(isset($u['query']) &amp;&amp; $u['query'] != ''){
+            $this-&gt;path .= '?' . $u['query'];
+		}
+		
+		// set default port
+		if(!isset($u['port'])){
+			if($u['scheme'] == 'https'){
+				$this-&gt;port = 443;
+			} else {
+				$this-&gt;port = 80;
+			}
+		}
+		
+		$this-&gt;uri = $this-&gt;path;
+		$this-&gt;digest_uri = $this-&gt;uri;
+		
+		// build headers
+		if (!isset($u['port'])) {
+			$this-&gt;outgoing_headers['Host'] = $this-&gt;host;
+		} else {
+			$this-&gt;outgoing_headers['Host'] = $this-&gt;host.':'.$this-&gt;port;
+		}
+		$this-&gt;debug('set Host: ' . $this-&gt;outgoing_headers['Host']);
+
+		if (isset($u['user']) &amp;&amp; $u['user'] != '') {
+			$this-&gt;setCredentials(urldecode($u['user']), isset($u['pass']) ? urldecode($u['pass']) : '');
+		}
+	}
+	
+	function connect($connection_timeout=0,$response_timeout=30){
+	  	// For PHP 4.3 with OpenSSL, change https scheme to ssl, then treat like
+	  	// &quot;regular&quot; socket.
+	  	// TODO: disabled for now because OpenSSL must be *compiled* in (not just
+	  	//       loaded), and until PHP5 stream_get_wrappers is not available.
+//	  	if ($this-&gt;scheme == 'https') {
+//		  	if (version_compare(phpversion(), '4.3.0') &gt;= 0) {
+//		  		if (extension_loaded('openssl')) {
+//		  			$this-&gt;scheme = 'ssl';
+//		  			$this-&gt;debug('Using SSL over OpenSSL');
+//		  		}
+//		  	}
+//		}
+		$this-&gt;debug(&quot;connect connection_timeout $connection_timeout, response_timeout $response_timeout, scheme $this-&gt;scheme, host $this-&gt;host, port $this-&gt;port&quot;);
+	  if ($this-&gt;scheme == 'http' || $this-&gt;scheme == 'ssl') {
+		// use persistent connection
+		if($this-&gt;persistentConnection &amp;&amp; isset($this-&gt;fp) &amp;&amp; is_resource($this-&gt;fp)){
+			if (!feof($this-&gt;fp)) {
+				$this-&gt;debug('Re-use persistent connection');
+				return true;
+			}
+			fclose($this-&gt;fp);
+			$this-&gt;debug('Closed persistent connection at EOF');
+		}
+
+		// munge host if using OpenSSL
+		if ($this-&gt;scheme == 'ssl') {
+			$host = '<A HREF="ssl://">ssl://</A>' . $this-&gt;host;
+		} else {
+			$host = $this-&gt;host;
+		}
+		$this-&gt;debug('calling fsockopen with host ' . $host . ' connection_timeout ' . $connection_timeout);
+
+		// open socket
+		if($connection_timeout &gt; 0){
+			$this-&gt;fp = @fsockopen( $host, $this-&gt;port, $this-&gt;errno, $this-&gt;error_str, $connection_timeout);
+		} else {
+			$this-&gt;fp = @fsockopen( $host, $this-&gt;port, $this-&gt;errno, $this-&gt;error_str);
+		}
+		
+		// test pointer
+		if(!$this-&gt;fp) {
+			$msg = 'Couldn\'t open socket connection to server ' . $this-&gt;url;
+			if ($this-&gt;errno) {
+				$msg .= ', Error ('.$this-&gt;errno.'): '.$this-&gt;error_str;
+			} else {
+				$msg .= ' prior to connect().  This is often a problem looking up the host name.';
+			}
+			$this-&gt;debug($msg);
+			$this-&gt;setError($msg);
+			return false;
+		}
+		
+		// set response timeout
+		$this-&gt;debug('set response timeout to ' . $response_timeout);
+		socket_set_timeout( $this-&gt;fp, $response_timeout);
+
+		$this-&gt;debug('socket connected');
+		return true;
+	  } else if ($this-&gt;scheme == 'https') {
+		if (!extension_loaded('curl')) {
+			$this-&gt;setError('CURL Extension, or OpenSSL extension w/ PHP version &gt;= 4.3 is required for HTTPS');
+			return false;
+		}
+		$this-&gt;debug('connect using https');
+		// init CURL
+		$this-&gt;ch = curl_init();
+		// set url
+		$hostURL = ($this-&gt;port != '') ? &quot;<A HREF="https://$this-">https://$this-</A>&gt;host:$this-&gt;port&quot; : &quot;<A HREF="https://$this-">https://$this-</A>&gt;host&quot;;
+		// add path
+		$hostURL .= $this-&gt;path;
+		curl_setopt($this-&gt;ch, CURLOPT_URL, $hostURL);
+		// follow location headers (re-directs)
+		curl_setopt($this-&gt;ch, CURLOPT_FOLLOWLOCATION, 1);
+		// ask for headers in the response output
+		curl_setopt($this-&gt;ch, CURLOPT_HEADER, 1);
+		// ask for the response output as the return value
+		curl_setopt($this-&gt;ch, CURLOPT_RETURNTRANSFER, 1);
+		// encode
+		// We manage this ourselves through headers and encoding
+//		if(function_exists('gzuncompress')){
+//			curl_setopt($this-&gt;ch, CURLOPT_ENCODING, 'deflate');
+//		}
+		// persistent connection
+		if ($this-&gt;persistentConnection) {
+			// The way we send data, we cannot use persistent connections, since
+			// there will be some &quot;junk&quot; at the end of our request.
+			//curl_setopt($this-&gt;ch, CURL_HTTP_VERSION_1_1, true);
+			$this-&gt;persistentConnection = false;
+			$this-&gt;outgoing_headers['Connection'] = 'close';
+			$this-&gt;debug('set Connection: ' . $this-&gt;outgoing_headers['Connection']);
+		}
+		// set timeout
+		if ($connection_timeout != 0) {
+			curl_setopt($this-&gt;ch, CURLOPT_TIMEOUT, $connection_timeout);
+		}
+		// TODO: cURL has added a connection timeout separate from the response timeout
+		//if ($connection_timeout != 0) {
+		//	curl_setopt($this-&gt;ch, CURLOPT_CONNECTIONTIMEOUT, $connection_timeout);
+		//}
+		//if ($response_timeout != 0) {
+		//	curl_setopt($this-&gt;ch, CURLOPT_TIMEOUT, $response_timeout);
+		//}
+
+		// recent versions of cURL turn on peer/host checking by default,
+		// while PHP binaries are not compiled with a default location for the
+		// CA cert bundle, so disable peer/host checking.
+//curl_setopt($this-&gt;ch, CURLOPT_CAINFO, 'f:\php-4.3.2-win32\extensions\curl-ca-bundle.crt');		
+		curl_setopt($this-&gt;ch, CURLOPT_SSL_VERIFYPEER, 0);
+		curl_setopt($this-&gt;ch, CURLOPT_SSL_VERIFYHOST, 0);
+
+		// support client certificates (thanks Tobias Boes, Doug Anarino, Eryan Ariobowo)
+		if ($this-&gt;authtype == 'certificate') {
+			if (isset($this-&gt;certRequest['cainfofile'])) {
+				curl_setopt($this-&gt;ch, CURLOPT_CAINFO, $this-&gt;certRequest['cainfofile']);
+			}
+			if (isset($this-&gt;certRequest['verifypeer'])) {
+				curl_setopt($this-&gt;ch, CURLOPT_SSL_VERIFYPEER, $this-&gt;certRequest['verifypeer']);
+			} else {
+				curl_setopt($this-&gt;ch, CURLOPT_SSL_VERIFYPEER, 1);
+			}
+			if (isset($this-&gt;certRequest['verifyhost'])) {
+				curl_setopt($this-&gt;ch, CURLOPT_SSL_VERIFYHOST, $this-&gt;certRequest['verifyhost']);
+			} else {
+				curl_setopt($this-&gt;ch, CURLOPT_SSL_VERIFYHOST, 1);
+			}
+			if (isset($this-&gt;certRequest['sslcertfile'])) {
+				curl_setopt($this-&gt;ch, CURLOPT_SSLCERT, $this-&gt;certRequest['sslcertfile']);
+			}
+			if (isset($this-&gt;certRequest['sslkeyfile'])) {
+				curl_setopt($this-&gt;ch, CURLOPT_SSLKEY, $this-&gt;certRequest['sslkeyfile']);
+			}
+			if (isset($this-&gt;certRequest['passphrase'])) {
+				curl_setopt($this-&gt;ch, CURLOPT_SSLKEYPASSWD , $this-&gt;certRequest['passphrase']);
+			}
+		}
+		$this-&gt;debug('cURL connection set up');
+		return true;
+	  } else {
+		$this-&gt;setError('Unknown scheme ' . $this-&gt;scheme);
+		$this-&gt;debug('Unknown scheme ' . $this-&gt;scheme);
+		return false;
+	  }
+	}
+	
+	/**
+	* send the SOAP message via HTTP
+	*
+	* @param    string $data message data
+	* @param    integer $timeout set connection timeout in seconds
+	* @param	integer $response_timeout set response timeout in seconds
+	* @param	array $cookies cookies to send
+	* @return	string data
+	* @access   public
+	*/
+	function send($data, $timeout=0, $response_timeout=30, $cookies=NULL) {
+		
+		$this-&gt;debug('entered send() with data of length: '.strlen($data));
+
+		$this-&gt;tryagain = true;
+		$tries = 0;
+		while ($this-&gt;tryagain) {
+			$this-&gt;tryagain = false;
+			if ($tries++ &lt; 2) {
+				// make connnection
+				if (!$this-&gt;connect($timeout, $response_timeout)){
+					return false;
+				}
+				
+				// send request
+				if (!$this-&gt;sendRequest($data, $cookies)){
+					return false;
+				}
+				
+				// get response
+				$respdata = $this-&gt;getResponse();
+			} else {
+				$this-&gt;setError('Too many tries to get an OK response');
+			}
+		}		
+		$this-&gt;debug('end of send()');
+		return $respdata;
+	}
+
+
+	/**
+	* send the SOAP message via HTTPS 1.0 using CURL
+	*
+	* @param    string $msg message data
+	* @param    integer $timeout set connection timeout in seconds
+	* @param	integer $response_timeout set response timeout in seconds
+	* @param	array $cookies cookies to send
+	* @return	string data
+	* @access   public
+	*/
+	function sendHTTPS($data, $timeout=0, $response_timeout=30, $cookies) {
+		return $this-&gt;send($data, $timeout, $response_timeout, $cookies);
+	}
+	
+	/**
+	* if authenticating, set user credentials here
+	*
+	* @param    string $username
+	* @param    string $password
+	* @param	string $authtype (basic, digest, certificate)
+	* @param	array $digestRequest (keys must be nonce, nc, realm, qop)
+	* @param	array $certRequest (keys must be cainfofile (optional), sslcertfile, sslkeyfile, passphrase, verifypeer (optional), verifyhost (optional): see corresponding options in cURL docs)
+	* @access   public
+	*/
+	function setCredentials($username, $password, $authtype = 'basic', $digestRequest = array(), $certRequest = array()) {
+		$this-&gt;debug(&quot;Set credentials for authtype $authtype&quot;);
+		// cf. RFC 2617
+		if ($authtype == 'basic') {
+			$this-&gt;outgoing_headers['Authorization'] = 'Basic '.base64_encode(str_replace(':','',$username).':'.$password);
+		} elseif ($authtype == 'digest') {
+			if (isset($digestRequest['nonce'])) {
+				$digestRequest['nc'] = isset($digestRequest['nc']) ? $digestRequest['nc']++ : 1;
+				
+				// calculate the Digest hashes (calculate code based on digest implementation found at: <A HREF="http://www.rassoc.com/gregr/weblog/stories/2002/07/09/webServicesSecurityHttpDigestAuthenticationWithoutActiveDirectory.html">http://www.rassoc.com/gregr/weblog/stories/2002/07/09/webServicesSecurityHttpDigestAuthenticationWithoutActiveDirectory.html</A>)
+	
+				// A1 = unq(username-value) &quot;:&quot; unq(realm-value) &quot;:&quot; passwd
+				$A1 = $username. ':' . (isset($digestRequest['realm']) ? $digestRequest['realm'] : '') . ':' . $password;
+	
+				// H(A1) = MD5(A1)
+				$HA1 = md5($A1);
+	
+				// A2 = Method &quot;:&quot; digest-uri-value
+				$A2 = 'POST:' . $this-&gt;digest_uri;
+	
+				// H(A2)
+				$HA2 =  md5($A2);
+	
+				// KD(secret, data) = H(concat(secret, &quot;:&quot;, data))
+				// if qop == auth:
+				// request-digest  = &lt;&quot;&gt; &lt; KD ( H(A1),     unq(nonce-value)
+				//                              &quot;:&quot; nc-value
+				//                              &quot;:&quot; unq(cnonce-value)
+				//                              &quot;:&quot; unq(qop-value)
+				//                              &quot;:&quot; H(A2)
+				//                            ) &lt;&quot;&gt;
+				// if qop is missing,
+				// request-digest  = &lt;&quot;&gt; &lt; KD ( H(A1), unq(nonce-value) &quot;:&quot; H(A2) ) &gt; &lt;&quot;&gt;
+	
+				$unhashedDigest = '';
+				$nonce = isset($digestRequest['nonce']) ? $digestRequest['nonce'] : '';
+				$cnonce = $nonce;
+				if ($digestRequest['qop'] != '') {
+					$unhashedDigest = $HA1 . ':' . $nonce . ':' . sprintf(&quot;%08d&quot;, $digestRequest['nc']) . ':' . $cnonce . ':' . $digestRequest['qop'] . ':' . $HA2;
+				} else {
+					$unhashedDigest = $HA1 . ':' . $nonce . ':' . $HA2;
+				}
+	
+				$hashedDigest = md5($unhashedDigest);
+	
+				$this-&gt;outgoing_headers['Authorization'] = 'Digest username=&quot;' . $username . '&quot;, realm=&quot;' . $digestRequest['realm'] . '&quot;, nonce=&quot;' . $nonce . '&quot;, uri=&quot;' . $this-&gt;digest_uri . '&quot;, cnonce=&quot;' . $cnonce . '&quot;, nc=' . sprintf(&quot;%08x&quot;, $digestRequest['nc']) . ', qop=&quot;' . $digestRequest['qop'] . '&quot;, response=&quot;' . $hashedDigest . '&quot;';
+			}
+		} elseif ($authtype == 'certificate') {
+			$this-&gt;certRequest = $certRequest;
+		}
+		$this-&gt;username = $username;
+		$this-&gt;password = $password;
+		$this-&gt;authtype = $authtype;
+		$this-&gt;digestRequest = $digestRequest;
+		
+		if (isset($this-&gt;outgoing_headers['Authorization'])) {
+			$this-&gt;debug('set Authorization: ' . substr($this-&gt;outgoing_headers['Authorization'], 0, 12) . '...');
+		} else {
+			$this-&gt;debug('Authorization header not set');
+		}
+	}
+	
+	/**
+	* set the soapaction value
+	*
+	* @param    string $soapaction
+	* @access   public
+	*/
+	function setSOAPAction($soapaction) {
+		$this-&gt;outgoing_headers['SOAPAction'] = '&quot;' . $soapaction . '&quot;';
+		$this-&gt;debug('set SOAPAction: ' . $this-&gt;outgoing_headers['SOAPAction']);
+	}
+	
+	/**
+	* use http encoding
+	*
+	* @param    string $enc encoding style. supported values: gzip, deflate, or both
+	* @access   public
+	*/
+	function setEncoding($enc='gzip, deflate') {
+		if (function_exists('gzdeflate')) {
+			$this-&gt;protocol_version = '1.1';
+			$this-&gt;outgoing_headers['Accept-Encoding'] = $enc;
+			$this-&gt;debug('set Accept-Encoding: ' . $this-&gt;outgoing_headers['Accept-Encoding']);
+			if (!isset($this-&gt;outgoing_headers['Connection'])) {
+				$this-&gt;outgoing_headers['Connection'] = 'close';
+				$this-&gt;persistentConnection = false;
+				$this-&gt;debug('set Connection: ' . $this-&gt;outgoing_headers['Connection']);
+			}
+			set_magic_quotes_runtime(0);
+			// deprecated
+			$this-&gt;encoding = $enc;
+		}
+	}
+	
+	/**
+	* set proxy info here
+	*
+	* @param    string $proxyhost
+	* @param    string $proxyport
+	* @param	string $proxyusername
+	* @param	string $proxypassword
+	* @access   public
+	*/
+	function setProxy($proxyhost, $proxyport, $proxyusername = '', $proxypassword = '') {
+		$this-&gt;uri = $this-&gt;url;
+		$this-&gt;host = $proxyhost;
+		$this-&gt;port = $proxyport;
+		if ($proxyusername != '' &amp;&amp; $proxypassword != '') {
+			$this-&gt;outgoing_headers['Proxy-Authorization'] = ' Basic '.base64_encode($proxyusername.':'.$proxypassword);
+			$this-&gt;debug('set Proxy-Authorization: ' . $this-&gt;outgoing_headers['Proxy-Authorization']);
+		}
+	}
+	
+	/**
+	* decode a string that is encoded w/ &quot;chunked' transfer encoding
+ 	* as defined in RFC2068 19.4.6
+	*
+	* @param    string $buffer
+	* @param    string $lb
+	* @returns	string
+	* @access   public
+	* @deprecated
+	*/
+	function decodeChunked($buffer, $lb){
+		// length := 0
+		$length = 0;
+		$new = '';
+		
+		// read chunk-size, chunk-extension (if any) and CRLF
+		// get the position of the linebreak
+		$chunkend = strpos($buffer, $lb);
+		if ($chunkend == FALSE) {
+			$this-&gt;debug('no linebreak found in decodeChunked');
+			return $new;
+		}
+		$temp = substr($buffer,0,$chunkend);
+		$chunk_size = hexdec( trim($temp) );
+		$chunkstart = $chunkend + strlen($lb);
+		// while (chunk-size &gt; 0) {
+		while ($chunk_size &gt; 0) {
+			$this-&gt;debug(&quot;chunkstart: $chunkstart chunk_size: $chunk_size&quot;);
+			$chunkend = strpos( $buffer, $lb, $chunkstart + $chunk_size);
+		  	
+			// Just in case we got a broken connection
+		  	if ($chunkend == FALSE) {
+		  	    $chunk = substr($buffer,$chunkstart);
+				// append chunk-data to entity-body
+		    	$new .= $chunk;
+		  	    $length += strlen($chunk);
+		  	    break;
+			}
+			
+		  	// read chunk-data and CRLF
+		  	$chunk = substr($buffer,$chunkstart,$chunkend-$chunkstart);
+		  	// append chunk-data to entity-body
+		  	$new .= $chunk;
+		  	// length := length + chunk-size
+		  	$length += strlen($chunk);
+		  	// read chunk-size and CRLF
+		  	$chunkstart = $chunkend + strlen($lb);
+			
+		  	$chunkend = strpos($buffer, $lb, $chunkstart) + strlen($lb);
+			if ($chunkend == FALSE) {
+				break; //Just in case we got a broken connection
+			}
+			$temp = substr($buffer,$chunkstart,$chunkend-$chunkstart);
+			$chunk_size = hexdec( trim($temp) );
+			$chunkstart = $chunkend;
+		}
+		return $new;
+	}
+	
+	/*
+	 *	Writes payload, including HTTP headers, to $this-&gt;outgoing_payload.
+	 */
+	function buildPayload($data, $cookie_str = '') {
+		// add content-length header
+		$this-&gt;outgoing_headers['Content-Length'] = strlen($data);
+		$this-&gt;debug('set Content-Length: ' . $this-&gt;outgoing_headers['Content-Length']);
+
+		// start building outgoing payload:
+		$req = &quot;$this-&gt;request_method $this-&gt;uri HTTP/$this-&gt;protocol_version&quot;;
+		$this-&gt;debug(&quot;HTTP request: $req&quot;);
+		$this-&gt;outgoing_payload = &quot;$req\r\n&quot;;
+
+		// loop thru headers, serializing
+		foreach($this-&gt;outgoing_headers as $k =&gt; $v){
+			$hdr = $k.': '.$v;
+			$this-&gt;debug(&quot;HTTP header: $hdr&quot;);
+			$this-&gt;outgoing_payload .= &quot;$hdr\r\n&quot;;
+		}
+
+		// add any cookies
+		if ($cookie_str != '') {
+			$hdr = 'Cookie: '.$cookie_str;
+			$this-&gt;debug(&quot;HTTP header: $hdr&quot;);
+			$this-&gt;outgoing_payload .= &quot;$hdr\r\n&quot;;
+		}
+
+		// header/body separator
+		$this-&gt;outgoing_payload .= &quot;\r\n&quot;;
+		
+		// add data
+		$this-&gt;outgoing_payload .= $data;
+	}
+
+	function sendRequest($data, $cookies = NULL) {
+		// build cookie string
+		$cookie_str = $this-&gt;getCookiesForRequest($cookies, (($this-&gt;scheme == 'ssl') || ($this-&gt;scheme == 'https')));
+
+		// build payload
+		$this-&gt;buildPayload($data, $cookie_str);
+
+	  if ($this-&gt;scheme == 'http' || $this-&gt;scheme == 'ssl') {
+		// send payload
+		if(!fputs($this-&gt;fp, $this-&gt;outgoing_payload, strlen($this-&gt;outgoing_payload))) {
+			$this-&gt;setError('couldn\'t write message data to socket');
+			$this-&gt;debug('couldn\'t write message data to socket');
+			return false;
+		}
+		$this-&gt;debug('wrote data to socket, length = ' . strlen($this-&gt;outgoing_payload));
+		return true;
+	  } else if ($this-&gt;scheme == 'https') {
+		// set payload
+		// TODO: cURL does say this should only be the verb, and in fact it
+		// turns out that the URI and HTTP version are appended to this, which
+		// some servers refuse to work with
+		//curl_setopt($this-&gt;ch, CURLOPT_CUSTOMREQUEST, $this-&gt;outgoing_payload);
+		foreach($this-&gt;outgoing_headers as $k =&gt; $v){
+			$curl_headers[] = &quot;$k: $v&quot;;
+		}
+		if ($cookie_str != '') {
+			$curl_headers[] = 'Cookie: ' . $cookie_str;
+		}
+		curl_setopt($this-&gt;ch, CURLOPT_HTTPHEADER, $curl_headers);
+		if ($this-&gt;request_method == &quot;POST&quot;) {
+	  		curl_setopt($this-&gt;ch, CURLOPT_POST, 1);
+	  		curl_setopt($this-&gt;ch, CURLOPT_POSTFIELDS, $data);
+	  	} else {
+	  	}
+		$this-&gt;debug('set cURL payload');
+		return true;
+	  }
+	}
+
+	function getResponse(){
+		$this-&gt;incoming_payload = '';
+	    
+	  if ($this-&gt;scheme == 'http' || $this-&gt;scheme == 'ssl') {
+	    // loop until headers have been retrieved
+	    $data = '';
+	    while (!isset($lb)){
+
+			// We might EOF during header read.
+			if(feof($this-&gt;fp)) {
+				$this-&gt;incoming_payload = $data;
+				$this-&gt;debug('found no headers before EOF after length ' . strlen($data));
+				$this-&gt;debug(&quot;received before EOF:\n&quot; . $data);
+				$this-&gt;setError('server failed to send headers');
+				return false;
+			}
+
+			$tmp = fgets($this-&gt;fp, 256);
+			$tmplen = strlen($tmp);
+			$this-&gt;debug(&quot;read line of $tmplen bytes: &quot; . trim($tmp));
+
+			if ($tmplen == 0) {
+				$this-&gt;incoming_payload = $data;
+				$this-&gt;debug('socket read of headers timed out after length ' . strlen($data));
+				$this-&gt;debug(&quot;read before timeout: &quot; . $data);
+				$this-&gt;setError('socket read of headers timed out');
+				return false;
+			}
+
+			$data .= $tmp;
+			$pos = strpos($data,&quot;\r\n\r\n&quot;);
+			if($pos &gt; 1){
+				$lb = &quot;\r\n&quot;;
+			} else {
+				$pos = strpos($data,&quot;\n\n&quot;);
+				if($pos &gt; 1){
+					$lb = &quot;\n&quot;;
+				}
+			}
+			// remove 100 header
+			if(isset($lb) &amp;&amp; ereg('^HTTP/1.1 100',$data)){
+				unset($lb);
+				$data = '';
+			}//
+		}
+		// store header data
+		$this-&gt;incoming_payload .= $data;
+		$this-&gt;debug('found end of headers after length ' . strlen($data));
+		// process headers
+		$header_data = trim(substr($data,0,$pos));
+		$header_array = explode($lb,$header_data);
+		$this-&gt;incoming_headers = array();
+		$this-&gt;incoming_cookies = array();
+		foreach($header_array as $header_line){
+			$arr = explode(':',$header_line, 2);
+			if(count($arr) &gt; 1){
+				$header_name = strtolower(trim($arr[0]));
+				$this-&gt;incoming_headers[$header_name] = trim($arr[1]);
+				if ($header_name == 'set-cookie') {
+					// TODO: allow multiple cookies from parseCookie
+					$cookie = $this-&gt;parseCookie(trim($arr[1]));
+					if ($cookie) {
+						$this-&gt;incoming_cookies[] = $cookie;
+						$this-&gt;debug('found cookie: ' . $cookie['name'] . ' = ' . $cookie['value']);
+					} else {
+						$this-&gt;debug('did not find cookie in ' . trim($arr[1]));
+					}
+    			}
+			} else if (isset($header_name)) {
+				// append continuation line to previous header
+				$this-&gt;incoming_headers[$header_name] .= $lb . ' ' . $header_line;
+			}
+		}
+		
+		// loop until msg has been received
+		if (isset($this-&gt;incoming_headers['transfer-encoding']) &amp;&amp; strtolower($this-&gt;incoming_headers['transfer-encoding']) == 'chunked') {
+			$content_length =  2147483647;	// ignore any content-length header
+			$chunked = true;
+			$this-&gt;debug(&quot;want to read chunked content&quot;);
+		} elseif (isset($this-&gt;incoming_headers['content-length'])) {
+			$content_length = $this-&gt;incoming_headers['content-length'];
+			$chunked = false;
+			$this-&gt;debug(&quot;want to read content of length $content_length&quot;);
+		} else {
+			$content_length =  2147483647;
+			$chunked = false;
+			$this-&gt;debug(&quot;want to read content to EOF&quot;);
+		}
+		$data = '';
+		do {
+			if ($chunked) {
+				$tmp = fgets($this-&gt;fp, 256);
+				$tmplen = strlen($tmp);
+				$this-&gt;debug(&quot;read chunk line of $tmplen bytes&quot;);
+				if ($tmplen == 0) {
+					$this-&gt;incoming_payload = $data;
+					$this-&gt;debug('socket read of chunk length timed out after length ' . strlen($data));
+					$this-&gt;debug(&quot;read before timeout:\n&quot; . $data);
+					$this-&gt;setError('socket read of chunk length timed out');
+					return false;
+				}
+				$content_length = hexdec(trim($tmp));
+				$this-&gt;debug(&quot;chunk length $content_length&quot;);
+			}
+			$strlen = 0;
+		    while (($strlen &lt; $content_length) &amp;&amp; (!feof($this-&gt;fp))) {
+		    	$readlen = min(8192, $content_length - $strlen);
+				$tmp = fread($this-&gt;fp, $readlen);
+				$tmplen = strlen($tmp);
+				$this-&gt;debug(&quot;read buffer of $tmplen bytes&quot;);
+				if (($tmplen == 0) &amp;&amp; (!feof($this-&gt;fp))) {
+					$this-&gt;incoming_payload = $data;
+					$this-&gt;debug('socket read of body timed out after length ' . strlen($data));
+					$this-&gt;debug(&quot;read before timeout:\n&quot; . $data);
+					$this-&gt;setError('socket read of body timed out');
+					return false;
+				}
+				$strlen += $tmplen;
+				$data .= $tmp;
+			}
+			if ($chunked &amp;&amp; ($content_length &gt; 0)) {
+				$tmp = fgets($this-&gt;fp, 256);
+				$tmplen = strlen($tmp);
+				$this-&gt;debug(&quot;read chunk terminator of $tmplen bytes&quot;);
+				if ($tmplen == 0) {
+					$this-&gt;incoming_payload = $data;
+					$this-&gt;debug('socket read of chunk terminator timed out after length ' . strlen($data));
+					$this-&gt;debug(&quot;read before timeout:\n&quot; . $data);
+					$this-&gt;setError('socket read of chunk terminator timed out');
+					return false;
+				}
+			}
+		} while ($chunked &amp;&amp; ($content_length &gt; 0) &amp;&amp; (!feof($this-&gt;fp)));
+		if (feof($this-&gt;fp)) {
+			$this-&gt;debug('read to EOF');
+		}
+		$this-&gt;debug('read body of length ' . strlen($data));
+		$this-&gt;incoming_payload .= $data;
+		$this-&gt;debug('received a total of '.strlen($this-&gt;incoming_payload).' bytes of data from server');
+		
+		// close filepointer
+		if(
+			(isset($this-&gt;incoming_headers['connection']) &amp;&amp; strtolower($this-&gt;incoming_headers['connection']) == 'close') || 
+			(! $this-&gt;persistentConnection) || feof($this-&gt;fp)){
+			fclose($this-&gt;fp);
+			$this-&gt;fp = false;
+			$this-&gt;debug('closed socket');
+		}
+		
+		// connection was closed unexpectedly
+		if($this-&gt;incoming_payload == ''){
+			$this-&gt;setError('no response from server');
+			return false;
+		}
+		
+		// decode transfer-encoding
+//		if(isset($this-&gt;incoming_headers['transfer-encoding']) &amp;&amp; strtolower($this-&gt;incoming_headers['transfer-encoding']) == 'chunked'){
+//			if(!$data = $this-&gt;decodeChunked($data, $lb)){
+//				$this-&gt;setError('Decoding of chunked data failed');
+//				return false;
+//			}
+			//print &quot;&lt;pre&gt;\nde-chunked:\n---------------\n$data\n\n---------------\n&lt;/pre&gt;&quot;;
+			// set decoded payload
+//			$this-&gt;incoming_payload = $header_data.$lb.$lb.$data;
+//		}
+	
+	  } else if ($this-&gt;scheme == 'https') {
+		// send and receive
+		$this-&gt;debug('send and receive with cURL');
+		$this-&gt;incoming_payload = curl_exec($this-&gt;ch);
+		$data = $this-&gt;incoming_payload;
+
+        $cErr = curl_error($this-&gt;ch);
+		if ($cErr != '') {
+        	$err = 'cURL ERROR: '.curl_errno($this-&gt;ch).': '.$cErr.'&lt;br&gt;';
+        	// TODO: there is a PHP bug that can cause this to SEGV for CURLINFO_CONTENT_TYPE
+			foreach(curl_getinfo($this-&gt;ch) as $k =&gt; $v){
+				$err .= &quot;$k: $v&lt;br&gt;&quot;;
+			}
+			$this-&gt;debug($err);
+			$this-&gt;setError($err);
+			curl_close($this-&gt;ch);
+	    	return false;
+		} else {
+			//echo '&lt;pre&gt;';
+			//var_dump(curl_getinfo($this-&gt;ch));
+			//echo '&lt;/pre&gt;';
+		}
+		// close curl
+		$this-&gt;debug('No cURL error, closing cURL');
+		curl_close($this-&gt;ch);
+		
+		// remove 100 header(s)
+		while (ereg('^HTTP/1.1 100',$data)) {
+			if ($pos = strpos($data,&quot;\r\n\r\n&quot;)) {
+				$data = ltrim(substr($data,$pos));
+			} elseif($pos = strpos($data,&quot;\n\n&quot;) ) {
+				$data = ltrim(substr($data,$pos));
+			}
+		}
+		
+		// separate content from HTTP headers
+		if ($pos = strpos($data,&quot;\r\n\r\n&quot;)) {
+			$lb = &quot;\r\n&quot;;
+		} elseif( $pos = strpos($data,&quot;\n\n&quot;)) {
+			$lb = &quot;\n&quot;;
+		} else {
+			$this-&gt;debug('no proper separation of headers and document');
+			$this-&gt;setError('no proper separation of headers and document');
+			return false;
+		}
+		$header_data = trim(substr($data,0,$pos));
+		$header_array = explode($lb,$header_data);
+		$data = ltrim(substr($data,$pos));
+		$this-&gt;debug('found proper separation of headers and document');
+		$this-&gt;debug('cleaned data, stringlen: '.strlen($data));
+		// clean headers
+		foreach ($header_array as $header_line) {
+			$arr = explode(':',$header_line,2);
+			if(count($arr) &gt; 1){
+				$header_name = strtolower(trim($arr[0]));
+				$this-&gt;incoming_headers[$header_name] = trim($arr[1]);
+				if ($header_name == 'set-cookie') {
+					// TODO: allow multiple cookies from parseCookie
+					$cookie = $this-&gt;parseCookie(trim($arr[1]));
+					if ($cookie) {
+						$this-&gt;incoming_cookies[] = $cookie;
+						$this-&gt;debug('found cookie: ' . $cookie['name'] . ' = ' . $cookie['value']);
+					} else {
+						$this-&gt;debug('did not find cookie in ' . trim($arr[1]));
+					}
+    			}
+			} else if (isset($header_name)) {
+				// append continuation line to previous header
+				$this-&gt;incoming_headers[$header_name] .= $lb . ' ' . $header_line;
+			}
+		}
+	  }
+
+		$arr = explode(' ', $header_array[0], 3);
+		$http_version = $arr[0];
+		$http_status = intval($arr[1]);
+		$http_reason = count($arr) &gt; 2 ? $arr[2] : '';
+
+ 		// see if we need to resend the request with http digest authentication
+ 		if (isset($this-&gt;incoming_headers['location']) &amp;&amp; $http_status == 301) {
+ 			$this-&gt;debug(&quot;Got 301 $http_reason with Location: &quot; . $this-&gt;incoming_headers['location']);
+ 			$this-&gt;setURL($this-&gt;incoming_headers['location']);
+			$this-&gt;tryagain = true;
+			return false;
+		}
+
+ 		// see if we need to resend the request with http digest authentication
+ 		if (isset($this-&gt;incoming_headers['www-authenticate']) &amp;&amp; $http_status == 401) {
+ 			$this-&gt;debug(&quot;Got 401 $http_reason with WWW-Authenticate: &quot; . $this-&gt;incoming_headers['www-authenticate']);
+ 			if (strstr($this-&gt;incoming_headers['www-authenticate'], &quot;Digest &quot;)) {
+ 				$this-&gt;debug('Server wants digest authentication');
+ 				// remove &quot;Digest &quot; from our elements
+ 				$digestString = str_replace('Digest ', '', $this-&gt;incoming_headers['www-authenticate']);
+ 				
+ 				// parse elements into array
+ 				$digestElements = explode(',', $digestString);
+ 				foreach ($digestElements as $val) {
+ 					$tempElement = explode('=', trim($val), 2);
+ 					$digestRequest[$tempElement[0]] = str_replace(&quot;\&quot;&quot;, '', $tempElement[1]);
+ 				}
+
+				// should have (at least) qop, realm, nonce
+ 				if (isset($digestRequest['nonce'])) {
+ 					$this-&gt;setCredentials($this-&gt;username, $this-&gt;password, 'digest', $digestRequest);
+ 					$this-&gt;tryagain = true;
+ 					return false;
+ 				}
+ 			}
+			$this-&gt;debug('HTTP authentication failed');
+			$this-&gt;setError('HTTP authentication failed');
+			return false;
+ 		}
+		
+		if (
+			($http_status &gt;= 300 &amp;&amp; $http_status &lt;= 307) ||
+			($http_status &gt;= 400 &amp;&amp; $http_status &lt;= 417) ||
+			($http_status &gt;= 501 &amp;&amp; $http_status &lt;= 505)
+		   ) {
+			$this-&gt;setError(&quot;Unsupported HTTP response status $http_status $http_reason (soapclient-&gt;response has contents of the response)&quot;);
+			return false;
+		}
+
+		// decode content-encoding
+		if(isset($this-&gt;incoming_headers['content-encoding']) &amp;&amp; $this-&gt;incoming_headers['content-encoding'] != ''){
+			if(strtolower($this-&gt;incoming_headers['content-encoding']) == 'deflate' || strtolower($this-&gt;incoming_headers['content-encoding']) == 'gzip'){
+    			// if decoding works, use it. else assume data wasn't gzencoded
+    			if(function_exists('gzinflate')){
+					//$timer-&gt;setMarker('starting decoding of gzip/deflated content');
+					// IIS 5 requires gzinflate instead of gzuncompress (similar to IE 5 and gzdeflate v. gzcompress)
+					// this means there are no Zlib headers, although there should be
+					$this-&gt;debug('The gzinflate function exists');
+					$datalen = strlen($data);
+					if ($this-&gt;incoming_headers['content-encoding'] == 'deflate') {
+						if ($degzdata = @gzinflate($data)) {
+	    					$data = $degzdata;
+	    					$this-&gt;debug('The payload has been inflated to ' . strlen($data) . ' bytes');
+	    					if (strlen($data) &lt; $datalen) {
+	    						// test for the case that the payload has been compressed twice
+		    					$this-&gt;debug('The inflated payload is smaller than the gzipped one; try again');
+								if ($degzdata = @gzinflate($data)) {
+			    					$data = $degzdata;
+			    					$this-&gt;debug('The payload has been inflated again to ' . strlen($data) . ' bytes');
+								}
+	    					}
+	    				} else {
+	    					$this-&gt;debug('Error using gzinflate to inflate the payload');
+	    					$this-&gt;setError('Error using gzinflate to inflate the payload');
+	    				}
+					} elseif ($this-&gt;incoming_headers['content-encoding'] == 'gzip') {
+						if ($degzdata = @gzinflate(substr($data, 10))) {	// do our best
+							$data = $degzdata;
+	    					$this-&gt;debug('The payload has been un-gzipped to ' . strlen($data) . ' bytes');
+	    					if (strlen($data) &lt; $datalen) {
+	    						// test for the case that the payload has been compressed twice
+		    					$this-&gt;debug('The un-gzipped payload is smaller than the gzipped one; try again');
+								if ($degzdata = @gzinflate(substr($data, 10))) {
+			    					$data = $degzdata;
+			    					$this-&gt;debug('The payload has been un-gzipped again to ' . strlen($data) . ' bytes');
+								}
+	    					}
+	    				} else {
+	    					$this-&gt;debug('Error using gzinflate to un-gzip the payload');
+							$this-&gt;setError('Error using gzinflate to un-gzip the payload');
+	    				}
+					}
+					//$timer-&gt;setMarker('finished decoding of gzip/deflated content');
+					//print &quot;&lt;xmp&gt;\nde-inflated:\n---------------\n$data\n-------------\n&lt;/xmp&gt;&quot;;
+					// set decoded payload
+					$this-&gt;incoming_payload = $header_data.$lb.$lb.$data;
+    			} else {
+					$this-&gt;debug('The server sent compressed data. Your php install must have the Zlib extension compiled in to support this.');
+					$this-&gt;setError('The server sent compressed data. Your php install must have the Zlib extension compiled in to support this.');
+				}
+			} else {
+				$this-&gt;debug('Unsupported Content-Encoding ' . $this-&gt;incoming_headers['content-encoding']);
+				$this-&gt;setError('Unsupported Content-Encoding ' . $this-&gt;incoming_headers['content-encoding']);
+			}
+		} else {
+			$this-&gt;debug('No Content-Encoding header');
+		}
+		
+		if(strlen($data) == 0){
+			$this-&gt;debug('no data after headers!');
+			$this-&gt;setError('no data present after HTTP headers');
+			return false;
+		}
+		
+		return $data;
+	}
+
+	function setContentType($type, $charset = false) {
+		$this-&gt;outgoing_headers['Content-Type'] = $type . ($charset ? '; charset=' . $charset : '');
+		$this-&gt;debug('set Content-Type: ' . $this-&gt;outgoing_headers['Content-Type']);
+	}
+
+	function usePersistentConnection(){
+		if (isset($this-&gt;outgoing_headers['Accept-Encoding'])) {
+			return false;
+		}
+		$this-&gt;protocol_version = '1.1';
+		$this-&gt;persistentConnection = true;
+		$this-&gt;outgoing_headers['Connection'] = 'Keep-Alive';
+		$this-&gt;debug('set Connection: ' . $this-&gt;outgoing_headers['Connection']);
+		return true;
+	}
+
+	/**
+	 * parse an incoming Cookie into it's parts
+	 *
+	 * @param	string $cookie_str content of cookie
+	 * @return	array with data of that cookie
+	 * @access	private
+	 */
+	/*
+	 * TODO: allow a Set-Cookie string to be parsed into multiple cookies
+	 */
+	function parseCookie($cookie_str) {
+		$cookie_str = str_replace('; ', ';', $cookie_str) . ';';
+		$data = split(';', $cookie_str);
+		$value_str = $data[0];
+
+		$cookie_param = 'domain=';
+		$start = strpos($cookie_str, $cookie_param);
+		if ($start &gt; 0) {
+			$domain = substr($cookie_str, $start + strlen($cookie_param));
+			$domain = substr($domain, 0, strpos($domain, ';'));
+		} else {
+			$domain = '';
+		}
+
+		$cookie_param = 'expires=';
+		$start = strpos($cookie_str, $cookie_param);
+		if ($start &gt; 0) {
+			$expires = substr($cookie_str, $start + strlen($cookie_param));
+			$expires = substr($expires, 0, strpos($expires, ';'));
+		} else {
+			$expires = '';
+		}
+
+		$cookie_param = 'path=';
+		$start = strpos($cookie_str, $cookie_param);
+		if ( $start &gt; 0 ) {
+			$path = substr($cookie_str, $start + strlen($cookie_param));
+			$path = substr($path, 0, strpos($path, ';'));
+		} else {
+			$path = '/';
+		}
+						
+		$cookie_param = ';secure;';
+		if (strpos($cookie_str, $cookie_param) !== FALSE) {
+			$secure = true;
+		} else {
+			$secure = false;
+		}
+
+		$sep_pos = strpos($value_str, '=');
+
+		if ($sep_pos) {
+			$name = substr($value_str, 0, $sep_pos);
+			$value = substr($value_str, $sep_pos + 1);
+			$cookie= array(	'name' =&gt; $name,
+			                'value' =&gt; $value,
+							'domain' =&gt; $domain,
+							'path' =&gt; $path,
+							'expires' =&gt; $expires,
+							'secure' =&gt; $secure
+							);		
+			return $cookie;
+		}
+		return false;
+	}
+  
+	/**
+	 * sort out cookies for the current request
+	 *
+	 * @param	array $cookies array with all cookies
+	 * @param	boolean $secure is the send-content secure or not?
+	 * @return	string for Cookie-HTTP-Header
+	 * @access	private
+	 */
+	function getCookiesForRequest($cookies, $secure=false) {
+		$cookie_str = '';
+		if ((! is_null($cookies)) &amp;&amp; (is_array($cookies))) {
+			foreach ($cookies as $cookie) {
+				if (! is_array($cookie)) {
+					continue;
+				}
+	    		$this-&gt;debug(&quot;check cookie for validity: &quot;.$cookie['name'].'='.$cookie['value']);
+				if ((isset($cookie['expires'])) &amp;&amp; (! empty($cookie['expires']))) {
+					if (strtotime($cookie['expires']) &lt;= time()) {
+						$this-&gt;debug('cookie has expired');
+						continue;
+					}
+				}
+				if ((isset($cookie['domain'])) &amp;&amp; (! empty($cookie['domain']))) {
+					$domain = preg_quote($cookie['domain']);
+					if (! preg_match(&quot;'.*$domain$'i&quot;, $this-&gt;host)) {
+						$this-&gt;debug('cookie has different domain');
+						continue;
+					}
+				}
+				if ((isset($cookie['path'])) &amp;&amp; (! empty($cookie['path']))) {
+					$path = preg_quote($cookie['path']);
+					if (! preg_match(&quot;'^$path.*'i&quot;, $this-&gt;path)) {
+						$this-&gt;debug('cookie is for a different path');
+						continue;
+					}
+				}
+				if ((! $secure) &amp;&amp; (isset($cookie['secure'])) &amp;&amp; ($cookie['secure'])) {
+					$this-&gt;debug('cookie is secure, transport is not');
+					continue;
+				}
+				$cookie_str .= $cookie['name'] . '=' . $cookie['value'] . '; ';
+	    		$this-&gt;debug('add cookie to Cookie-String: ' . $cookie['name'] . '=' . $cookie['value']);
+			}
+		}
+		return $cookie_str;
+  }
+}
+
+
+?&gt;
\ No newline at end of file

Added: cms/trunk/includes/nusoap/class.soap_val.php
===================================================================
--- cms/trunk/includes/nusoap/class.soap_val.php	2005-09-20 21:46:50 UTC (rev 136)
+++ cms/trunk/includes/nusoap/class.soap_val.php	2005-09-21 03:53:30 UTC (rev 137)
@@ -0,0 +1,107 @@
+&lt;?php
+
+
+
+
+/**
+* For creating serializable abstractions of native PHP types.  This class
+* allows element name/namespace, XSD type, and XML attributes to be
+* associated with a value.  This is extremely useful when WSDL is not
+* used, but is also useful when WSDL is used with polymorphic types, including
+* xsd:anyType and user-defined types.
+*
+* @author   Dietrich Ayala &lt;<A HREF="https://lists.berlios.de/mailman/listinfo/viperals-svncheckins">dietrich at ganx4.com</A>&gt;
+* @version  $Id: class.soap_val.php,v 1.9 2005/07/27 19:24:42 snichol Exp $
+* @access   public
+*/
+class soapval extends nusoap_base {
+	/**
+	 * The XML element name
+	 *
+	 * @var string
+	 * @access private
+	 */
+	var $name;
+	/**
+	 * The XML type name (string or false)
+	 *
+	 * @var mixed
+	 * @access private
+	 */
+	var $type;
+	/**
+	 * The PHP value
+	 *
+	 * @var mixed
+	 * @access private
+	 */
+	var $value;
+	/**
+	 * The XML element namespace (string or false)
+	 *
+	 * @var mixed
+	 * @access private
+	 */
+	var $element_ns;
+	/**
+	 * The XML type namespace (string or false)
+	 *
+	 * @var mixed
+	 * @access private
+	 */
+	var $type_ns;
+	/**
+	 * The XML element attributes (array or false)
+	 *
+	 * @var mixed
+	 * @access private
+	 */
+	var $attributes;
+
+	/**
+	* constructor
+	*
+	* @param    string $name optional name
+	* @param    mixed $type optional type name
+	* @param	mixed $value optional value
+	* @param	mixed $element_ns optional namespace of value
+	* @param	mixed $type_ns optional namespace of type
+	* @param	mixed $attributes associative array of attributes to add to element serialization
+	* @access   public
+	*/
+  	function soapval($name='soapval',$type=false,$value=-1,$element_ns=false,$type_ns=false,$attributes=false) {
+		parent::nusoap_base();
+		$this-&gt;name = $name;
+		$this-&gt;type = $type;
+		$this-&gt;value = $value;
+		$this-&gt;element_ns = $element_ns;
+		$this-&gt;type_ns = $type_ns;
+		$this-&gt;attributes = $attributes;
+    }
+
+	/**
+	* return serialized value
+	*
+	* @param	string $use The WSDL use value (encoded|literal)
+	* @return	string XML data
+	* @access   public
+	*/
+	function serialize($use='encoded') {
+		return $this-&gt;serialize_val($this-&gt;value,$this-&gt;name,$this-&gt;type,$this-&gt;element_ns,$this-&gt;type_ns,$this-&gt;attributes,$use);
+    }
+
+	/**
+	* decodes a soapval object into a PHP native type
+	*
+	* @return	mixed
+	* @access   public
+	*/
+	function decode(){
+		return $this-&gt;value;
+	}
+}
+
+
+
+
+?&gt;
\ No newline at end of file

Added: cms/trunk/includes/nusoap/class.soapclient.php
===================================================================
--- cms/trunk/includes/nusoap/class.soapclient.php	2005-09-20 21:46:50 UTC (rev 136)
+++ cms/trunk/includes/nusoap/class.soapclient.php	2005-09-21 03:53:30 UTC (rev 137)
@@ -0,0 +1,859 @@
+&lt;?php
+
+
+
+
+/**
+*
+* soapclient higher level class for easy usage.
+*
+* usage:
+*
+* // instantiate client with server info
+* $soapclient = new soapclient( string path [ ,boolean wsdl] );
+*
+* // call method, get results
+* echo $soapclient-&gt;call( string methodname [ ,array parameters] );
+*
+* // bye bye client
+* unset($soapclient);
+*
+* @author   Dietrich Ayala &lt;<A HREF="https://lists.berlios.de/mailman/listinfo/viperals-svncheckins">dietrich at ganx4.com</A>&gt;
+* @version  $Id: class.soapclient.php,v 1.52 2005/07/27 19:24:42 snichol Exp $
+* @access   public
+*/
+class soapclient extends nusoap_base  {
+
+	var $username = '';
+	var $password = '';
+	var $authtype = '';
+	var $certRequest = array();
+	var $requestHeaders = false;	// SOAP headers in request (text)
+	var $responseHeaders = '';		// SOAP headers from response (incomplete namespace resolution) (text)
+	var $document = '';				// SOAP body response portion (incomplete namespace resolution) (text)
+	var $endpoint;
+	var $forceEndpoint = '';		// overrides WSDL endpoint
+    var $proxyhost = '';
+    var $proxyport = '';
+	var $proxyusername = '';
+	var $proxypassword = '';
+    var $xml_encoding = '';			// character set encoding of incoming (response) messages
+	var $http_encoding = false;
+	var $timeout = 0;				// HTTP connection timeout
+	var $response_timeout = 30;		// HTTP response timeout
+	var $endpointType = '';			// soap|wsdl, empty for WSDL initialization error
+	var $persistentConnection = false;
+	var $defaultRpcParams = false;	// This is no longer used
+	var $request = '';				// HTTP request
+	var $response = '';				// HTTP response
+	var $responseData = '';			// SOAP payload of response
+	var $cookies = array();			// Cookies from response or for request
+    var $decode_utf8 = true;		// toggles whether the parser decodes element content w/ utf8_decode()
+	var $operations = array();		// WSDL operations, empty for WSDL initialization error
+	
+	/*
+	 * fault related variables
+	 */
+	/**
+	 * @var      fault
+	 * @access   public
+	 */
+	var $fault;
+	/**
+	 * @var      faultcode
+	 * @access   public
+	 */
+	var $faultcode;
+	/**
+	 * @var      faultstring
+	 * @access   public
+	 */
+	var $faultstring;
+	/**
+	 * @var      faultdetail
+	 * @access   public
+	 */
+	var $faultdetail;
+
+	/**
+	* constructor
+	*
+	* @param    mixed $endpoint SOAP server or WSDL URL (string), or wsdl instance (object)
+	* @param    bool $wsdl optional, set to true if using WSDL
+	* @param	int $portName optional portName in WSDL document
+	* @param    string $proxyhost
+	* @param    string $proxyport
+	* @param	string $proxyusername
+	* @param	string $proxypassword
+	* @param	integer $timeout set the connection timeout
+	* @param	integer $response_timeout set the response timeout
+	* @access   public
+	*/
+	function soapclient($endpoint,$wsdl = false,$proxyhost = false,$proxyport = false,$proxyusername = false, $proxypassword = false, $timeout = 0, $response_timeout = 30){
+		parent::nusoap_base();
+		$this-&gt;endpoint = $endpoint;
+		$this-&gt;proxyhost = $proxyhost;
+		$this-&gt;proxyport = $proxyport;
+		$this-&gt;proxyusername = $proxyusername;
+		$this-&gt;proxypassword = $proxypassword;
+		$this-&gt;timeout = $timeout;
+		$this-&gt;response_timeout = $response_timeout;
+
+		// make values
+		if($wsdl){
+			if (is_object($endpoint) &amp;&amp; (get_class($endpoint) == 'wsdl')) {
+				$this-&gt;wsdl = $endpoint;
+				$this-&gt;endpoint = $this-&gt;wsdl-&gt;wsdl;
+				$this-&gt;wsdlFile = $this-&gt;endpoint;
+				$this-&gt;debug('existing wsdl instance created from ' . $this-&gt;endpoint);
+			} else {
+				$this-&gt;wsdlFile = $this-&gt;endpoint;
+				
+				// instantiate wsdl object and parse wsdl file
+				$this-&gt;debug('instantiating wsdl class with doc: '.$endpoint);
+				$this-&gt;wsdl =&amp; new wsdl($this-&gt;wsdlFile,$this-&gt;proxyhost,$this-&gt;proxyport,$this-&gt;proxyusername,$this-&gt;proxypassword,$this-&gt;timeout,$this-&gt;response_timeout);
+			}
+			$this-&gt;appendDebug($this-&gt;wsdl-&gt;getDebug());
+			$this-&gt;wsdl-&gt;clearDebug();
+			// catch errors
+			if($errstr = $this-&gt;wsdl-&gt;getError()){
+				$this-&gt;debug('got wsdl error: '.$errstr);
+				$this-&gt;setError('wsdl error: '.$errstr);
+			} elseif($this-&gt;operations = $this-&gt;wsdl-&gt;getOperations()){
+				$this-&gt;debug( 'got '.count($this-&gt;operations).' operations from wsdl '.$this-&gt;wsdlFile);
+				$this-&gt;endpointType = 'wsdl';
+			} else {
+				$this-&gt;debug( 'getOperations returned false');
+				$this-&gt;setError('no operations defined in the WSDL document!');
+			}
+		} else {
+			$this-&gt;debug(&quot;instantiate SOAP with endpoint at $endpoint&quot;);
+			$this-&gt;endpointType = 'soap';
+		}
+	}
+
+	/**
+	* calls method, returns PHP native type
+	*
+	* @param    string $method SOAP server URL or path
+	* @param    mixed $params An array, associative or simple, of the parameters
+	*			              for the method call, or a string that is the XML
+	*			              for the call.  For rpc style, this call will
+	*			              wrap the XML in a tag named after the method, as
+	*			              well as the SOAP Envelope and Body.  For document
+	*			              style, this will only wrap with the Envelope and Body.
+	*			              IMPORTANT: when using an array with document style,
+	*			              in which case there
+	*                         is really one parameter, the root of the fragment
+	*                         used in the call, which encloses what programmers
+	*                         normally think of parameters.  A parameter array
+	*                         *must* include the wrapper.
+	* @param	string $namespace optional method namespace (WSDL can override)
+	* @param	string $soapAction optional SOAPAction value (WSDL can override)
+	* @param	mixed $headers optional string of XML with SOAP header content, or array of soapval objects for SOAP headers
+	* @param	boolean $rpcParams optional (no longer used)
+	* @param	string	$style optional (rpc|document) the style to use when serializing parameters (WSDL can override)
+	* @param	string	$use optional (encoded|literal) the use when serializing parameters (WSDL can override)
+	* @return	mixed	response from SOAP call
+	* @access   public
+	*/
+	function call($operation,$params=array(),$namespace='<A HREF="http://tempuri.org">http://tempuri.org</A>',$soapAction='',$headers=false,$rpcParams=null,$style='rpc',$use='encoded'){
+		$this-&gt;operation = $operation;
+		$this-&gt;fault = false;
+		$this-&gt;setError('');
+		$this-&gt;request = '';
+		$this-&gt;response = '';
+		$this-&gt;responseData = '';
+		$this-&gt;faultstring = '';
+		$this-&gt;faultcode = '';
+		$this-&gt;opData = array();
+		
+		$this-&gt;debug(&quot;call: operation=$operation, namespace=$namespace, soapAction=$soapAction, rpcParams=$rpcParams, style=$style, use=$use, endpointType=$this-&gt;endpointType&quot;);
+		$this-&gt;appendDebug('params=' . $this-&gt;varDump($params));
+		$this-&gt;appendDebug('headers=' . $this-&gt;varDump($headers));
+		if ($headers) {
+			$this-&gt;requestHeaders = $headers;
+		}
+		// serialize parameters
+		if($this-&gt;endpointType == 'wsdl' &amp;&amp; $opData = $this-&gt;getOperationData($operation)){
+			// use WSDL for operation
+			$this-&gt;opData = $opData;
+			$this-&gt;debug(&quot;found operation&quot;);
+			$this-&gt;appendDebug('opData=' . $this-&gt;varDump($opData));
+			if (isset($opData['soapAction'])) {
+				$soapAction = $opData['soapAction'];
+			}
+			if (! $this-&gt;forceEndpoint) {
+				$this-&gt;endpoint = $opData['endpoint'];
+			} else {
+				$this-&gt;endpoint = $this-&gt;forceEndpoint;
+			}
+			$namespace = isset($opData['input']['namespace']) ? $opData['input']['namespace'] :	$namespace;
+			$style = $opData['style'];
+			$use = $opData['input']['use'];
+			// add ns to ns array
+			if($namespace != '' &amp;&amp; !isset($this-&gt;wsdl-&gt;namespaces[$namespace])){
+				$nsPrefix = 'ns' . rand(1000, 9999);
+				$this-&gt;wsdl-&gt;namespaces[$nsPrefix] = $namespace;
+			}
+            $nsPrefix = $this-&gt;wsdl-&gt;getPrefixFromNamespace($namespace);
+			// serialize payload
+			if (is_string($params)) {
+				$this-&gt;debug(&quot;serializing param string for WSDL operation $operation&quot;);
+				$payload = $params;
+			} elseif (is_array($params)) {
+				$this-&gt;debug(&quot;serializing param array for WSDL operation $operation&quot;);
+				$payload = $this-&gt;wsdl-&gt;serializeRPCParameters($operation,'input',$params);
+			} else {
+				$this-&gt;debug('params must be array or string');
+				$this-&gt;setError('params must be array or string');
+				return false;
+			}
+            $usedNamespaces = $this-&gt;wsdl-&gt;usedNamespaces;
+			if (isset($opData['input']['encodingStyle'])) {
+				$encodingStyle = $opData['input']['encodingStyle'];
+			} else {
+				$encodingStyle = '';
+			}
+			$this-&gt;appendDebug($this-&gt;wsdl-&gt;getDebug());
+			$this-&gt;wsdl-&gt;clearDebug();
+			if ($errstr = $this-&gt;wsdl-&gt;getError()) {
+				$this-&gt;debug('got wsdl error: '.$errstr);
+				$this-&gt;setError('wsdl error: '.$errstr);
+				return false;
+			}
+		} elseif($this-&gt;endpointType == 'wsdl') {
+			// operation not in WSDL
+			$this-&gt;appendDebug($this-&gt;wsdl-&gt;getDebug());
+			$this-&gt;wsdl-&gt;clearDebug();
+			$this-&gt;setError( 'operation '.$operation.' not present.');
+			$this-&gt;debug(&quot;operation '$operation' not present.&quot;);
+			return false;
+		} else {
+			// no WSDL
+			//$this-&gt;namespaces['ns1'] = $namespace;
+			$nsPrefix = 'ns' . rand(1000, 9999);
+			// serialize 
+			$payload = '';
+			if (is_string($params)) {
+				$this-&gt;debug(&quot;serializing param string for operation $operation&quot;);
+				$payload = $params;
+			} elseif (is_array($params)) {
+				$this-&gt;debug(&quot;serializing param array for operation $operation&quot;);
+				foreach($params as $k =&gt; $v){
+					$payload .= $this-&gt;serialize_val($v,$k,false,false,false,false,$use);
+				}
+			} else {
+				$this-&gt;debug('params must be array or string');
+				$this-&gt;setError('params must be array or string');
+				return false;
+			}
+			$usedNamespaces = array();
+			if ($use == 'encoded') {
+				$encodingStyle = '<A HREF="http://schemas.xmlsoap.org/soap/encoding/">http://schemas.xmlsoap.org/soap/encoding/</A>';
+			} else {
+				$encodingStyle = '';
+			}
+		}
+		// wrap RPC calls with method element
+		if ($style == 'rpc') {
+			if ($use == 'literal') {
+				$this-&gt;debug(&quot;wrapping RPC request with literal method element&quot;);
+				if ($namespace) {
+					$payload = &quot;&lt;$operation xmlns=\&quot;$namespace\&quot;&gt;&quot; . $payload . &quot;&lt;/$operation&gt;&quot;;
+				} else {
+					$payload = &quot;&lt;$operation&gt;&quot; . $payload . &quot;&lt;/$operation&gt;&quot;;
+				}
+			} else {
+				$this-&gt;debug(&quot;wrapping RPC request with encoded method element&quot;);
+				if ($namespace) {
+					$payload = &quot;&lt;$nsPrefix:$operation xmlns:$nsPrefix=\&quot;$namespace\&quot;&gt;&quot; .
+								$payload .
+								&quot;&lt;/$nsPrefix:$operation&gt;&quot;;
+				} else {
+					$payload = &quot;&lt;$operation&gt;&quot; .
+								$payload .
+								&quot;&lt;/$operation&gt;&quot;;
+				}
+			}
+		}
+		// serialize envelope
+		$soapmsg = $this-&gt;serializeEnvelope($payload,$this-&gt;requestHeaders,$usedNamespaces,$style,$use,$encodingStyle);
+		$this-&gt;debug(&quot;endpoint=$this-&gt;endpoint, soapAction=$soapAction, namespace=$namespace, style=$style, use=$use, encodingStyle=$encodingStyle&quot;);
+		$this-&gt;debug('SOAP message length=' . strlen($soapmsg) . ' contents (max 1000 bytes)=' . substr($soapmsg, 0, 1000));
+		// send
+		$return = $this-&gt;send($this-&gt;getHTTPBody($soapmsg),$soapAction,$this-&gt;timeout,$this-&gt;response_timeout);
+		if($errstr = $this-&gt;getError()){
+			$this-&gt;debug('Error: '.$errstr);
+			return false;
+		} else {
+			$this-&gt;return = $return;
+			$this-&gt;debug('sent message successfully and got a(n) '.gettype($return));
+           	$this-&gt;appendDebug('return=' . $this-&gt;varDump($return));
+			
+			// fault?
+			if(is_array($return) &amp;&amp; isset($return['faultcode'])){
+				$this-&gt;debug('got fault');
+				$this-&gt;setError($return['faultcode'].': '.$return['faultstring']);
+				$this-&gt;fault = true;
+				foreach($return as $k =&gt; $v){
+					$this-&gt;$k = $v;
+					$this-&gt;debug(&quot;$k = $v&lt;br&gt;&quot;);
+				}
+				return $return;
+			} elseif ($style == 'document') {
+				// NOTE: if the response is defined to have multiple parts (i.e. unwrapped),
+				// we are only going to return the first part here...sorry about that
+				return $return;
+			} else {
+				// array of return values
+				if(is_array($return)){
+					// multiple 'out' parameters, which we return wrapped up
+					// in the array
+					if(sizeof($return) &gt; 1){
+						return $return;
+					}
+					// single 'out' parameter (normally the return value)
+					$return = array_shift($return);
+					$this-&gt;debug('return shifted value: ');
+					$this-&gt;appendDebug($this-&gt;varDump($return));
+           			return $return;
+				// nothing returned (ie, echoVoid)
+				} else {
+					return &quot;&quot;;
+				}
+			}
+		}
+	}
+
+	/**
+	* get available data pertaining to an operation
+	*
+	* @param    string $operation operation name
+	* @return	array array of data pertaining to the operation
+	* @access   public
+	*/
+	function getOperationData($operation){
+		if(isset($this-&gt;operations[$operation])){
+			return $this-&gt;operations[$operation];
+		}
+		$this-&gt;debug(&quot;No data for operation: $operation&quot;);
+	}
+
+    /**
+    * send the SOAP message
+    *
+    * Note: if the operation has multiple return values
+    * the return value of this method will be an array
+    * of those values.
+    *
+	* @param    string $msg a SOAPx4 soapmsg object
+	* @param    string $soapaction SOAPAction value
+	* @param    integer $timeout set connection timeout in seconds
+	* @param	integer $response_timeout set response timeout in seconds
+	* @return	mixed native PHP types.
+	* @access   private
+	*/
+	function send($msg, $soapaction = '', $timeout=0, $response_timeout=30) {
+		$this-&gt;checkCookies();
+		// detect transport
+		switch(true){
+			// http(s)
+			case ereg('^http',$this-&gt;endpoint):
+				$this-&gt;debug('transporting via HTTP');
+				if($this-&gt;persistentConnection == true &amp;&amp; is_object($this-&gt;persistentConnection)){
+					$http =&amp; $this-&gt;persistentConnection;
+				} else {
+					$http = new soap_transport_http($this-&gt;endpoint);
+					if ($this-&gt;persistentConnection) {
+						$http-&gt;usePersistentConnection();
+					}
+				}
+				$http-&gt;setContentType($this-&gt;getHTTPContentType(), $this-&gt;getHTTPContentTypeCharset());
+				$http-&gt;setSOAPAction($soapaction);
+				if($this-&gt;proxyhost &amp;&amp; $this-&gt;proxyport){
+					$http-&gt;setProxy($this-&gt;proxyhost,$this-&gt;proxyport,$this-&gt;proxyusername,$this-&gt;proxypassword);
+				}
+                if($this-&gt;authtype != '') {
+					$http-&gt;setCredentials($this-&gt;username, $this-&gt;password, $this-&gt;authtype, array(), $this-&gt;certRequest);
+				}
+				if($this-&gt;http_encoding != ''){
+					$http-&gt;setEncoding($this-&gt;http_encoding);
+				}
+				$this-&gt;debug('sending message, length='.strlen($msg));
+				if(ereg('^http:',$this-&gt;endpoint)){
+				//if(strpos($this-&gt;endpoint,'http:')){
+					$this-&gt;responseData = $http-&gt;send($msg,$timeout,$response_timeout,$this-&gt;cookies);
+				} elseif(ereg('^https',$this-&gt;endpoint)){
+				//} elseif(strpos($this-&gt;endpoint,'https:')){
+					//if(phpversion() == '4.3.0-dev'){
+						//$response = $http-&gt;send($msg,$timeout,$response_timeout);
+                   		//$this-&gt;request = $http-&gt;outgoing_payload;
+						//$this-&gt;response = $http-&gt;incoming_payload;
+					//} else
+					$this-&gt;responseData = $http-&gt;sendHTTPS($msg,$timeout,$response_timeout,$this-&gt;cookies);
+				} else {
+					$this-&gt;setError('no http/s in endpoint url');
+				}
+				$this-&gt;request = $http-&gt;outgoing_payload;
+				$this-&gt;response = $http-&gt;incoming_payload;
+				$this-&gt;appendDebug($http-&gt;getDebug());
+				$this-&gt;UpdateCookies($http-&gt;incoming_cookies);
+
+				// save transport object if using persistent connections
+				if ($this-&gt;persistentConnection) {
+					$http-&gt;clearDebug();
+					if (!is_object($this-&gt;persistentConnection)) {
+						$this-&gt;persistentConnection = $http;
+					}
+				}
+				
+				if($err = $http-&gt;getError()){
+					$this-&gt;setError('HTTP Error: '.$err);
+					return false;
+				} elseif($this-&gt;getError()){
+					return false;
+				} else {
+					$this-&gt;debug('got response, length='. strlen($this-&gt;responseData).' type='.$http-&gt;incoming_headers['content-type']);
+					return $this-&gt;parseResponse($http-&gt;incoming_headers, $this-&gt;responseData);
+				}
+			break;
+			default:
+				$this-&gt;setError('no transport found, or selected transport is not yet supported!');
+			return false;
+			break;
+		}
+	}
+
+	/**
+	* processes SOAP message returned from server
+	*
+	* @param	array	$headers	The HTTP headers
+	* @param	string	$data		unprocessed response data from server
+	* @return	mixed	value of the message, decoded into a PHP type
+	* @access   private
+	*/
+    function parseResponse($headers, $data) {
+		$this-&gt;debug('Entering parseResponse() for data of length ' . strlen($data) . ' and type ' . $headers['content-type']);
+		if (!strstr($headers['content-type'], 'text/xml')) {
+			$this-&gt;setError('Response not of type text/xml');
+			return false;
+		}
+		if (strpos($headers['content-type'], '=')) {
+			$enc = str_replace('&quot;', '', substr(strstr($headers[&quot;content-type&quot;], '='), 1));
+			$this-&gt;debug('Got response encoding: ' . $enc);
+			if(eregi('^(ISO-8859-1|US-ASCII|UTF-8)$',$enc)){
+				$this-&gt;xml_encoding = strtoupper($enc);
+			} else {
+				$this-&gt;xml_encoding = 'US-ASCII';
+			}
+		} else {
+			// should be US-ASCII for HTTP 1.0 or ISO-8859-1 for HTTP 1.1
+			$this-&gt;xml_encoding = 'ISO-8859-1';
+		}
+		$this-&gt;debug('Use encoding: ' . $this-&gt;xml_encoding . ' when creating soap_parser');
+		$parser = new soap_parser($data,$this-&gt;xml_encoding,$this-&gt;operation,$this-&gt;decode_utf8);
+		// add parser debug data to our debug
+		$this-&gt;appendDebug($parser-&gt;getDebug());
+		// if parse errors
+		if($errstr = $parser-&gt;getError()){
+			$this-&gt;setError( $errstr);
+			// destroy the parser object
+			unset($parser);
+			return false;
+		} else {
+			// get SOAP headers
+			$this-&gt;responseHeaders = $parser-&gt;getHeaders();
+			// get decoded message
+			$return = $parser-&gt;get_response();
+            // add document for doclit support
+            $this-&gt;document = $parser-&gt;document;
+			// destroy the parser object
+			unset($parser);
+			// return decode message
+			return $return;
+		}
+	 }
+
+	/**
+	* sets the SOAP endpoint, which can override WSDL
+	*
+	* @param	$endpoint string The endpoint URL to use, or empty string or false to prevent override
+	* @access   public
+	*/
+	function setEndpoint($endpoint) {
+		$this-&gt;forceEndpoint = $endpoint;
+	}
+
+	/**
+	* set the SOAP headers
+	*
+	* @param	$headers mixed String of XML with SOAP header content, or array of soapval objects for SOAP headers
+	* @access   public
+	*/
+	function setHeaders($headers){
+		$this-&gt;requestHeaders = $headers;
+	}
+
+	/**
+	* get the SOAP response headers (namespace resolution incomplete)
+	*
+	* @return	string
+	* @access   public
+	*/
+	function getHeaders(){
+		return $this-&gt;responseHeaders;
+	}
+
+	/**
+	* set proxy info here
+	*
+	* @param    string $proxyhost
+	* @param    string $proxyport
+	* @param	string $proxyusername
+	* @param	string $proxypassword
+	* @access   public
+	*/
+	function setHTTPProxy($proxyhost, $proxyport, $proxyusername = '', $proxypassword = '') {
+		$this-&gt;proxyhost = $proxyhost;
+		$this-&gt;proxyport = $proxyport;
+		$this-&gt;proxyusername = $proxyusername;
+		$this-&gt;proxypassword = $proxypassword;
+	}
+
+	/**
+	* if authenticating, set user credentials here
+	*
+	* @param    string $username
+	* @param    string $password
+	* @param	string $authtype (basic|digest|certificate)
+	* @param	array $certRequest (keys must be cainfofile (optional), sslcertfile, sslkeyfile, passphrase, verifypeer (optional), verifyhost (optional): see corresponding options in cURL docs)
+	* @access   public
+	*/
+	function setCredentials($username, $password, $authtype = 'basic', $certRequest = array()) {
+		$this-&gt;username = $username;
+		$this-&gt;password = $password;
+		$this-&gt;authtype = $authtype;
+		$this-&gt;certRequest = $certRequest;
+	}
+	
+	/**
+	* use HTTP encoding
+	*
+	* @param    string $enc
+	* @access   public
+	*/
+	function setHTTPEncoding($enc='gzip, deflate'){
+		$this-&gt;http_encoding = $enc;
+	}
+	
+	/**
+	* use HTTP persistent connections if possible
+	*
+	* @access   public
+	*/
+	function useHTTPPersistentConnection(){
+		$this-&gt;persistentConnection = true;
+	}
+	
+	/**
+	* gets the default RPC parameter setting.
+	* If true, default is that call params are like RPC even for document style.
+	* Each call() can override this value.
+	*
+	* This is no longer used.
+	*
+	* @return boolean
+	* @access public
+	* @deprecated
+	*/
+	function getDefaultRpcParams() {
+		return $this-&gt;defaultRpcParams;
+	}
+
+	/**
+	* sets the default RPC parameter setting.
+	* If true, default is that call params are like RPC even for document style
+	* Each call() can override this value.
+	*
+	* This is no longer used.
+	*
+	* @param    boolean $rpcParams
+	* @access public
+	* @deprecated
+	*/
+	function setDefaultRpcParams($rpcParams) {
+		$this-&gt;defaultRpcParams = $rpcParams;
+	}
+	
+	/**
+	* dynamically creates an instance of a proxy class,
+	* allowing user to directly call methods from wsdl
+	*
+	* @return   object soap_proxy object
+	* @access   public
+	*/
+	function getProxy(){
+		$r = rand();
+		$evalStr = $this-&gt;_getProxyClassCode($r);
+		//$this-&gt;debug(&quot;proxy class: $evalStr&quot;;
+		// eval the class
+		eval($evalStr);
+		// instantiate proxy object
+		eval(&quot;\$proxy = new soap_proxy_$r('');&quot;);
+		// transfer current wsdl data to the proxy thereby avoiding parsing the wsdl twice
+		$proxy-&gt;endpointType = 'wsdl';
+		$proxy-&gt;wsdlFile = $this-&gt;wsdlFile;
+		$proxy-&gt;wsdl = $this-&gt;wsdl;
+		$proxy-&gt;operations = $this-&gt;operations;
+		$proxy-&gt;defaultRpcParams = $this-&gt;defaultRpcParams;
+		// transfer other state
+		$proxy-&gt;username = $this-&gt;username;
+		$proxy-&gt;password = $this-&gt;password;
+		$proxy-&gt;authtype = $this-&gt;authtype;
+		$proxy-&gt;proxyhost = $this-&gt;proxyhost;
+		$proxy-&gt;proxyport = $this-&gt;proxyport;
+		$proxy-&gt;proxyusername = $this-&gt;proxyusername;
+		$proxy-&gt;proxypassword = $this-&gt;proxypassword;
+		$proxy-&gt;timeout = $this-&gt;timeout;
+		$proxy-&gt;response_timeout = $this-&gt;response_timeout;
+		$proxy-&gt;http_encoding = $this-&gt;http_encoding;
+		$proxy-&gt;persistentConnection = $this-&gt;persistentConnection;
+		$proxy-&gt;requestHeaders = $this-&gt;requestHeaders;
+		$proxy-&gt;soap_defencoding = $this-&gt;soap_defencoding;
+		$proxy-&gt;endpoint = $this-&gt;endpoint;
+		$proxy-&gt;forceEndpoint = $this-&gt;forceEndpoint;
+		return $proxy;
+	}
+
+	/**
+	* dynamically creates proxy class code
+	*
+	* @return   string PHP/NuSOAP code for the proxy class
+	* @access   private
+	*/
+	function _getProxyClassCode($r) {
+		if ($this-&gt;endpointType != 'wsdl') {
+			$evalStr = 'A proxy can only be created for a WSDL client';
+			$this-&gt;setError($evalStr);
+			return $evalStr;
+		}
+		$evalStr = '';
+		foreach ($this-&gt;operations as $operation =&gt; $opData) {
+			if ($operation != '') {
+				// create param string and param comment string
+				if (sizeof($opData['input']['parts']) &gt; 0) {
+					$paramStr = '';
+					$paramArrayStr = '';
+					$paramCommentStr = '';
+					foreach ($opData['input']['parts'] as $name =&gt; $type) {
+						$paramStr .= &quot;\$$name, &quot;;
+						$paramArrayStr .= &quot;'$name' =&gt; \$$name, &quot;;
+						$paramCommentStr .= &quot;$type \$$name, &quot;;
+					}
+					$paramStr = substr($paramStr, 0, strlen($paramStr)-2);
+					$paramArrayStr = substr($paramArrayStr, 0, strlen($paramArrayStr)-2);
+					$paramCommentStr = substr($paramCommentStr, 0, strlen($paramCommentStr)-2);
+				} else {
+					$paramStr = '';
+					$paramCommentStr = 'void';
+				}
+				$opData['namespace'] = !isset($opData['namespace']) ? '<A HREF="http://testuri.com">http://testuri.com</A>' : $opData['namespace'];
+				$evalStr .= &quot;// $paramCommentStr
+	function &quot; . str_replace('.', '__', $operation) . &quot;($paramStr) {
+		\$params = array($paramArrayStr);
+		return \$this-&gt;call('$operation', \$params, '&quot;.$opData['namespace'].&quot;', '&quot;.(isset($opData['soapAction']) ? $opData['soapAction'] : '').&quot;');
+	}
+	&quot;;
+				unset($paramStr);
+				unset($paramCommentStr);
+			}
+		}
+		$evalStr = 'class soap_proxy_'.$r.' extends soapclient {
+	'.$evalStr.'
+}';
+		return $evalStr;
+	}
+
+	/**
+	* dynamically creates proxy class code
+	*
+	* @return   string PHP/NuSOAP code for the proxy class
+	* @access   public
+	*/
+	function getProxyClassCode() {
+		$r = rand();
+		return $this-&gt;_getProxyClassCode($r);
+	}
+
+	/**
+	* gets the HTTP body for the current request.
+	*
+	* @param string $soapmsg The SOAP payload
+	* @return string The HTTP body, which includes the SOAP payload
+	* @access private
+	*/
+	function getHTTPBody($soapmsg) {
+		return $soapmsg;
+	}
+	
+	/**
+	* gets the HTTP content type for the current request.
+	*
+	* Note: getHTTPBody must be called before this.
+	*
+	* @return string the HTTP content type for the current request.
+	* @access private
+	*/
+	function getHTTPContentType() {
+		return 'text/xml';
+	}
+	
+	/**
+	* gets the HTTP content type charset for the current request.
+	* returns false for non-text content types.
+	*
+	* Note: getHTTPBody must be called before this.
+	*
+	* @return string the HTTP content type charset for the current request.
+	* @access private
+	*/
+	function getHTTPContentTypeCharset() {
+		return $this-&gt;soap_defencoding;
+	}
+
+	/*
+	* whether or not parser should decode utf8 element content
+    *
+    * @return   always returns true
+    * @access   public
+    */
+    function decodeUTF8($bool){
+		$this-&gt;decode_utf8 = $bool;
+		return true;
+    }
+
+	/**
+	 * adds a new Cookie into $this-&gt;cookies array
+	 *
+	 * @param	string $name Cookie Name
+	 * @param	string $value Cookie Value
+	 * @return	if cookie-set was successful returns true, else false
+	 * @access	public
+	 */
+	function setCookie($name, $value) {
+		if (strlen($name) == 0) {
+			return false;
+		}
+		$this-&gt;cookies[] = array('name' =&gt; $name, 'value' =&gt; $value);
+		return true;
+	}
+
+	/**
+	 * gets all Cookies
+	 *
+	 * @return   array with all internal cookies
+	 * @access   public
+	 */
+	function getCookies() {
+		return $this-&gt;cookies;
+	}
+
+	/**
+	 * checks all Cookies and delete those which are expired
+	 *
+	 * @return   always return true
+	 * @access   private
+	 */
+	function checkCookies() {
+		if (sizeof($this-&gt;cookies) == 0) {
+			return true;
+		}
+		$this-&gt;debug('checkCookie: check ' . sizeof($this-&gt;cookies) . ' cookies');
+		$curr_cookies = $this-&gt;cookies;
+		$this-&gt;cookies = array();
+		foreach ($curr_cookies as $cookie) {
+			if (! is_array($cookie)) {
+				$this-&gt;debug('Remove cookie that is not an array');
+				continue;
+			}
+			if ((isset($cookie['expires'])) &amp;&amp; (! empty($cookie['expires']))) {
+				if (strtotime($cookie['expires']) &gt; time()) {
+					$this-&gt;cookies[] = $cookie;
+				} else {
+					$this-&gt;debug('Remove expired cookie ' . $cookie['name']);
+				}
+			} else {
+				$this-&gt;cookies[] = $cookie;
+			}
+		}
+		$this-&gt;debug('checkCookie: '.sizeof($this-&gt;cookies).' cookies left in array');
+		return true;
+	}
+
+	/**
+	 * updates the current cookies with a new set
+	 *
+	 * @param	array $cookies new cookies with which to update current ones
+	 * @return	always return true
+	 * @access	private
+	 */
+	function UpdateCookies($cookies) {
+		if (sizeof($this-&gt;cookies) == 0) {
+			// no existing cookies: take whatever is new
+			if (sizeof($cookies) &gt; 0) {
+				$this-&gt;debug('Setting new cookie(s)');
+				$this-&gt;cookies = $cookies;
+			}
+			return true;
+		}
+		if (sizeof($cookies) == 0) {
+			// no new cookies: keep what we've got
+			return true;
+		}
+		// merge
+		foreach ($cookies as $newCookie) {
+			if (!is_array($newCookie)) {
+				continue;
+			}
+			if ((!isset($newCookie['name'])) || (!isset($newCookie['value']))) {
+				continue;
+			}
+			$newName = $newCookie['name'];
+
+			$found = false;
+			for ($i = 0; $i &lt; count($this-&gt;cookies); $i++) {
+				$cookie = $this-&gt;cookies[$i];
+				if (!is_array($cookie)) {
+					continue;
+				}
+				if (!isset($cookie['name'])) {
+					continue;
+				}
+				if ($newName != $cookie['name']) {
+					continue;
+				}
+				$newDomain = isset($newCookie['domain']) ? $newCookie['domain'] : 'NODOMAIN';
+				$domain = isset($cookie['domain']) ? $cookie['domain'] : 'NODOMAIN';
+				if ($newDomain != $domain) {
+					continue;
+				}
+				$newPath = isset($newCookie['path']) ? $newCookie['path'] : 'NOPATH';
+				$path = isset($cookie['path']) ? $cookie['path'] : 'NOPATH';
+				if ($newPath != $path) {
+					continue;
+				}
+				$this-&gt;cookies[$i] = $newCookie;
+				$found = true;
+				$this-&gt;debug('Update cookie ' . $newName . '=' . $newCookie['value']);
+				break;
+			}
+			if (! $found) {
+				$this-&gt;debug('Add cookie ' . $newName . '=' . $newCookie['value']);
+				$this-&gt;cookies[] = $newCookie;
+			}
+		}
+		return true;
+	}
+}
+?&gt;

Added: cms/trunk/includes/nusoap/class.wsdl.php
===================================================================
--- cms/trunk/includes/nusoap/class.wsdl.php	2005-09-20 21:46:50 UTC (rev 136)
+++ cms/trunk/includes/nusoap/class.wsdl.php	2005-09-21 03:53:30 UTC (rev 137)
@@ -0,0 +1,1727 @@
+&lt;?php
+
+
+
+
+/**
+* parses a WSDL file, allows access to it's data, other utility methods
+* 
+* @author   Dietrich Ayala &lt;<A HREF="https://lists.berlios.de/mailman/listinfo/viperals-svncheckins">dietrich at ganx4.com</A>&gt;
+* @version  $Id: class.wsdl.php,v 1.56 2005/08/04 01:27:42 snichol Exp $
+* @access public 
+*/
+class wsdl extends nusoap_base {
+	// URL or filename of the root of this WSDL
+    var $wsdl; 
+    // define internal arrays of bindings, ports, operations, messages, etc.
+    var $schemas = array();
+    var $currentSchema;
+    var $message = array();
+    var $complexTypes = array();
+    var $messages = array();
+    var $currentMessage;
+    var $currentOperation;
+    var $portTypes = array();
+    var $currentPortType;
+    var $bindings = array();
+    var $currentBinding;
+    var $ports = array();
+    var $currentPort;
+    var $opData = array();
+    var $status = '';
+    var $documentation = false;
+    var $endpoint = ''; 
+    // array of wsdl docs to import
+    var $import = array(); 
+    // parser vars
+    var $parser;
+    var $position = 0;
+    var $depth = 0;
+    var $depth_array = array();
+	// for getting wsdl
+	var $proxyhost = '';
+    var $proxyport = '';
+	var $proxyusername = '';
+	var $proxypassword = '';
+	var $timeout = 0;
+	var $response_timeout = 30;
+
+    /**
+     * constructor
+     * 
+     * @param string $wsdl WSDL document URL
+	 * @param string $proxyhost
+	 * @param string $proxyport
+	 * @param string $proxyusername
+	 * @param string $proxypassword
+	 * @param integer $timeout set the connection timeout
+	 * @param integer $response_timeout set the response timeout
+     * @access public 
+     */
+    function wsdl($wsdl = '',$proxyhost=false,$proxyport=false,$proxyusername=false,$proxypassword=false,$timeout=0,$response_timeout=30){
+		parent::nusoap_base();
+        $this-&gt;wsdl = $wsdl;
+        $this-&gt;proxyhost = $proxyhost;
+        $this-&gt;proxyport = $proxyport;
+		$this-&gt;proxyusername = $proxyusername;
+		$this-&gt;proxypassword = $proxypassword;
+		$this-&gt;timeout = $timeout;
+		$this-&gt;response_timeout = $response_timeout;
+        
+        // parse wsdl file
+        if ($wsdl != &quot;&quot;) {
+            $this-&gt;debug('initial wsdl URL: ' . $wsdl);
+            $this-&gt;parseWSDL($wsdl);
+        }
+        // imports
+        // TODO: handle imports more properly, grabbing them in-line and nesting them
+        	$imported_urls = array();
+        	$imported = 1;
+        	while ($imported &gt; 0) {
+        		$imported = 0;
+        		// Schema imports
+        		foreach ($this-&gt;schemas as $ns =&gt; $list) {
+        			foreach ($list as $xs) {
+						$wsdlparts = parse_url($this-&gt;wsdl);	// this is bogusly simple!
+			            foreach ($xs-&gt;imports as $ns2 =&gt; $list2) {
+			                for ($ii = 0; $ii &lt; count($list2); $ii++) {
+			                	if (! $list2[$ii]['loaded']) {
+			                		$this-&gt;schemas[$ns]-&gt;imports[$ns2][$ii]['loaded'] = true;
+			                		$url = $list2[$ii]['location'];
+									if ($url != '') {
+										$urlparts = parse_url($url);
+										if (!isset($urlparts['host'])) {
+											$url = $wsdlparts['scheme'] . '://' . $wsdlparts['host'] . (isset($wsdlparts['port']) ? ':' .$wsdlparts['port'] : '') .
+													substr($wsdlparts['path'],0,strrpos($wsdlparts['path'],'/') + 1) .$urlparts['path'];
+										}
+										if (! in_array($url, $imported_urls)) {
+						                	$this-&gt;parseWSDL($url);
+					                		$imported++;
+					                		$imported_urls[] = $url;
+					                	}
+									} else {
+										$this-&gt;debug(&quot;Unexpected scenario: empty URL for unloaded import&quot;);
+									}
+								}
+							}
+			            } 
+        			}
+        		}
+        		// WSDL imports
+				$wsdlparts = parse_url($this-&gt;wsdl);	// this is bogusly simple!
+	            foreach ($this-&gt;import as $ns =&gt; $list) {
+	                for ($ii = 0; $ii &lt; count($list); $ii++) {
+	                	if (! $list[$ii]['loaded']) {
+	                		$this-&gt;import[$ns][$ii]['loaded'] = true;
+	                		$url = $list[$ii]['location'];
+							if ($url != '') {
+								$urlparts = parse_url($url);
+								if (!isset($urlparts['host'])) {
+									$url = $wsdlparts['scheme'] . '://' . $wsdlparts['host'] . (isset($wsdlparts['port']) ? ':' . $wsdlparts['port'] : '') .
+											substr($wsdlparts['path'],0,strrpos($wsdlparts['path'],'/') + 1) .$urlparts['path'];
+								}
+								if (! in_array($url, $imported_urls)) {
+				                	$this-&gt;parseWSDL($url);
+			                		$imported++;
+			                		$imported_urls[] = $url;
+			                	}
+							} else {
+								$this-&gt;debug(&quot;Unexpected scenario: empty URL for unloaded import&quot;);
+							}
+						}
+					}
+	            } 
+			}
+        // add new data to operation data
+        foreach($this-&gt;bindings as $binding =&gt; $bindingData) {
+            if (isset($bindingData['operations']) &amp;&amp; is_array($bindingData['operations'])) {
+                foreach($bindingData['operations'] as $operation =&gt; $data) {
+                    $this-&gt;debug('post-parse data gathering for ' . $operation);
+                    $this-&gt;bindings[$binding]['operations'][$operation]['input'] = 
+						isset($this-&gt;bindings[$binding]['operations'][$operation]['input']) ? 
+						array_merge($this-&gt;bindings[$binding]['operations'][$operation]['input'], $this-&gt;portTypes[ $bindingData['portType'] ][$operation]['input']) :
+						$this-&gt;portTypes[ $bindingData['portType'] ][$operation]['input'];
+                    $this-&gt;bindings[$binding]['operations'][$operation]['output'] = 
+						isset($this-&gt;bindings[$binding]['operations'][$operation]['output']) ?
+						array_merge($this-&gt;bindings[$binding]['operations'][$operation]['output'], $this-&gt;portTypes[ $bindingData['portType'] ][$operation]['output']) :
+						$this-&gt;portTypes[ $bindingData['portType'] ][$operation]['output'];
+                    if(isset($this-&gt;messages[ $this-&gt;bindings[$binding]['operations'][$operation]['input']['message'] ])){
+						$this-&gt;bindings[$binding]['operations'][$operation]['input']['parts'] = $this-&gt;messages[ $this-&gt;bindings[$binding]['operations'][$operation]['input']['message'] ];
+					}
+					if(isset($this-&gt;messages[ $this-&gt;bindings[$binding]['operations'][$operation]['output']['message'] ])){
+                   		$this-&gt;bindings[$binding]['operations'][$operation]['output']['parts'] = $this-&gt;messages[ $this-&gt;bindings[$binding]['operations'][$operation]['output']['message'] ];
+                    }
+					if (isset($bindingData['style'])) {
+                        $this-&gt;bindings[$binding]['operations'][$operation]['style'] = $bindingData['style'];
+                    }
+                    $this-&gt;bindings[$binding]['operations'][$operation]['transport'] = isset($bindingData['transport']) ? $bindingData['transport'] : '';
+                    $this-&gt;bindings[$binding]['operations'][$operation]['documentation'] = isset($this-&gt;portTypes[ $bindingData['portType'] ][$operation]['documentation']) ? $this-&gt;portTypes[ $bindingData['portType'] ][$operation]['documentation'] : '';
+                    $this-&gt;bindings[$binding]['operations'][$operation]['endpoint'] = isset($bindingData['endpoint']) ? $bindingData['endpoint'] : '';
+                } 
+            } 
+        }
+    }
+
+    /**
+     * parses the wsdl document
+     * 
+     * @param string $wsdl path or URL
+     * @access private 
+     */
+    function parseWSDL($wsdl = '')
+    {
+        if ($wsdl == '') {
+            $this-&gt;debug('no wsdl passed to parseWSDL()!!');
+            $this-&gt;setError('no wsdl passed to parseWSDL()!!');
+            return false;
+        }
+        
+        // parse $wsdl for url format
+        $wsdl_props = parse_url($wsdl);
+
+        if (isset($wsdl_props['scheme']) &amp;&amp; ($wsdl_props['scheme'] == 'http' || $wsdl_props['scheme'] == 'https')) {
+            $this-&gt;debug('getting WSDL http(s) URL ' . $wsdl);
+        	// get wsdl
+	        $tr = new soap_transport_http($wsdl);
+			$tr-&gt;request_method = 'GET';
+			$tr-&gt;useSOAPAction = false;
+			if($this-&gt;proxyhost &amp;&amp; $this-&gt;proxyport){
+				$tr-&gt;setProxy($this-&gt;proxyhost,$this-&gt;proxyport,$this-&gt;proxyusername,$this-&gt;proxypassword);
+			}
+			$tr-&gt;setEncoding('gzip, deflate');
+			$wsdl_string = $tr-&gt;send('', $this-&gt;timeout, $this-&gt;response_timeout);
+			//$this-&gt;debug(&quot;WSDL request\n&quot; . $tr-&gt;outgoing_payload);
+			//$this-&gt;debug(&quot;WSDL response\n&quot; . $tr-&gt;incoming_payload);
+			$this-&gt;appendDebug($tr-&gt;getDebug());
+			// catch errors
+			if($err = $tr-&gt;getError() ){
+				$errstr = 'HTTP ERROR: '.$err;
+				$this-&gt;debug($errstr);
+	            $this-&gt;setError($errstr);
+				unset($tr);
+	            return false;
+			}
+			unset($tr);
+			$this-&gt;debug(&quot;got WSDL URL&quot;);
+        } else {
+            // $wsdl is not http(s), so treat it as a file URL or plain file path
+        	if (isset($wsdl_props['scheme']) &amp;&amp; ($wsdl_props['scheme'] == 'file') &amp;&amp; isset($wsdl_props['path'])) {
+        		$path = isset($wsdl_props['host']) ? ($wsdl_props['host'] . ':' . $wsdl_props['path']) : $wsdl_props['path'];
+        	} else {
+        		$path = $wsdl;
+        	}
+            $this-&gt;debug('getting WSDL file ' . $path);
+            if ($fp = @fopen($path, 'r')) {
+                $wsdl_string = '';
+                while ($data = fread($fp, 32768)) {
+                    $wsdl_string .= $data;
+                } 
+                fclose($fp);
+            } else {
+            	$errstr = &quot;Bad path to WSDL file $path&quot;;
+            	$this-&gt;debug($errstr);
+                $this-&gt;setError($errstr);
+                return false;
+            } 
+        }
+        $this-&gt;debug('Parse WSDL');
+        // end new code added
+        // Create an XML parser.
+        $this-&gt;parser = xml_parser_create(); 
+        // Set the options for parsing the XML data.
+        // xml_parser_set_option($parser, XML_OPTION_SKIP_WHITE, 1);
+        xml_parser_set_option($this-&gt;parser, XML_OPTION_CASE_FOLDING, 0); 
+        // Set the object for the parser.
+        xml_set_object($this-&gt;parser, $this); 
+        // Set the element handlers for the parser.
+        xml_set_element_handler($this-&gt;parser, 'start_element', 'end_element');
+        xml_set_character_data_handler($this-&gt;parser, 'character_data');
+        // Parse the XML file.
+        if (!xml_parse($this-&gt;parser, $wsdl_string, true)) {
+            // Display an error message.
+            $errstr = sprintf(
+				'XML error parsing WSDL from %s on line %d: %s',
+				$wsdl,
+                xml_get_current_line_number($this-&gt;parser),
+                xml_error_string(xml_get_error_code($this-&gt;parser))
+                );
+            $this-&gt;debug($errstr);
+			$this-&gt;debug(&quot;XML payload:\n&quot; . $wsdl_string);
+            $this-&gt;setError($errstr);
+            return false;
+        } 
+		// free the parser
+        xml_parser_free($this-&gt;parser);
+        $this-&gt;debug('Parsing WSDL done');
+		// catch wsdl parse errors
+		if($this-&gt;getError()){
+			return false;
+		}
+        return true;
+    } 
+
+    /**
+     * start-element handler
+     * 
+     * @param string $parser XML parser object
+     * @param string $name element name
+     * @param string $attrs associative array of attributes
+     * @access private 
+     */
+    function start_element($parser, $name, $attrs)
+    {
+        if ($this-&gt;status == 'schema') {
+            $this-&gt;currentSchema-&gt;schemaStartElement($parser, $name, $attrs);
+            $this-&gt;appendDebug($this-&gt;currentSchema-&gt;getDebug());
+            $this-&gt;currentSchema-&gt;clearDebug();
+        } elseif (ereg('schema$', $name)) {
+        	$this-&gt;debug('Parsing WSDL schema');
+            // $this-&gt;debug(&quot;startElement for $name ($attrs[name]). status = $this-&gt;status (&quot;.$this-&gt;getLocalPart($name).&quot;)&quot;);
+            $this-&gt;status = 'schema';
+            $this-&gt;currentSchema = new xmlschema('', '', $this-&gt;namespaces);
+            $this-&gt;currentSchema-&gt;schemaStartElement($parser, $name, $attrs);
+            $this-&gt;appendDebug($this-&gt;currentSchema-&gt;getDebug());
+            $this-&gt;currentSchema-&gt;clearDebug();
+        } else {
+            // position in the total number of elements, starting from 0
+            $pos = $this-&gt;position++;
+            $depth = $this-&gt;depth++; 
+            // set self as current value for this depth
+            $this-&gt;depth_array[$depth] = $pos;
+            $this-&gt;message[$pos] = array('cdata' =&gt; ''); 
+            // process attributes
+            if (count($attrs) &gt; 0) {
+				// register namespace declarations
+                foreach($attrs as $k =&gt; $v) {
+                    if (ereg(&quot;^xmlns&quot;, $k)) {
+                        if ($ns_prefix = substr(strrchr($k, ':'), 1)) {
+                            $this-&gt;namespaces[$ns_prefix] = $v;
+                        } else {
+                            $this-&gt;namespaces['ns' . (count($this-&gt;namespaces) + 1)] = $v;
+                        } 
+                        if ($v == '<A HREF="http://www.w3.org/2001/XMLSchema">http://www.w3.org/2001/XMLSchema</A>' || $v == '<A HREF="http://www.w3.org/1999/XMLSchema">http://www.w3.org/1999/XMLSchema</A>' || $v == '<A HREF="http://www.w3.org/2000/10/XMLSchema">http://www.w3.org/2000/10/XMLSchema</A>') {
+                            $this-&gt;XMLSchemaVersion = $v;
+                            $this-&gt;namespaces['xsi'] = $v . '-instance';
+                        } 
+                    }
+                }
+                // expand each attribute prefix to its namespace
+                foreach($attrs as $k =&gt; $v) {
+                    $k = strpos($k, ':') ? $this-&gt;expandQname($k) : $k;
+                    if ($k != 'location' &amp;&amp; $k != 'soapAction' &amp;&amp; $k != 'namespace') {
+                        $v = strpos($v, ':') ? $this-&gt;expandQname($v) : $v;
+                    } 
+                    $eAttrs[$k] = $v;
+                } 
+                $attrs = $eAttrs;
+            } else {
+                $attrs = array();
+            } 
+            // get element prefix, namespace and name
+            if (ereg(':', $name)) {
+                // get ns prefix
+                $prefix = substr($name, 0, strpos($name, ':')); 
+                // get ns
+                $namespace = isset($this-&gt;namespaces[$prefix]) ? $this-&gt;namespaces[$prefix] : ''; 
+                // get unqualified name
+                $name = substr(strstr($name, ':'), 1);
+            } 
+			// process attributes, expanding any prefixes to namespaces
+            // find status, register data
+            switch ($this-&gt;status) {
+                case 'message':
+                    if ($name == 'part') {
+			            if (isset($attrs['type'])) {
+		                    $this-&gt;debug(&quot;msg &quot; . $this-&gt;currentMessage . &quot;: found part $attrs[name]: &quot; . implode(',', $attrs));
+		                    $this-&gt;messages[$this-&gt;currentMessage][$attrs['name']] = $attrs['type'];
+            			} 
+			            if (isset($attrs['element'])) {
+		                    $this-&gt;debug(&quot;msg &quot; . $this-&gt;currentMessage . &quot;: found part $attrs[name]: &quot; . implode(',', $attrs));
+			                $this-&gt;messages[$this-&gt;currentMessage][$attrs['name']] = $attrs['element'];
+			            } 
+        			} 
+        			break;
+			    case 'portType':
+			        switch ($name) {
+			            case 'operation':
+			                $this-&gt;currentPortOperation = $attrs['name'];
+			                $this-&gt;debug(&quot;portType $this-&gt;currentPortType operation: $this-&gt;currentPortOperation&quot;);
+			                if (isset($attrs['parameterOrder'])) {
+			                	$this-&gt;portTypes[$this-&gt;currentPortType][$attrs['name']]['parameterOrder'] = $attrs['parameterOrder'];
+			        		} 
+			        		break;
+					    case 'documentation':
+					        $this-&gt;documentation = true;
+					        break; 
+					    // merge input/output data
+					    default:
+					        $m = isset($attrs['message']) ? $this-&gt;getLocalPart($attrs['message']) : '';
+					        $this-&gt;portTypes[$this-&gt;currentPortType][$this-&gt;currentPortOperation][$name]['message'] = $m;
+					        break;
+					} 
+			    	break;
+				case 'binding':
+				    switch ($name) {
+				        case 'binding': 
+				            // get ns prefix
+				            if (isset($attrs['style'])) {
+				            $this-&gt;bindings[$this-&gt;currentBinding]['prefix'] = $prefix;
+					    	} 
+					    	$this-&gt;bindings[$this-&gt;currentBinding] = array_merge($this-&gt;bindings[$this-&gt;currentBinding], $attrs);
+					    	break;
+						case 'header':
+						    $this-&gt;bindings[$this-&gt;currentBinding]['operations'][$this-&gt;currentOperation][$this-&gt;opStatus]['headers'][] = $attrs;
+						    break;
+						case 'operation':
+						    if (isset($attrs['soapAction'])) {
+						        $this-&gt;bindings[$this-&gt;currentBinding]['operations'][$this-&gt;currentOperation]['soapAction'] = $attrs['soapAction'];
+						    } 
+						    if (isset($attrs['style'])) {
+						        $this-&gt;bindings[$this-&gt;currentBinding]['operations'][$this-&gt;currentOperation]['style'] = $attrs['style'];
+						    } 
+						    if (isset($attrs['name'])) {
+						        $this-&gt;currentOperation = $attrs['name'];
+						        $this-&gt;debug(&quot;current binding operation: $this-&gt;currentOperation&quot;);
+						        $this-&gt;bindings[$this-&gt;currentBinding]['operations'][$this-&gt;currentOperation]['name'] = $attrs['name'];
+						        $this-&gt;bindings[$this-&gt;currentBinding]['operations'][$this-&gt;currentOperation]['binding'] = $this-&gt;currentBinding;
+						        $this-&gt;bindings[$this-&gt;currentBinding]['operations'][$this-&gt;currentOperation]['endpoint'] = isset($this-&gt;bindings[$this-&gt;currentBinding]['endpoint']) ? $this-&gt;bindings[$this-&gt;currentBinding]['endpoint'] : '';
+						    } 
+						    break;
+						case 'input':
+						    $this-&gt;opStatus = 'input';
+						    break;
+						case 'output':
+						    $this-&gt;opStatus = 'output';
+						    break;
+						case 'body':
+						    if (isset($this-&gt;bindings[$this-&gt;currentBinding]['operations'][$this-&gt;currentOperation][$this-&gt;opStatus])) {
+						        $this-&gt;bindings[$this-&gt;currentBinding]['operations'][$this-&gt;currentOperation][$this-&gt;opStatus] = array_merge($this-&gt;bindings[$this-&gt;currentBinding]['operations'][$this-&gt;currentOperation][$this-&gt;opStatus], $attrs);
+						    } else {
+						        $this-&gt;bindings[$this-&gt;currentBinding]['operations'][$this-&gt;currentOperation][$this-&gt;opStatus] = $attrs;
+						    } 
+						    break;
+					} 
+					break;
+				case 'service':
+					switch ($name) {
+					    case 'port':
+					        $this-&gt;currentPort = $attrs['name'];
+					        $this-&gt;debug('current port: ' . $this-&gt;currentPort);
+					        $this-&gt;ports[$this-&gt;currentPort]['binding'] = $this-&gt;getLocalPart($attrs['binding']);
+					
+					        break;
+					    case 'address':
+					        $this-&gt;ports[$this-&gt;currentPort]['location'] = $attrs['location'];
+					        $this-&gt;ports[$this-&gt;currentPort]['bindingType'] = $namespace;
+					        $this-&gt;bindings[ $this-&gt;ports[$this-&gt;currentPort]['binding'] ]['bindingType'] = $namespace;
+					        $this-&gt;bindings[ $this-&gt;ports[$this-&gt;currentPort]['binding'] ]['endpoint'] = $attrs['location'];
+					        break;
+					} 
+					break;
+			} 
+		// set status
+		switch ($name) {
+			case 'import':
+			    if (isset($attrs['location'])) {
+                    $this-&gt;import[$attrs['namespace']][] = array('location' =&gt; $attrs['location'], 'loaded' =&gt; false);
+                    $this-&gt;debug('parsing import ' . $attrs['namespace']. ' - ' . $attrs['location'] . ' (' . count($this-&gt;import[$attrs['namespace']]).')');
+				} else {
+                    $this-&gt;import[$attrs['namespace']][] = array('location' =&gt; '', 'loaded' =&gt; true);
+					if (! $this-&gt;getPrefixFromNamespace($attrs['namespace'])) {
+						$this-&gt;namespaces['ns'.(count($this-&gt;namespaces)+1)] = $attrs['namespace'];
+					}
+                    $this-&gt;debug('parsing import ' . $attrs['namespace']. ' - [no location] (' . count($this-&gt;import[$attrs['namespace']]).')');
+				}
+				break;
+			//wait for schema
+			//case 'types':
+			//	$this-&gt;status = 'schema';
+			//	break;
+			case 'message':
+				$this-&gt;status = 'message';
+				$this-&gt;messages[$attrs['name']] = array();
+				$this-&gt;currentMessage = $attrs['name'];
+				break;
+			case 'portType':
+				$this-&gt;status = 'portType';
+				$this-&gt;portTypes[$attrs['name']] = array();
+				$this-&gt;currentPortType = $attrs['name'];
+				break;
+			case &quot;binding&quot;:
+				if (isset($attrs['name'])) {
+				// get binding name
+					if (strpos($attrs['name'], ':')) {
+			    		$this-&gt;currentBinding = $this-&gt;getLocalPart($attrs['name']);
+					} else {
+			    		$this-&gt;currentBinding = $attrs['name'];
+					} 
+					$this-&gt;status = 'binding';
+					$this-&gt;bindings[$this-&gt;currentBinding]['portType'] = $this-&gt;getLocalPart($attrs['type']);
+					$this-&gt;debug(&quot;current binding: $this-&gt;currentBinding of portType: &quot; . $attrs['type']);
+				} 
+				break;
+			case 'service':
+				$this-&gt;serviceName = $attrs['name'];
+				$this-&gt;status = 'service';
+				$this-&gt;debug('current service: ' . $this-&gt;serviceName);
+				break;
+			case 'definitions':
+				foreach ($attrs as $name =&gt; $value) {
+					$this-&gt;wsdl_info[$name] = $value;
+				} 
+				break;
+			} 
+		} 
+	} 
+
+	/**
+	* end-element handler
+	* 
+	* @param string $parser XML parser object
+	* @param string $name element name
+	* @access private 
+	*/
+	function end_element($parser, $name){ 
+		// unset schema status
+		if (/*ereg('types$', $name) ||*/ ereg('schema$', $name)) {
+			$this-&gt;status = &quot;&quot;;
+            $this-&gt;appendDebug($this-&gt;currentSchema-&gt;getDebug());
+            $this-&gt;currentSchema-&gt;clearDebug();
+			$this-&gt;schemas[$this-&gt;currentSchema-&gt;schemaTargetNamespace][] = $this-&gt;currentSchema;
+        	$this-&gt;debug('Parsing WSDL schema done');
+		} 
+		if ($this-&gt;status == 'schema') {
+			$this-&gt;currentSchema-&gt;schemaEndElement($parser, $name);
+		} else {
+			// bring depth down a notch
+			$this-&gt;depth--;
+		} 
+		// end documentation
+		if ($this-&gt;documentation) {
+			//TODO: track the node to which documentation should be assigned; it can be a part, message, etc.
+			//$this-&gt;portTypes[$this-&gt;currentPortType][$this-&gt;currentPortOperation]['documentation'] = $this-&gt;documentation;
+			$this-&gt;documentation = false;
+		} 
+	} 
+
+	/**
+	 * element content handler
+	 * 
+	 * @param string $parser XML parser object
+	 * @param string $data element content
+	 * @access private 
+	 */
+	function character_data($parser, $data)
+	{
+		$pos = isset($this-&gt;depth_array[$this-&gt;depth]) ? $this-&gt;depth_array[$this-&gt;depth] : 0;
+		if (isset($this-&gt;message[$pos]['cdata'])) {
+			$this-&gt;message[$pos]['cdata'] .= $data;
+		} 
+		if ($this-&gt;documentation) {
+			$this-&gt;documentation .= $data;
+		} 
+	} 
+	
+	function getBindingData($binding)
+	{
+		if (is_array($this-&gt;bindings[$binding])) {
+			return $this-&gt;bindings[$binding];
+		} 
+	}
+	
+	/**
+	 * returns an assoc array of operation names =&gt; operation data
+	 * 
+	 * @param string $bindingType eg: soap, smtp, dime (only soap is currently supported)
+	 * @return array 
+	 * @access public 
+	 */
+	function getOperations($bindingType = 'soap')
+	{
+		$ops = array();
+		if ($bindingType == 'soap') {
+			$bindingType = '<A HREF="http://schemas.xmlsoap.org/wsdl/soap/">http://schemas.xmlsoap.org/wsdl/soap/</A>';
+		}
+		// loop thru ports
+		foreach($this-&gt;ports as $port =&gt; $portData) {
+			// binding type of port matches parameter
+			if ($portData['bindingType'] == $bindingType) {
+				//$this-&gt;debug(&quot;getOperations for port $port&quot;);
+				//$this-&gt;debug(&quot;port data: &quot; . $this-&gt;varDump($portData));
+				//$this-&gt;debug(&quot;bindings: &quot; . $this-&gt;varDump($this-&gt;bindings[ $portData['binding'] ]));
+				// merge bindings
+				if (isset($this-&gt;bindings[ $portData['binding'] ]['operations'])) {
+					$ops = array_merge ($ops, $this-&gt;bindings[ $portData['binding'] ]['operations']);
+				}
+			}
+		} 
+		return $ops;
+	} 
+	
+	/**
+	 * returns an associative array of data necessary for calling an operation
+	 * 
+	 * @param string $operation , name of operation
+	 * @param string $bindingType , type of binding eg: soap
+	 * @return array 
+	 * @access public 
+	 */
+	function getOperationData($operation, $bindingType = 'soap')
+	{
+		if ($bindingType == 'soap') {
+			$bindingType = '<A HREF="http://schemas.xmlsoap.org/wsdl/soap/">http://schemas.xmlsoap.org/wsdl/soap/</A>';
+		}
+		// loop thru ports
+		foreach($this-&gt;ports as $port =&gt; $portData) {
+			// binding type of port matches parameter
+			if ($portData['bindingType'] == $bindingType) {
+				// get binding
+				//foreach($this-&gt;bindings[ $portData['binding'] ]['operations'] as $bOperation =&gt; $opData) {
+				foreach(array_keys($this-&gt;bindings[ $portData['binding'] ]['operations']) as $bOperation) {
+					// note that we could/should also check the namespace here
+					if ($operation == $bOperation) {
+						$opData = $this-&gt;bindings[ $portData['binding'] ]['operations'][$operation];
+					    return $opData;
+					} 
+				} 
+			}
+		} 
+	}
+	
+	/**
+	 * returns an associative array of data necessary for calling an operation
+	 * 
+	 * @param string $soapAction soapAction for operation
+	 * @param string $bindingType type of binding eg: soap
+	 * @return array 
+	 * @access public 
+	 */
+	function getOperationDataForSoapAction($soapAction, $bindingType = 'soap') {
+		if ($bindingType == 'soap') {
+			$bindingType = '<A HREF="http://schemas.xmlsoap.org/wsdl/soap/">http://schemas.xmlsoap.org/wsdl/soap/</A>';
+		}
+		// loop thru ports
+		foreach($this-&gt;ports as $port =&gt; $portData) {
+			// binding type of port matches parameter
+			if ($portData['bindingType'] == $bindingType) {
+				// loop through operations for the binding
+				foreach ($this-&gt;bindings[ $portData['binding'] ]['operations'] as $bOperation =&gt; $opData) {
+					if ($opData['soapAction'] == $soapAction) {
+					    return $opData;
+					} 
+				} 
+			}
+		} 
+	}
+	
+	/**
+    * returns an array of information about a given type
+    * returns false if no type exists by the given name
+    *
+	*	 typeDef = array(
+	*	 'elements' =&gt; array(), // refs to elements array
+	*	'restrictionBase' =&gt; '',
+	*	'phpType' =&gt; '',
+	*	'order' =&gt; '(sequence|all)',
+	*	'attrs' =&gt; array() // refs to attributes array
+	*	)
+    *
+    * @param $type string the type
+    * @param $ns string namespace (not prefix) of the type
+    * @return mixed
+    * @access public
+    * @see xmlschema
+    */
+	function getTypeDef($type, $ns) {
+		$this-&gt;debug(&quot;in getTypeDef: type=$type, ns=$ns&quot;);
+		if ((! $ns) &amp;&amp; isset($this-&gt;namespaces['tns'])) {
+			$ns = $this-&gt;namespaces['tns'];
+			$this-&gt;debug(&quot;in getTypeDef: type namespace forced to $ns&quot;);
+		}
+		if (isset($this-&gt;schemas[$ns])) {
+			$this-&gt;debug(&quot;in getTypeDef: have schema for namespace $ns&quot;);
+			for ($i = 0; $i &lt; count($this-&gt;schemas[$ns]); $i++) {
+				$xs = &amp;$this-&gt;schemas[$ns][$i];
+				$t = $xs-&gt;getTypeDef($type);
+				$this-&gt;appendDebug($xs-&gt;getDebug());
+				$xs-&gt;clearDebug();
+				if ($t) {
+					if (!isset($t['phpType'])) {
+						// get info for type to tack onto the element
+						$uqType = substr($t['type'], strrpos($t['type'], ':') + 1);
+						$ns = substr($t['type'], 0, strrpos($t['type'], ':'));
+						$etype = $this-&gt;getTypeDef($uqType, $ns);
+						if ($etype) {
+							$this-&gt;debug(&quot;found type for [element] $type:&quot;);
+							$this-&gt;debug($this-&gt;varDump($etype));
+							if (isset($etype['phpType'])) {
+								$t['phpType'] = $etype['phpType'];
+							}
+							if (isset($etype['elements'])) {
+								$t['elements'] = $etype['elements'];
+							}
+							if (isset($etype['attrs'])) {
+								$t['attrs'] = $etype['attrs'];
+							}
+						}
+					}
+					return $t;
+				}
+			}
+		} else {
+			$this-&gt;debug(&quot;in getTypeDef: do not have schema for namespace $ns&quot;);
+		}
+		return false;
+	}
+
+    /**
+    * prints html description of services
+    *
+    * @access private
+    */
+    function webDescription(){
+    	global $HTTP_SERVER_VARS;
+
+		if (isset($_SERVER)) {
+			$PHP_SELF = $_SERVER['PHP_SELF'];
+		} elseif (isset($HTTP_SERVER_VARS)) {
+			$PHP_SELF = $HTTP_SERVER_VARS['PHP_SELF'];
+		} else {
+			$this-&gt;setError(&quot;Neither _SERVER nor HTTP_SERVER_VARS is available&quot;);
+		}
+
+		$b = '
+		&lt;html&gt;&lt;head&gt;&lt;title&gt;NuSOAP: '.$this-&gt;serviceName.'&lt;/title&gt;
+		&lt;style type=&quot;text/css&quot;&gt;
+		    body    { font-family: arial; color: #000000; background-color: #ffffff; margin: 0px 0px 0px 0px; }
+		    p       { font-family: arial; color: #000000; margin-top: 0px; margin-bottom: 12px; }
+		    pre { background-color: silver; padding: 5px; font-family: Courier New; font-size: x-small; color: #000000;}
+		    ul      { margin-top: 10px; margin-left: 20px; }
+		    li      { list-style-type: none; margin-top: 10px; color: #000000; }
+		    .content{
+			margin-left: 0px; padding-bottom: 2em; }
+		    .nav {
+			padding-top: 10px; padding-bottom: 10px; padding-left: 15px; font-size: .70em;
+			margin-top: 10px; margin-left: 0px; color: #000000;
+			background-color: #ccccff; width: 20%; margin-left: 20px; margin-top: 20px; }
+		    .title {
+			font-family: arial; font-size: 26px; color: #ffffff;
+			background-color: #999999; width: 105%; margin-left: 0px;
+			padding-top: 10px; padding-bottom: 10px; padding-left: 15px;}
+		    .hidden {
+			position: absolute; visibility: hidden; z-index: 200; left: 250px; top: 100px;
+			font-family: arial; overflow: hidden; width: 600;
+			padding: 20px; font-size: 10px; background-color: #999999;
+			layer-background-color:#FFFFFF; }
+		    a,a:active  { color: charcoal; font-weight: bold; }
+		    a:visited   { color: #666666; font-weight: bold; }
+		    a:hover     { color: cc3300; font-weight: bold; }
+		&lt;/style&gt;
+		&lt;script language=&quot;JavaScript&quot; type=&quot;text/javascript&quot;&gt;
+		&lt;!--
+		// POP-UP CAPTIONS...
+		function lib_bwcheck(){ //Browsercheck (needed)
+		    this.ver=navigator.appVersion
+		    this.agent=navigator.userAgent
+		    this.dom=document.getElementById?1:0
+		    this.opera5=this.agent.indexOf(&quot;Opera 5&quot;)&gt;-1
+		    this.ie5=(this.ver.indexOf(&quot;MSIE 5&quot;)&gt;-1 &amp;&amp; this.dom &amp;&amp; !this.opera5)?1:0;
+		    this.ie6=(this.ver.indexOf(&quot;MSIE 6&quot;)&gt;-1 &amp;&amp; this.dom &amp;&amp; !this.opera5)?1:0;
+		    this.ie4=(document.all &amp;&amp; !this.dom &amp;&amp; !this.opera5)?1:0;
+		    this.ie=this.ie4||this.ie5||this.ie6
+		    this.mac=this.agent.indexOf(&quot;Mac&quot;)&gt;-1
+		    this.ns6=(this.dom &amp;&amp; parseInt(this.ver) &gt;= 5) ?1:0;
+		    this.ns4=(document.layers &amp;&amp; !this.dom)?1:0;
+		    this.bw=(this.ie6 || this.ie5 || this.ie4 || this.ns4 || this.ns6 || this.opera5)
+		    return this
+		}
+		var bw = new lib_bwcheck()
+		//Makes crossbrowser object.
+		function makeObj(obj){
+		    this.evnt=bw.dom? document.getElementById(obj):bw.ie4?document.all[obj]:bw.ns4?document.layers[obj]:0;
+		    if(!this.evnt) return false
+		    this.css=bw.dom||bw.ie4?this.evnt.style:bw.ns4?this.evnt:0;
+		    this.wref=bw.dom||bw.ie4?this.evnt:bw.ns4?this.css.document:0;
+		    this.writeIt=b_writeIt;
+		    return this
+		}
+		// A unit of measure that will be added when setting the position of a layer.
+		//var px = bw.ns4||window.opera?&quot;&quot;:&quot;px&quot;;
+		function b_writeIt(text){
+		    if (bw.ns4){this.wref.write(text);this.wref.close()}
+		    else this.wref.innerHTML = text
+		}
+		//Shows the messages
+		var oDesc;
+		function popup(divid){
+		    if(oDesc = new makeObj(divid)){
+			oDesc.css.visibility = &quot;visible&quot;
+		    }
+		}
+		function popout(){ // Hides message
+		    if(oDesc) oDesc.css.visibility = &quot;hidden&quot;
+		}
+		//--&gt;
+		&lt;/script&gt;
+		&lt;/head&gt;
+		&lt;body&gt;
+		&lt;div class=content&gt;
+			&lt;br&gt;&lt;br&gt;
+			&lt;div class=title&gt;'.$this-&gt;serviceName.'&lt;/div&gt;
+			&lt;div class=nav&gt;
+				&lt;p&gt;View the &lt;a href=&quot;'.$PHP_SELF.'?wsdl&quot;&gt;WSDL&lt;/a&gt; for the service.
+				Click on an operation name to view it&apos;s details.&lt;/p&gt;
+				&lt;ul&gt;';
+				foreach($this-&gt;getOperations() as $op =&gt; $data){
+				    $b .= &quot;&lt;li&gt;&lt;a href='#' onclick=\&quot;popout();popup('$op')\&quot;&gt;$op&lt;/a&gt;&lt;/li&gt;&quot;;
+				    // create hidden div
+				    $b .= &quot;&lt;div id='$op' class='hidden'&gt;
+				    &lt;a href='#' onclick='popout()'&gt;&lt;font color='#ffffff'&gt;Close&lt;/font&gt;&lt;/a&gt;&lt;br&gt;&lt;br&gt;&quot;;
+				    foreach($data as $donnie =&gt; $marie){ // loop through opdata
+						if($donnie == 'input' || $donnie == 'output'){ // show input/output data
+						    $b .= &quot;&lt;font color='white'&gt;&quot;.ucfirst($donnie).':&lt;/font&gt;&lt;br&gt;';
+						    foreach($marie as $captain =&gt; $tenille){ // loop through data
+								if($captain == 'parts'){ // loop thru parts
+								    $b .= &quot;&nbsp;&nbsp;$captain:&lt;br&gt;&quot;;
+					                //if(is_array($tenille)){
+								    	foreach($tenille as $joanie =&gt; $chachi){
+											$b .= &quot;&nbsp;&nbsp;&nbsp;&nbsp;$joanie: $chachi&lt;br&gt;&quot;;
+								    	}
+					        		//}
+								} else {
+								    $b .= &quot;&nbsp;&nbsp;$captain: $tenille&lt;br&gt;&quot;;
+								}
+						    }
+						} else {
+						    $b .= &quot;&lt;font color='white'&gt;&quot;.ucfirst($donnie).&quot;:&lt;/font&gt; $marie&lt;br&gt;&quot;;
+						}
+				    }
+					$b .= '&lt;/div&gt;';
+				}
+				$b .= '
+				&lt;ul&gt;
+			&lt;/div&gt;
+		&lt;/div&gt;&lt;/body&gt;&lt;/html&gt;';
+		return $b;
+    }
+
+	/**
+	* serialize the parsed wsdl
+	*
+	* @param mixed $debug whether to put debug=1 in endpoint URL
+	* @return string serialization of WSDL
+	* @access public 
+	*/
+	function serialize($debug = 0)
+	{
+		$xml = '&lt;?xml version=&quot;1.0&quot; encoding=&quot;ISO-8859-1&quot;?&gt;';
+		$xml .= &quot;\n&lt;definitions&quot;;
+		foreach($this-&gt;namespaces as $k =&gt; $v) {
+			$xml .= &quot; xmlns:$k=\&quot;$v\&quot;&quot;;
+		} 
+		// 10.9.02 - add poulter fix for wsdl and tns declarations
+		if (isset($this-&gt;namespaces['wsdl'])) {
+			$xml .= &quot; xmlns=\&quot;&quot; . $this-&gt;namespaces['wsdl'] . &quot;\&quot;&quot;;
+		} 
+		if (isset($this-&gt;namespaces['tns'])) {
+			$xml .= &quot; targetNamespace=\&quot;&quot; . $this-&gt;namespaces['tns'] . &quot;\&quot;&quot;;
+		} 
+		$xml .= '&gt;'; 
+		// imports
+		if (sizeof($this-&gt;import) &gt; 0) {
+			foreach($this-&gt;import as $ns =&gt; $list) {
+				foreach ($list as $ii) {
+					if ($ii['location'] != '') {
+						$xml .= '&lt;import location=&quot;' . $ii['location'] . '&quot; namespace=&quot;' . $ns . '&quot; /&gt;';
+					} else {
+						$xml .= '&lt;import namespace=&quot;' . $ns . '&quot; /&gt;';
+					}
+				}
+			} 
+		} 
+		// types
+		if (count($this-&gt;schemas)&gt;=1) {
+			$xml .= &quot;\n&lt;types&gt;&quot;;
+			foreach ($this-&gt;schemas as $ns =&gt; $list) {
+				foreach ($list as $xs) {
+					$xml .= $xs-&gt;serializeSchema();
+				}
+			}
+			$xml .= '&lt;/types&gt;';
+		} 
+		// messages
+		if (count($this-&gt;messages) &gt;= 1) {
+			foreach($this-&gt;messages as $msgName =&gt; $msgParts) {
+				$xml .= &quot;\n&lt;message name=\&quot;&quot; . $msgName . '&quot;&gt;';
+				if(is_array($msgParts)){
+					foreach($msgParts as $partName =&gt; $partType) {
+						// print 'serializing '.$partType.', sv: '.$this-&gt;XMLSchemaVersion.'&lt;br&gt;';
+						if (strpos($partType, ':')) {
+						    $typePrefix = $this-&gt;getPrefixFromNamespace($this-&gt;getPrefix($partType));
+						} elseif (isset($this-&gt;typemap[$this-&gt;namespaces['xsd']][$partType])) {
+						    // print 'checking typemap: '.$this-&gt;XMLSchemaVersion.'&lt;br&gt;';
+						    $typePrefix = 'xsd';
+						} else {
+						    foreach($this-&gt;typemap as $ns =&gt; $types) {
+						        if (isset($types[$partType])) {
+						            $typePrefix = $this-&gt;getPrefixFromNamespace($ns);
+						        } 
+						    } 
+						    if (!isset($typePrefix)) {
+						        die(&quot;$partType has no namespace!&quot;);
+						    } 
+						}
+						$ns = $this-&gt;getNamespaceFromPrefix($typePrefix);
+						$typeDef = $this-&gt;getTypeDef($this-&gt;getLocalPart($partType), $ns);
+						if ($typeDef['typeClass'] == 'element') {
+							$elementortype = 'element';
+						} else {
+							$elementortype = 'type';
+						}
+						$xml .= '&lt;part name=&quot;' . $partName . '&quot; ' . $elementortype . '=&quot;' . $typePrefix . ':' . $this-&gt;getLocalPart($partType) . '&quot; /&gt;';
+					}
+				}
+				$xml .= '&lt;/message&gt;';
+			} 
+		} 
+		// bindings &amp; porttypes
+		if (count($this-&gt;bindings) &gt;= 1) {
+			$binding_xml = '';
+			$portType_xml = '';
+			foreach($this-&gt;bindings as $bindingName =&gt; $attrs) {
+				$binding_xml .= &quot;\n&lt;binding name=\&quot;&quot; . $bindingName . '&quot; type=&quot;tns:' . $attrs['portType'] . '&quot;&gt;';
+				$binding_xml .= '&lt;soap:binding style=&quot;' . $attrs['style'] . '&quot; transport=&quot;' . $attrs['transport'] . '&quot;/&gt;';
+				$portType_xml .= &quot;\n&lt;portType name=\&quot;&quot; . $attrs['portType'] . '&quot;&gt;';
+				foreach($attrs['operations'] as $opName =&gt; $opParts) {
+					$binding_xml .= '&lt;operation name=&quot;' . $opName . '&quot;&gt;';
+					$binding_xml .= '&lt;soap:operation soapAction=&quot;' . $opParts['soapAction'] . '&quot; style=&quot;'. $opParts['style'] . '&quot;/&gt;';
+					if (isset($opParts['input']['encodingStyle']) &amp;&amp; $opParts['input']['encodingStyle'] != '') {
+						$enc_style = ' encodingStyle=&quot;' . $opParts['input']['encodingStyle'] . '&quot;';
+					} else {
+						$enc_style = '';
+					}
+					$binding_xml .= '&lt;input&gt;&lt;soap:body use=&quot;' . $opParts['input']['use'] . '&quot; namespace=&quot;' . $opParts['input']['namespace'] . '&quot;' . $enc_style . '/&gt;&lt;/input&gt;';
+					if (isset($opParts['output']['encodingStyle']) &amp;&amp; $opParts['output']['encodingStyle'] != '') {
+						$enc_style = ' encodingStyle=&quot;' . $opParts['output']['encodingStyle'] . '&quot;';
+					} else {
+						$enc_style = '';
+					}
+					$binding_xml .= '&lt;output&gt;&lt;soap:body use=&quot;' . $opParts['output']['use'] . '&quot; namespace=&quot;' . $opParts['output']['namespace'] . '&quot;' . $enc_style . '/&gt;&lt;/output&gt;';
+					$binding_xml .= '&lt;/operation&gt;';
+					$portType_xml .= '&lt;operation name=&quot;' . $opParts['name'] . '&quot;';
+					if (isset($opParts['parameterOrder'])) {
+					    $portType_xml .= ' parameterOrder=&quot;' . $opParts['parameterOrder'] . '&quot;';
+					} 
+					$portType_xml .= '&gt;';
+					if(isset($opParts['documentation']) &amp;&amp; $opParts['documentation'] != '') {
+						$portType_xml .= '&lt;documentation&gt;' . htmlspecialchars($opParts['documentation']) . '&lt;/documentation&gt;';
+					}
+					$portType_xml .= '&lt;input message=&quot;tns:' . $opParts['input']['message'] . '&quot;/&gt;';
+					$portType_xml .= '&lt;output message=&quot;tns:' . $opParts['output']['message'] . '&quot;/&gt;';
+					$portType_xml .= '&lt;/operation&gt;';
+				} 
+				$portType_xml .= '&lt;/portType&gt;';
+				$binding_xml .= '&lt;/binding&gt;';
+			} 
+			$xml .= $portType_xml . $binding_xml;
+		} 
+		// services
+		$xml .= &quot;\n&lt;service name=\&quot;&quot; . $this-&gt;serviceName . '&quot;&gt;';
+		if (count($this-&gt;ports) &gt;= 1) {
+			foreach($this-&gt;ports as $pName =&gt; $attrs) {
+				$xml .= '&lt;port name=&quot;' . $pName . '&quot; binding=&quot;tns:' . $attrs['binding'] . '&quot;&gt;';
+				$xml .= '&lt;soap:address location=&quot;' . $attrs['location'] . ($debug ? '?debug=1' : '') . '&quot;/&gt;';
+				$xml .= '&lt;/port&gt;';
+			} 
+		} 
+		$xml .= '&lt;/service&gt;';
+		return $xml . &quot;\n&lt;/definitions&gt;&quot;;
+	} 
+	
+	/**
+	 * serialize PHP values according to a WSDL message definition
+	 *
+	 * TODO
+	 * - multi-ref serialization
+	 * - validate PHP values against type definitions, return errors if invalid
+	 * 
+	 * @param string $operation operation name
+	 * @param string $direction (input|output)
+	 * @param mixed $parameters parameter value(s)
+	 * @return mixed parameters serialized as XML or false on error (e.g. operation not found)
+	 * @access public
+	 */
+	function serializeRPCParameters($operation, $direction, $parameters)
+	{
+		$this-&gt;debug(&quot;in serializeRPCParameters: operation=$operation, direction=$direction, XMLSchemaVersion=$this-&gt;XMLSchemaVersion&quot;); 
+		$this-&gt;appendDebug('parameters=' . $this-&gt;varDump($parameters));
+		
+		if ($direction != 'input' &amp;&amp; $direction != 'output') {
+			$this-&gt;debug('The value of the \$direction argument needs to be either &quot;input&quot; or &quot;output&quot;');
+			$this-&gt;setError('The value of the \$direction argument needs to be either &quot;input&quot; or &quot;output&quot;');
+			return false;
+		} 
+		if (!$opData = $this-&gt;getOperationData($operation)) {
+			$this-&gt;debug('Unable to retrieve WSDL data for operation: ' . $operation);
+			$this-&gt;setError('Unable to retrieve WSDL data for operation: ' . $operation);
+			return false;
+		}
+		$this-&gt;debug('opData:');
+		$this-&gt;appendDebug($this-&gt;varDump($opData));
+
+		// Get encoding style for output and set to current
+		$encodingStyle = '<A HREF="http://schemas.xmlsoap.org/soap/encoding/">http://schemas.xmlsoap.org/soap/encoding/</A>';
+		if(($direction == 'input') &amp;&amp; isset($opData['output']['encodingStyle']) &amp;&amp; ($opData['output']['encodingStyle'] != $encodingStyle)) {
+			$encodingStyle = $opData['output']['encodingStyle'];
+			$enc_style = $encodingStyle;
+		}
+
+		// set input params
+		$xml = '';
+		if (isset($opData[$direction]['parts']) &amp;&amp; sizeof($opData[$direction]['parts']) &gt; 0) {
+			
+			$use = $opData[$direction]['use'];
+			$this-&gt;debug('have ' . count($opData[$direction]['parts']) . ' part(s) to serialize');
+			if (is_array($parameters)) {
+				$parametersArrayType = $this-&gt;isArraySimpleOrStruct($parameters);
+				$this-&gt;debug('have ' . count($parameters) . ' parameter(s) provided as ' . $parametersArrayType . ' to serialize');
+				foreach($opData[$direction]['parts'] as $name =&gt; $type) {
+					$this-&gt;debug('serializing part &quot;'.$name.'&quot; of type &quot;'.$type.'&quot;');
+					// Track encoding style
+					if (isset($opData[$direction]['encodingStyle']) &amp;&amp; $encodingStyle != $opData[$direction]['encodingStyle']) {
+						$encodingStyle = $opData[$direction]['encodingStyle'];			
+						$enc_style = $encodingStyle;
+					} else {
+						$enc_style = false;
+					}
+					// NOTE: add error handling here
+					// if serializeType returns false, then catch global error and fault
+					if ($parametersArrayType == 'arraySimple') {
+						$p = array_shift($parameters);
+						$this-&gt;debug('calling serializeType w/indexed param');
+						$xml .= $this-&gt;serializeType($name, $type, $p, $use, $enc_style);
+					} elseif (isset($parameters[$name])) {
+						$this-&gt;debug('calling serializeType w/named param');
+						$xml .= $this-&gt;serializeType($name, $type, $parameters[$name], $use, $enc_style);
+					} else {
+						// TODO: only send nillable
+						$this-&gt;debug('calling serializeType w/null param');
+						$xml .= $this-&gt;serializeType($name, $type, null, $use, $enc_style);
+					}
+				}
+			} else {
+				$this-&gt;debug('no parameters passed.');
+			}
+		}
+		$this-&gt;debug(&quot;serializeRPCParameters returning: $xml&quot;);
+		return $xml;
+	} 
+	
+	/**
+	 * serialize a PHP value according to a WSDL message definition
+	 * 
+	 * TODO
+	 * - multi-ref serialization
+	 * - validate PHP values against type definitions, return errors if invalid
+	 * 
+	 * @param string $ type name
+	 * @param mixed $ param value
+	 * @return mixed new param or false if initial value didn't validate
+	 * @access public
+	 * @deprecated
+	 */
+	function serializeParameters($operation, $direction, $parameters)
+	{
+		$this-&gt;debug(&quot;in serializeParameters: operation=$operation, direction=$direction, XMLSchemaVersion=$this-&gt;XMLSchemaVersion&quot;); 
+		$this-&gt;appendDebug('parameters=' . $this-&gt;varDump($parameters));
+		
+		if ($direction != 'input' &amp;&amp; $direction != 'output') {
+			$this-&gt;debug('The value of the \$direction argument needs to be either &quot;input&quot; or &quot;output&quot;');
+			$this-&gt;setError('The value of the \$direction argument needs to be either &quot;input&quot; or &quot;output&quot;');
+			return false;
+		} 
+		if (!$opData = $this-&gt;getOperationData($operation)) {
+			$this-&gt;debug('Unable to retrieve WSDL data for operation: ' . $operation);
+			$this-&gt;setError('Unable to retrieve WSDL data for operation: ' . $operation);
+			return false;
+		}
+		$this-&gt;debug('opData:');
+		$this-&gt;appendDebug($this-&gt;varDump($opData));
+		
+		// Get encoding style for output and set to current
+		$encodingStyle = '<A HREF="http://schemas.xmlsoap.org/soap/encoding/">http://schemas.xmlsoap.org/soap/encoding/</A>';
+		if(($direction == 'input') &amp;&amp; isset($opData['output']['encodingStyle']) &amp;&amp; ($opData['output']['encodingStyle'] != $encodingStyle)) {
+			$encodingStyle = $opData['output']['encodingStyle'];
+			$enc_style = $encodingStyle;
+		}
+		
+		// set input params
+		$xml = '';
+		if (isset($opData[$direction]['parts']) &amp;&amp; sizeof($opData[$direction]['parts']) &gt; 0) {
+			
+			$use = $opData[$direction]['use'];
+			$this-&gt;debug(&quot;use=$use&quot;);
+			$this-&gt;debug('got ' . count($opData[$direction]['parts']) . ' part(s)');
+			if (is_array($parameters)) {
+				$parametersArrayType = $this-&gt;isArraySimpleOrStruct($parameters);
+				$this-&gt;debug('have ' . $parametersArrayType . ' parameters');
+				foreach($opData[$direction]['parts'] as $name =&gt; $type) {
+					$this-&gt;debug('serializing part &quot;'.$name.'&quot; of type &quot;'.$type.'&quot;');
+					// Track encoding style
+					if(isset($opData[$direction]['encodingStyle']) &amp;&amp; $encodingStyle != $opData[$direction]['encodingStyle']) {
+						$encodingStyle = $opData[$direction]['encodingStyle'];			
+						$enc_style = $encodingStyle;
+					} else {
+						$enc_style = false;
+					}
+					// NOTE: add error handling here
+					// if serializeType returns false, then catch global error and fault
+					if ($parametersArrayType == 'arraySimple') {
+						$p = array_shift($parameters);
+						$this-&gt;debug('calling serializeType w/indexed param');
+						$xml .= $this-&gt;serializeType($name, $type, $p, $use, $enc_style);
+					} elseif (isset($parameters[$name])) {
+						$this-&gt;debug('calling serializeType w/named param');
+						$xml .= $this-&gt;serializeType($name, $type, $parameters[$name], $use, $enc_style);
+					} else {
+						// TODO: only send nillable
+						$this-&gt;debug('calling serializeType w/null param');
+						$xml .= $this-&gt;serializeType($name, $type, null, $use, $enc_style);
+					}
+				}
+			} else {
+				$this-&gt;debug('no parameters passed.');
+			}
+		}
+		$this-&gt;debug(&quot;serializeParameters returning: $xml&quot;);
+		return $xml;
+	} 
+	
+	/**
+	 * serializes a PHP value according a given type definition
+	 * 
+	 * @param string $name name of value (part or element)
+	 * @param string $type XML schema type of value (type or element)
+	 * @param mixed $value a native PHP value (parameter value)
+	 * @param string $use use for part (encoded|literal)
+	 * @param string $encodingStyle SOAP encoding style for the value (if different than the enclosing style)
+	 * @param boolean $unqualified a kludge for what should be XML namespace form handling
+	 * @return string value serialized as an XML string
+	 * @access private
+	 */
+	function serializeType($name, $type, $value, $use='encoded', $encodingStyle=false, $unqualified=false)
+	{
+		$this-&gt;debug(&quot;in serializeType: name=$name, type=$type, use=$use, encodingStyle=$encodingStyle, unqualified=&quot; . ($unqualified ? &quot;unqualified&quot; : &quot;qualified&quot;));
+		$this-&gt;appendDebug(&quot;value=&quot; . $this-&gt;varDump($value));
+		if($use == 'encoded' &amp;&amp; $encodingStyle) {
+			$encodingStyle = ' SOAP-ENV:encodingStyle=&quot;' . $encodingStyle . '&quot;';
+		}
+
+		// if a soapval has been supplied, let its type override the WSDL
+    	if (is_object($value) &amp;&amp; get_class($value) == 'soapval') {
+    		if ($value-&gt;type_ns) {
+    			$type = $value-&gt;type_ns . ':' . $value-&gt;type;
+		    	$forceType = true;
+		    	$this-&gt;debug(&quot;in serializeType: soapval overrides type to $type&quot;);
+    		} elseif ($value-&gt;type) {
+	    		$type = $value-&gt;type;
+		    	$forceType = true;
+		    	$this-&gt;debug(&quot;in serializeType: soapval overrides type to $type&quot;);
+	    	} else {
+	    		$forceType = false;
+		    	$this-&gt;debug(&quot;in serializeType: soapval does not override type&quot;);
+	    	}
+	    	$attrs = $value-&gt;attributes;
+	    	$value = $value-&gt;value;
+	    	$this-&gt;debug(&quot;in serializeType: soapval overrides value to $value&quot;);
+	    	if ($attrs) {
+	    		if (!is_array($value)) {
+	    			$value['!'] = $value;
+	    		}
+	    		foreach ($attrs as $n =&gt; $v) {
+	    			$value['!' . $n] = $v;
+	    		}
+		    	$this-&gt;debug(&quot;in serializeType: soapval provides attributes&quot;);
+		    }
+        } else {
+        	$forceType = false;
+        }
+
+		$xml = '';
+		if (strpos($type, ':')) {
+			$uqType = substr($type, strrpos($type, ':') + 1);
+			$ns = substr($type, 0, strrpos($type, ':'));
+			$this-&gt;debug(&quot;in serializeType: got a prefixed type: $uqType, $ns&quot;);
+			if ($this-&gt;getNamespaceFromPrefix($ns)) {
+				$ns = $this-&gt;getNamespaceFromPrefix($ns);
+				$this-&gt;debug(&quot;in serializeType: expanded prefixed type: $uqType, $ns&quot;);
+			}
+
+			if($ns == $this-&gt;XMLSchemaVersion || $ns == '<A HREF="http://schemas.xmlsoap.org/soap/encoding/">http://schemas.xmlsoap.org/soap/encoding/</A>'){
+				$this-&gt;debug('in serializeType: type namespace indicates XML Schema or SOAP Encoding type');
+				if ($unqualified  &amp;&amp; $use == 'literal') {
+					$elementNS = &quot; xmlns=\&quot;\&quot;&quot;;
+				} else {
+					$elementNS = '';
+				}
+				if (is_null($value)) {
+					if ($use == 'literal') {
+						// TODO: depends on minOccurs
+						$xml = &quot;&lt;$name$elementNS/&gt;&quot;;
+					} else {
+						// TODO: depends on nillable, which should be checked before calling this method
+						$xml = &quot;&lt;$name$elementNS xsi:nil=\&quot;true\&quot; xsi:type=\&quot;&quot; . $this-&gt;getPrefixFromNamespace($ns) . &quot;:$uqType\&quot;/&gt;&quot;;
+					}
+					$this-&gt;debug(&quot;in serializeType: returning: $xml&quot;);
+					return $xml;
+				}
+		    	if ($uqType == 'boolean') {
+		    		if ((is_string($value) &amp;&amp; $value == 'false') || (! $value)) {
+						$value = 'false';
+					} else {
+						$value = 'true';
+					}
+				} 
+				if ($uqType == 'string' &amp;&amp; gettype($value) == 'string') {
+					$value = $this-&gt;expandEntities($value);
+				}
+				if (($uqType == 'long' || $uqType == 'unsignedLong') &amp;&amp; gettype($value) == 'double') {
+					$value = sprintf(&quot;%.0lf&quot;, $value);
+				}
+				// it's a scalar
+				// TODO: what about null/nil values?
+				// check type isn't a custom type extending xmlschema namespace
+				if (!$this-&gt;getTypeDef($uqType, $ns)) {
+					if ($use == 'literal') {
+						if ($forceType) {
+							$xml = &quot;&lt;$name$elementNS xsi:type=\&quot;&quot; . $this-&gt;getPrefixFromNamespace($ns) . &quot;:$uqType\&quot;&gt;$value&lt;/$name&gt;&quot;;
+						} else {
+							$xml = &quot;&lt;$name$elementNS&gt;$value&lt;/$name&gt;&quot;;
+						}
+					} else {
+						$xml = &quot;&lt;$name$elementNS xsi:type=\&quot;&quot; . $this-&gt;getPrefixFromNamespace($ns) . &quot;:$uqType\&quot;$encodingStyle&gt;$value&lt;/$name&gt;&quot;;
+					}
+					$this-&gt;debug(&quot;in serializeType: returning: $xml&quot;);
+					return $xml;
+				}
+				$this-&gt;debug('custom type extends XML Schema or SOAP Encoding namespace (yuck)');
+			} else if ($ns == '<A HREF="http://xml.apache.org/xml-soap">http://xml.apache.org/xml-soap</A>') {
+				$this-&gt;debug('in serializeType: appears to be Apache SOAP type');
+				if ($uqType == 'Map') {
+					$tt_prefix = $this-&gt;getPrefixFromNamespace('<A HREF="http://xml.apache.org/xml-soap">http://xml.apache.org/xml-soap</A>');
+					if (! $tt_prefix) {
+						$this-&gt;debug('in serializeType: Add namespace for Apache SOAP type');
+						$tt_prefix = 'ns' . rand(1000, 9999);
+						$this-&gt;namespaces[$tt_prefix] = '<A HREF="http://xml.apache.org/xml-soap">http://xml.apache.org/xml-soap</A>';
+						// force this to be added to usedNamespaces
+						$tt_prefix = $this-&gt;getPrefixFromNamespace('<A HREF="http://xml.apache.org/xml-soap">http://xml.apache.org/xml-soap</A>');
+					}
+					$contents = '';
+					foreach($value as $k =&gt; $v) {
+						$this-&gt;debug(&quot;serializing map element: key $k, value $v&quot;);
+						$contents .= '&lt;item&gt;';
+						$contents .= $this-&gt;serialize_val($k,'key',false,false,false,false,$use);
+						$contents .= $this-&gt;serialize_val($v,'value',false,false,false,false,$use);
+						$contents .= '&lt;/item&gt;';
+					}
+					if ($use == 'literal') {
+						if ($forceType) {
+							$xml = &quot;&lt;$name xsi:type=\&quot;&quot; . $tt_prefix . &quot;:$uqType\&quot;&gt;$contents&lt;/$name&gt;&quot;;
+						} else {
+							$xml = &quot;&lt;$name&gt;$contents&lt;/$name&gt;&quot;;
+						}
+					} else {
+						$xml = &quot;&lt;$name xsi:type=\&quot;&quot; . $tt_prefix . &quot;:$uqType\&quot;$encodingStyle&gt;$contents&lt;/$name&gt;&quot;;
+					}
+					$this-&gt;debug(&quot;in serializeType: returning: $xml&quot;);
+					return $xml;
+				}
+				$this-&gt;debug('in serializeType: Apache SOAP type, but only support Map');
+			}
+		} else {
+			// TODO: should the type be compared to types in XSD, and the namespace
+			// set to XSD if the type matches?
+			$this-&gt;debug(&quot;in serializeType: No namespace for type $type&quot;);
+			$ns = '';
+			$uqType = $type;
+		}
+		if(!$typeDef = $this-&gt;getTypeDef($uqType, $ns)){
+			$this-&gt;setError(&quot;$type ($uqType) is not a supported type.&quot;);
+			$this-&gt;debug(&quot;in serializeType: $type ($uqType) is not a supported type.&quot;);
+			return false;
+		} else {
+			$this-&gt;debug(&quot;in serializeType: found typeDef&quot;);
+			$this-&gt;appendDebug('typeDef=' . $this-&gt;varDump($typeDef));
+		}
+		$phpType = $typeDef['phpType'];
+		$this-&gt;debug(&quot;in serializeType: uqType: $uqType, ns: $ns, phptype: $phpType, arrayType: &quot; . (isset($typeDef['arrayType']) ? $typeDef['arrayType'] : '') ); 
+		// if php type == struct, map value to the &lt;all&gt; element names
+		if ($phpType == 'struct') {
+			if (isset($typeDef['typeClass']) &amp;&amp; $typeDef['typeClass'] == 'element') {
+				$elementName = $uqType;
+				if (isset($typeDef['form']) &amp;&amp; ($typeDef['form'] == 'qualified')) {
+					$elementNS = &quot; xmlns=\&quot;$ns\&quot;&quot;;
+				} else {
+					$elementNS = &quot; xmlns=\&quot;\&quot;&quot;;
+				}
+			} else {
+				$elementName = $name;
+				if ($unqualified) {
+					$elementNS = &quot; xmlns=\&quot;\&quot;&quot;;
+				} else {
+					$elementNS = '';
+				}
+			}
+			if (is_null($value)) {
+				if ($use == 'literal') {
+					// TODO: depends on minOccurs
+					$xml = &quot;&lt;$elementName$elementNS/&gt;&quot;;
+				} else {
+					$xml = &quot;&lt;$elementName$elementNS xsi:nil=\&quot;true\&quot; xsi:type=\&quot;&quot; . $this-&gt;getPrefixFromNamespace($ns) . &quot;:$uqType\&quot;/&gt;&quot;;
+				}
+				$this-&gt;debug(&quot;in serializeType: returning: $xml&quot;);
+				return $xml;
+			}
+			if (is_object($value)) {
+				$value = get_object_vars($value);
+			}
+			if (is_array($value)) {
+				$elementAttrs = $this-&gt;serializeComplexTypeAttributes($typeDef, $value, $ns, $uqType);
+				if ($use == 'literal') {
+					if ($forceType) {
+						$xml = &quot;&lt;$elementName$elementNS$elementAttrs xsi:type=\&quot;&quot; . $this-&gt;getPrefixFromNamespace($ns) . &quot;:$uqType\&quot;&gt;&quot;;
+					} else {
+						$xml = &quot;&lt;$elementName$elementNS$elementAttrs&gt;&quot;;
+					}
+				} else {
+					$xml = &quot;&lt;$elementName$elementNS$elementAttrs xsi:type=\&quot;&quot; . $this-&gt;getPrefixFromNamespace($ns) . &quot;:$uqType\&quot;$encodingStyle&gt;&quot;;
+				}
+	
+				$xml .= $this-&gt;serializeComplexTypeElements($typeDef, $value, $ns, $uqType, $use, $encodingStyle);
+				$xml .= &quot;&lt;/$elementName&gt;&quot;;
+			} else {
+				$this-&gt;debug(&quot;in serializeType: phpType is struct, but value is not an array&quot;);
+				$this-&gt;setError(&quot;phpType is struct, but value is not an array: see debug output for details&quot;);
+				$xml = '';
+			}
+		} elseif ($phpType == 'array') {
+			if (isset($typeDef['form']) &amp;&amp; ($typeDef['form'] == 'qualified')) {
+				$elementNS = &quot; xmlns=\&quot;$ns\&quot;&quot;;
+			} else {
+				if ($unqualified) {
+					$elementNS = &quot; xmlns=\&quot;\&quot;&quot;;
+				} else {
+					$elementNS = '';
+				}
+			}
+			if (is_null($value)) {
+				if ($use == 'literal') {
+					// TODO: depends on minOccurs
+					$xml = &quot;&lt;$name$elementNS/&gt;&quot;;
+				} else {
+					$xml = &quot;&lt;$name$elementNS xsi:nil=\&quot;true\&quot; xsi:type=\&quot;&quot; .
+						$this-&gt;getPrefixFromNamespace('<A HREF="http://schemas.xmlsoap.org/soap/encoding/">http://schemas.xmlsoap.org/soap/encoding/</A>') .
+						&quot;:Array\&quot; &quot; .
+						$this-&gt;getPrefixFromNamespace('<A HREF="http://schemas.xmlsoap.org/soap/encoding/">http://schemas.xmlsoap.org/soap/encoding/</A>') .
+						':arrayType=&quot;' .
+						$this-&gt;getPrefixFromNamespace($this-&gt;getPrefix($typeDef['arrayType'])) .
+						':' .
+						$this-&gt;getLocalPart($typeDef['arrayType']).&quot;[0]\&quot;/&gt;&quot;;
+				}
+				$this-&gt;debug(&quot;in serializeType: returning: $xml&quot;);
+				return $xml;
+			}
+			if (isset($typeDef['multidimensional'])) {
+				$nv = array();
+				foreach($value as $v) {
+					$cols = ',' . sizeof($v);
+					$nv = array_merge($nv, $v);
+				} 
+				$value = $nv;
+			} else {
+				$cols = '';
+			} 
+			if (is_array($value) &amp;&amp; sizeof($value) &gt;= 1) {
+				$rows = sizeof($value);
+				$contents = '';
+				foreach($value as $k =&gt; $v) {
+					$this-&gt;debug(&quot;serializing array element: $k, $v of type: $typeDef[arrayType]&quot;);
+					//if (strpos($typeDef['arrayType'], ':') ) {
+					if (!in_array($typeDef['arrayType'],$this-&gt;typemap['<A HREF="http://www.w3.org/2001/XMLSchema">http://www.w3.org/2001/XMLSchema</A>'])) {
+					    $contents .= $this-&gt;serializeType('item', $typeDef['arrayType'], $v, $use);
+					} else {
+					    $contents .= $this-&gt;serialize_val($v, 'item', $typeDef['arrayType'], null, $this-&gt;XMLSchemaVersion, false, $use);
+					} 
+				}
+			} else {
+				$rows = 0;
+				$contents = null;
+			}
+			// TODO: for now, an empty value will be serialized as a zero element
+			// array.  Revisit this when coding the handling of null/nil values.
+			if ($use == 'literal') {
+				$xml = &quot;&lt;$name$elementNS&gt;&quot;
+					.$contents
+					.&quot;&lt;/$name&gt;&quot;;
+			} else {
+				$xml = &quot;&lt;$name$elementNS xsi:type=\&quot;&quot;.$this-&gt;getPrefixFromNamespace('<A HREF="http://schemas.xmlsoap.org/soap/encoding/">http://schemas.xmlsoap.org/soap/encoding/</A>').':Array&quot; '.
+					$this-&gt;getPrefixFromNamespace('<A HREF="http://schemas.xmlsoap.org/soap/encoding/">http://schemas.xmlsoap.org/soap/encoding/</A>')
+					.':arrayType=&quot;'
+					.$this-&gt;getPrefixFromNamespace($this-&gt;getPrefix($typeDef['arrayType']))
+					.&quot;:&quot;.$this-&gt;getLocalPart($typeDef['arrayType']).&quot;[$rows$cols]\&quot;&gt;&quot;
+					.$contents
+					.&quot;&lt;/$name&gt;&quot;;
+			}
+		} elseif ($phpType == 'scalar') {
+			if (isset($typeDef['form']) &amp;&amp; ($typeDef['form'] == 'qualified')) {
+				$elementNS = &quot; xmlns=\&quot;$ns\&quot;&quot;;
+			} else {
+				if ($unqualified) {
+					$elementNS = &quot; xmlns=\&quot;\&quot;&quot;;
+				} else {
+					$elementNS = '';
+				}
+			}
+			if ($use == 'literal') {
+				if ($forceType) {
+					$xml = &quot;&lt;$name$elementNS xsi:type=\&quot;&quot; . $this-&gt;getPrefixFromNamespace($ns) . &quot;:$uqType\&quot;&gt;$value&lt;/$name&gt;&quot;;
+				} else {
+					$xml = &quot;&lt;$name$elementNS&gt;$value&lt;/$name&gt;&quot;;
+				}
+			} else {
+				$xml = &quot;&lt;$name$elementNS xsi:type=\&quot;&quot; . $this-&gt;getPrefixFromNamespace($ns) . &quot;:$uqType\&quot;$encodingStyle&gt;$value&lt;/$name&gt;&quot;;
+			}
+		}
+		$this-&gt;debug(&quot;in serializeType: returning: $xml&quot;);
+		return $xml;
+	}
+	
+	/**
+	 * serializes the attributes for a complexType
+	 *
+	 * @param array $typeDef our internal representation of an XML schema type (or element)
+	 * @param mixed $value a native PHP value (parameter value)
+	 * @param string $ns the namespace of the type
+	 * @param string $uqType the local part of the type
+	 * @return string value serialized as an XML string
+	 * @access private
+	 */
+	function serializeComplexTypeAttributes($typeDef, $value, $ns, $uqType) {
+		$xml = '';
+		if (isset($typeDef['attrs']) &amp;&amp; is_array($typeDef['attrs'])) {
+			$this-&gt;debug(&quot;serialize attributes for XML Schema type $ns:$uqType&quot;);
+			if (is_array($value)) {
+				$xvalue = $value;
+			} elseif (is_object($value)) {
+				$xvalue = get_object_vars($value);
+			} else {
+				$this-&gt;debug(&quot;value is neither an array nor an object for XML Schema type $ns:$uqType&quot;);
+				$xvalue = array();
+			}
+			foreach ($typeDef['attrs'] as $aName =&gt; $attrs) {
+				if (isset($xvalue['!' . $aName])) {
+					$xname = '!' . $aName;
+					$this-&gt;debug(&quot;value provided for attribute $aName with key $xname&quot;);
+				} elseif (isset($xvalue[$aName])) {
+					$xname = $aName;
+					$this-&gt;debug(&quot;value provided for attribute $aName with key $xname&quot;);
+				} elseif (isset($attrs['default'])) {
+					$xname = '!' . $aName;
+					$xvalue[$xname] = $attrs['default'];
+					$this-&gt;debug('use default value of ' . $xvalue[$aName] . ' for attribute ' . $aName);
+				} else {
+					$xname = '';
+					$this-&gt;debug(&quot;no value provided for attribute $aName&quot;);
+				}
+				if ($xname) {
+					$xml .=  &quot; $aName=\&quot;&quot; . $this-&gt;expandEntities($xvalue[$xname]) . &quot;\&quot;&quot;;
+				}
+			} 
+		} else {
+			$this-&gt;debug(&quot;no attributes to serialize for XML Schema type $ns:$uqType&quot;);
+		}
+		if (isset($typeDef['extensionBase'])) {
+			$ns = $this-&gt;getPrefix($typeDef['extensionBase']);
+			$uqType = $this-&gt;getLocalPart($typeDef['extensionBase']);
+			if ($this-&gt;getNamespaceFromPrefix($ns)) {
+				$ns = $this-&gt;getNamespaceFromPrefix($ns);
+			}
+			if ($typeDef = $this-&gt;getTypeDef($uqType, $ns)) {
+				$this-&gt;debug(&quot;serialize attributes for extension base $ns:$uqType&quot;);
+				$xml .= $this-&gt;serializeComplexTypeAttributes($typeDef, $value, $ns, $uqType);
+			} else {
+				$this-&gt;debug(&quot;extension base $ns:$uqType is not a supported type&quot;);
+			}
+		}
+		return $xml;
+	}
+
+	/**
+	 * serializes the elements for a complexType
+	 *
+	 * @param array $typeDef our internal representation of an XML schema type (or element)
+	 * @param mixed $value a native PHP value (parameter value)
+	 * @param string $ns the namespace of the type
+	 * @param string $uqType the local part of the type
+	 * @param string $use use for part (encoded|literal)
+	 * @param string $encodingStyle SOAP encoding style for the value (if different than the enclosing style)
+	 * @return string value serialized as an XML string
+	 * @access private
+	 */
+	function serializeComplexTypeElements($typeDef, $value, $ns, $uqType, $use='encoded', $encodingStyle=false) {
+		$xml = '';
+		if (isset($typeDef['elements']) &amp;&amp; is_array($typeDef['elements'])) {
+			$this-&gt;debug(&quot;in serializeComplexTypeElements, serialize elements for XML Schema type $ns:$uqType&quot;);
+			if (is_array($value)) {
+				$xvalue = $value;
+			} elseif (is_object($value)) {
+				$xvalue = get_object_vars($value);
+			} else {
+				$this-&gt;debug(&quot;value is neither an array nor an object for XML Schema type $ns:$uqType&quot;);
+				$xvalue = array();
+			}
+			// toggle whether all elements are present - ideally should validate against schema
+			if (count($typeDef['elements']) != count($xvalue)){
+				$optionals = true;
+			}
+			foreach ($typeDef['elements'] as $eName =&gt; $attrs) {
+				if (!isset($xvalue[$eName])) {
+					if (isset($attrs['default'])) {
+						$xvalue[$eName] = $attrs['default'];
+						$this-&gt;debug('use default value of ' . $xvalue[$eName] . ' for element ' . $eName);
+					}
+				}
+				// if user took advantage of a minOccurs=0, then only serialize named parameters
+				if (isset($optionals)
+				    &amp;&amp; (!isset($xvalue[$eName])) 
+					&amp;&amp; ( (!isset($attrs['nillable'])) || $attrs['nillable'] != 'true')
+					){
+					if (isset($attrs['minOccurs']) &amp;&amp; $attrs['minOccurs'] &lt;&gt; '0') {
+						$this-&gt;debug(&quot;apparent error: no value provided for element $eName with minOccurs=&quot; . $attrs['minOccurs']);
+					}
+					// do nothing
+					$this-&gt;debug(&quot;no value provided for complexType element $eName and element is not nillable, so serialize nothing&quot;);
+				} else {
+					// get value
+					if (isset($xvalue[$eName])) {
+					    $v = $xvalue[$eName];
+					} else {
+					    $v = null;
+					}
+					if (isset($attrs['form'])) {
+						$unqualified = ($attrs['form'] == 'unqualified');
+					} else {
+						$unqualified = false;
+					}
+					if (isset($attrs['maxOccurs']) &amp;&amp; ($attrs['maxOccurs'] == 'unbounded' || $attrs['maxOccurs'] &gt; 1) &amp;&amp; isset($v) &amp;&amp; is_array($v) &amp;&amp; $this-&gt;isArraySimpleOrStruct($v) == 'arraySimple') {
+						$vv = $v;
+						foreach ($vv as $k =&gt; $v) {
+							if (isset($attrs['type']) || isset($attrs['ref'])) {
+								// serialize schema-defined type
+							    $xml .= $this-&gt;serializeType($eName, isset($attrs['type']) ? $attrs['type'] : $attrs['ref'], $v, $use, $encodingStyle, $unqualified);
+							} else {
+								// serialize generic type (can this ever really happen?)
+							    $this-&gt;debug(&quot;calling serialize_val() for $v, $eName, false, false, false, false, $use&quot;);
+							    $xml .= $this-&gt;serialize_val($v, $eName, false, false, false, false, $use);
+							}
+						}
+					} else {
+						if (isset($attrs['type']) || isset($attrs['ref'])) {
+							// serialize schema-defined type
+						    $xml .= $this-&gt;serializeType($eName, isset($attrs['type']) ? $attrs['type'] : $attrs['ref'], $v, $use, $encodingStyle, $unqualified);
+						} else {
+							// serialize generic type (can this ever really happen?)
+						    $this-&gt;debug(&quot;calling serialize_val() for $v, $eName, false, false, false, false, $use&quot;);
+						    $xml .= $this-&gt;serialize_val($v, $eName, false, false, false, false, $use);
+						}
+					}
+				}
+			} 
+		} else {
+			$this-&gt;debug(&quot;no elements to serialize for XML Schema type $ns:$uqType&quot;);
+		}
+		if (isset($typeDef['extensionBase'])) {
+			$ns = $this-&gt;getPrefix($typeDef['extensionBase']);
+			$uqType = $this-&gt;getLocalPart($typeDef['extensionBase']);
+			if ($this-&gt;getNamespaceFromPrefix($ns)) {
+				$ns = $this-&gt;getNamespaceFromPrefix($ns);
+			}
+			if ($typeDef = $this-&gt;getTypeDef($uqType, $ns)) {
+				$this-&gt;debug(&quot;serialize elements for extension base $ns:$uqType&quot;);
+				$xml .= $this-&gt;serializeComplexTypeElements($typeDef, $value, $ns, $uqType, $use, $encodingStyle);
+			} else {
+				$this-&gt;debug(&quot;extension base $ns:$uqType is not a supported type&quot;);
+			}
+		}
+		return $xml;
+	}
+
+	/**
+	* adds an XML Schema complex type to the WSDL types
+	*
+	* @param string	name
+	* @param string typeClass (complexType|simpleType|attribute)
+	* @param string phpType: currently supported are array and struct (php assoc array)
+	* @param string compositor (all|sequence|choice)
+	* @param string restrictionBase namespace:name (<A HREF="http://schemas.xmlsoap.org/soap/encoding/:Array">http://schemas.xmlsoap.org/soap/encoding/:Array</A>)
+	* @param array elements = array ( name =&gt; array(name=&gt;'',type=&gt;'') )
+	* @param array attrs = 	array(array('ref'=&gt;'SOAP-ENC:arrayType','wsdl:arrayType'=&gt;'xsd:string[]'))
+	* @param string arrayType: namespace:name (xsd:string)
+	* @see xmlschema
+	* @access public
+	*/
+	function addComplexType($name,$typeClass='complexType',$phpType='array',$compositor='',$restrictionBase='',$elements=array(),$attrs=array(),$arrayType='') {
+		if (count($elements) &gt; 0) {
+	    	foreach($elements as $n =&gt; $e){
+	            // expand each element
+	            foreach ($e as $k =&gt; $v) {
+		            $k = strpos($k,':') ? $this-&gt;expandQname($k) : $k;
+		            $v = strpos($v,':') ? $this-&gt;expandQname($v) : $v;
+		            $ee[$k] = $v;
+		    	}
+	    		$eElements[$n] = $ee;
+	    	}
+	    	$elements = $eElements;
+		}
+		
+		if (count($attrs) &gt; 0) {
+	    	foreach($attrs as $n =&gt; $a){
+	            // expand each attribute
+	            foreach ($a as $k =&gt; $v) {
+		            $k = strpos($k,':') ? $this-&gt;expandQname($k) : $k;
+		            $v = strpos($v,':') ? $this-&gt;expandQname($v) : $v;
+		            $aa[$k] = $v;
+		    	}
+	    		$eAttrs[$n] = $aa;
+	    	}
+	    	$attrs = $eAttrs;
+		}
+
+		$restrictionBase = strpos($restrictionBase,':') ? $this-&gt;expandQname($restrictionBase) : $restrictionBase;
+		$arrayType = strpos($arrayType,':') ? $this-&gt;expandQname($arrayType) : $arrayType;
+
+		$typens = isset($this-&gt;namespaces['types']) ? $this-&gt;namespaces['types'] : $this-&gt;namespaces['tns'];
+		$this-&gt;schemas[$typens][0]-&gt;addComplexType($name,$typeClass,$phpType,$compositor,$restrictionBase,$elements,$attrs,$arrayType);
+	}
+
+	/**
+	* adds an XML Schema simple type to the WSDL types
+	*
+	* @param string $name
+	* @param string $restrictionBase namespace:name (<A HREF="http://schemas.xmlsoap.org/soap/encoding/:Array">http://schemas.xmlsoap.org/soap/encoding/:Array</A>)
+	* @param string $typeClass (should always be simpleType)
+	* @param string $phpType (should always be scalar)
+	* @param array $enumeration array of values
+	* @see xmlschema
+	* @access public
+	*/
+	function addSimpleType($name, $restrictionBase='', $typeClass='simpleType', $phpType='scalar', $enumeration=array()) {
+		$restrictionBase = strpos($restrictionBase,':') ? $this-&gt;expandQname($restrictionBase) : $restrictionBase;
+
+		$typens = isset($this-&gt;namespaces['types']) ? $this-&gt;namespaces['types'] : $this-&gt;namespaces['tns'];
+		$this-&gt;schemas[$typens][0]-&gt;addSimpleType($name, $restrictionBase, $typeClass, $phpType, $enumeration);
+	}
+
+	/**
+	* adds an element to the WSDL types
+	*
+	* @param array $attrs attributes that must include name and type
+	* @see xmlschema
+	* @access public
+	*/
+	function addElement($attrs) {
+		$typens = isset($this-&gt;namespaces['types']) ? $this-&gt;namespaces['types'] : $this-&gt;namespaces['tns'];
+		$this-&gt;schemas[$typens][0]-&gt;addElement($attrs);
+	}
+
+	/**
+	* register an operation with the server
+	* 
+	* @param string $name operation (method) name
+	* @param array $in assoc array of input values: key = param name, value = param type
+	* @param array $out assoc array of output values: key = param name, value = param type
+	* @param string $namespace optional The namespace for the operation
+	* @param string $soapaction optional The soapaction for the operation
+	* @param string $style (rpc|document) optional The style for the operation Note: when 'document' is specified, parameter and return wrappers are created for you automatically
+	* @param string $use (encoded|literal) optional The use for the parameters (cannot mix right now)
+	* @param string $documentation optional The description to include in the WSDL
+	* @param string $encodingStyle optional (usually '<A HREF="http://schemas.xmlsoap.org/soap/encoding/">http://schemas.xmlsoap.org/soap/encoding/</A>' for encoded)
+	* @access public 
+	*/
+	function addOperation($name, $in = false, $out = false, $namespace = false, $soapaction = false, $style = 'rpc', $use = 'encoded', $documentation = '', $encodingStyle = ''){
+		if ($use == 'encoded' &amp;&amp; $encodingStyle == '') {
+			$encodingStyle = '<A HREF="http://schemas.xmlsoap.org/soap/encoding/">http://schemas.xmlsoap.org/soap/encoding/</A>';
+		}
+
+		if ($style == 'document') {
+			$elements = array();
+			foreach ($in as $n =&gt; $t) {
+				$elements[$n] = array('name' =&gt; $n, 'type' =&gt; $t);
+			}
+			$this-&gt;addComplexType($name . 'RequestType', 'complexType', 'struct', 'all', '', $elements);
+			$this-&gt;addElement(array('name' =&gt; $name, 'type' =&gt; $name . 'RequestType'));
+			$in = array('parameters' =&gt; 'tns:' . $name);
+
+			$elements = array();
+			foreach ($out as $n =&gt; $t) {
+				$elements[$n] = array('name' =&gt; $n, 'type' =&gt; $t);
+			}
+			$this-&gt;addComplexType($name . 'ResponseType', 'complexType', 'struct', 'all', '', $elements);
+			$this-&gt;addElement(array('name' =&gt; $name . 'Response', 'type' =&gt; $name . 'ResponseType'));
+			$out = array('parameters' =&gt; 'tns:' . $name . 'Response');
+		}
+
+		// get binding
+		$this-&gt;bindings[ $this-&gt;serviceName . 'Binding' ]['operations'][$name] =
+		array(
+		'name' =&gt; $name,
+		'binding' =&gt; $this-&gt;serviceName . 'Binding',
+		'endpoint' =&gt; $this-&gt;endpoint,
+		'soapAction' =&gt; $soapaction,
+		'style' =&gt; $style,
+		'input' =&gt; array(
+			'use' =&gt; $use,
+			'namespace' =&gt; $namespace,
+			'encodingStyle' =&gt; $encodingStyle,
+			'message' =&gt; $name . 'Request',
+			'parts' =&gt; $in),
+		'output' =&gt; array(
+			'use' =&gt; $use,
+			'namespace' =&gt; $namespace,
+			'encodingStyle' =&gt; $encodingStyle,
+			'message' =&gt; $name . 'Response',
+			'parts' =&gt; $out),
+		'namespace' =&gt; $namespace,
+		'transport' =&gt; '<A HREF="http://schemas.xmlsoap.org/soap/http">http://schemas.xmlsoap.org/soap/http</A>',
+		'documentation' =&gt; $documentation); 
+		// add portTypes
+		// add messages
+		if($in)
+		{
+			foreach($in as $pName =&gt; $pType)
+			{
+				if(strpos($pType,':')) {
+					$pType = $this-&gt;getNamespaceFromPrefix($this-&gt;getPrefix($pType)).&quot;:&quot;.$this-&gt;getLocalPart($pType);
+				}
+				$this-&gt;messages[$name.'Request'][$pName] = $pType;
+			}
+		} else {
+            $this-&gt;messages[$name.'Request']= '0';
+        }
+		if($out)
+		{
+			foreach($out as $pName =&gt; $pType)
+			{
+				if(strpos($pType,':')) {
+					$pType = $this-&gt;getNamespaceFromPrefix($this-&gt;getPrefix($pType)).&quot;:&quot;.$this-&gt;getLocalPart($pType);
+				}
+				$this-&gt;messages[$name.'Response'][$pName] = $pType;
+			}
+		} else {
+            $this-&gt;messages[$name.'Response']= '0';
+        }
+		return true;
+	} 
+}
+
+?&gt;
\ No newline at end of file

Added: cms/trunk/includes/nusoap/class.wsdlcache.php
===================================================================
--- cms/trunk/includes/nusoap/class.wsdlcache.php	2005-09-20 21:46:50 UTC (rev 136)
+++ cms/trunk/includes/nusoap/class.wsdlcache.php	2005-09-21 03:53:30 UTC (rev 137)
@@ -0,0 +1,184 @@
+&lt;?php
+
+
+
+/**
+* caches instances of the wsdl class
+* 
+* @author   Scott Nichol &lt;<A HREF="https://lists.berlios.de/mailman/listinfo/viperals-svncheckins">snichol at computer.org</A>&gt;
+* @author	Ingo Fischer &lt;<A HREF="https://lists.berlios.de/mailman/listinfo/viperals-svncheckins">ingo at apollon.de</A>&gt;
+* @version  $Id: class.wsdlcache.php,v 1.5 2005/05/20 17:58:17 snichol Exp $
+* @access public 
+*/
+class wsdlcache {
+	/**
+	 *	@var resource
+	 *	@access private
+	 */
+	var $fplock;
+	/**
+	 *	@var integer
+	 *	@access private
+	 */
+	var $cache_lifetime;
+	/**
+	 *	@var string
+	 *	@access private
+	 */
+	var $cache_dir;
+	/**
+	 *	@var string
+	 *	@access public
+	 */
+	var $debug_str = '';
+
+	/**
+	* constructor
+	*
+	* @param string $cache_dir directory for cache-files
+	* @param integer $cache_lifetime lifetime for caching-files in seconds or 0 for unlimited
+	* @access public
+	*/
+	function wsdlcache($cache_dir='.', $cache_lifetime=0) {
+		$this-&gt;fplock = array();
+		$this-&gt;cache_dir = $cache_dir != '' ? $cache_dir : '.';
+		$this-&gt;cache_lifetime = $cache_lifetime;
+	}
+
+	/**
+	* creates the filename used to cache a wsdl instance
+	*
+	* @param string $wsdl The URL of the wsdl instance
+	* @return string The filename used to cache the instance
+	* @access private
+	*/
+	function createFilename($wsdl) {
+		return $this-&gt;cache_dir.'/wsdlcache-' . md5($wsdl);
+	}
+
+	/**
+	* adds debug data to the class level debug string
+	*
+	* @param    string $string debug data
+	* @access   private
+	*/
+	function debug($string){
+		$this-&gt;debug_str .= get_class($this).&quot;: $string\n&quot;;
+	}
+
+	/**
+	* gets a wsdl instance from the cache
+	*
+	* @param string $wsdl The URL of the wsdl instance
+	* @return object wsdl The cached wsdl instance, null if the instance is not in the cache
+	* @access public
+	*/
+	function get($wsdl) {
+		$filename = $this-&gt;createFilename($wsdl);
+		if ($this-&gt;obtainMutex($filename, &quot;r&quot;)) {
+			// check for expired WSDL that must be removed from the cache
+ 			if ($this-&gt;cache_lifetime &gt; 0) {
+				if (file_exists($filename) &amp;&amp; (time() - filemtime($filename) &gt; $this-&gt;cache_lifetime)) {
+					unlink($filename);
+					$this-&gt;debug(&quot;Expired $wsdl ($filename) from cache&quot;);
+					$this-&gt;releaseMutex($filename);
+					return null;
+  				}
+			}
+			// see what there is to return
+			$fp = @fopen($filename, &quot;r&quot;);
+			if ($fp) {
+				$s = implode(&quot;&quot;, @file($filename));
+				fclose($fp);
+				$this-&gt;debug(&quot;Got $wsdl ($filename) from cache&quot;);
+			} else {
+				$s = null;
+				$this-&gt;debug(&quot;$wsdl ($filename) not in cache&quot;);
+			}
+			$this-&gt;releaseMutex($filename);
+			return (!is_null($s)) ? unserialize($s) : null;
+		} else {
+			$this-&gt;debug(&quot;Unable to obtain mutex for $filename in get&quot;);
+		}
+		return null;
+	}
+
+	/**
+	* obtains the local mutex
+	*
+	* @param string $filename The Filename of the Cache to lock
+	* @param string $mode The open-mode (&quot;r&quot; or &quot;w&quot;) or the file - affects lock-mode
+	* @return boolean Lock successfully obtained ?!
+	* @access private
+	*/
+	function obtainMutex($filename, $mode) {
+		if (isset($this-&gt;fplock[md5($filename)])) {
+			$this-&gt;debug(&quot;Lock for $filename already exists&quot;);
+			return false;
+		}
+		$this-&gt;fplock[md5($filename)] = fopen($filename.&quot;.lock&quot;, &quot;w&quot;);
+		if ($mode == &quot;r&quot;) {
+			return flock($this-&gt;fplock[md5($filename)], LOCK_SH);
+		} else {
+			return flock($this-&gt;fplock[md5($filename)], LOCK_EX);
+		}
+	}
+
+	/**
+	* adds a wsdl instance to the cache
+	*
+	* @param object wsdl $wsdl_instance The wsdl instance to add
+	* @return boolean WSDL successfully cached
+	* @access public
+	*/
+	function put($wsdl_instance) {
+		$filename = $this-&gt;createFilename($wsdl_instance-&gt;wsdl);
+		$s = serialize($wsdl_instance);
+		if ($this-&gt;obtainMutex($filename, &quot;w&quot;)) {
+			$fp = fopen($filename, &quot;w&quot;);
+			fputs($fp, $s);
+			fclose($fp);
+			$this-&gt;debug(&quot;Put $wsdl_instance-&gt;wsdl ($filename) in cache&quot;);
+			$this-&gt;releaseMutex($filename);
+			return true;
+		} else {
+			$this-&gt;debug(&quot;Unable to obtain mutex for $filename in put&quot;);
+		}
+		return false;
+	}
+
+	/**
+	* releases the local mutex
+	*
+	* @param string $filename The Filename of the Cache to lock
+	* @return boolean Lock successfully released
+	* @access private
+	*/
+	function releaseMutex($filename) {
+		$ret = flock($this-&gt;fplock[md5($filename)], LOCK_UN);
+		fclose($this-&gt;fplock[md5($filename)]);
+		unset($this-&gt;fplock[md5($filename)]);
+		if (! $ret) {
+			$this-&gt;debug(&quot;Not able to release lock for $filename&quot;);
+		}
+		return $ret;
+	}
+
+	/**
+	* removes a wsdl instance from the cache
+	*
+	* @param string $wsdl The URL of the wsdl instance
+	* @return boolean Whether there was an instance to remove
+	* @access public
+	*/
+	function remove($wsdl) {
+		$filename = $this-&gt;createFilename($wsdl);
+		// ignore errors obtaining mutex
+		$this-&gt;obtainMutex($filename, &quot;w&quot;);
+		$ret = unlink($filename);
+		$this-&gt;debug(&quot;Removed ($ret) $wsdl ($filename) from cache&quot;);
+		$this-&gt;releaseMutex($filename);
+		return $ret;
+	}
+}
+?&gt;

Added: cms/trunk/includes/nusoap/class.xmlschema.php
===================================================================
--- cms/trunk/includes/nusoap/class.xmlschema.php	2005-09-20 21:46:50 UTC (rev 136)
+++ cms/trunk/includes/nusoap/class.xmlschema.php	2005-09-21 03:53:30 UTC (rev 137)
@@ -0,0 +1,906 @@
+&lt;?php
+
+
+
+
+/**
+* parses an XML Schema, allows access to it's data, other utility methods
+* no validation... yet.
+* very experimental and limited. As is discussed on XML-DEV, I'm one of the people
+* that just doesn't have time to read the spec(s) thoroughly, and just have a couple of trusty
+* tutorials I refer to :)
+*
+* @author   Dietrich Ayala &lt;<A HREF="https://lists.berlios.de/mailman/listinfo/viperals-svncheckins">dietrich at ganx4.com</A>&gt;
+* @version  $Id: class.xmlschema.php,v 1.39 2005/08/04 01:27:42 snichol Exp $
+* @access   public
+*/
+class XMLSchema extends nusoap_base  {
+	
+	// files
+	var $schema = '';
+	var $xml = '';
+	// namespaces
+	var $enclosingNamespaces;
+	// schema info
+	var $schemaInfo = array();
+	var $schemaTargetNamespace = '';
+	// types, elements, attributes defined by the schema
+	var $attributes = array();
+	var $complexTypes = array();
+	var $complexTypeStack = array();
+	var $currentComplexType = null;
+	var $elements = array();
+	var $elementStack = array();
+	var $currentElement = null;
+	var $simpleTypes = array();
+	var $simpleTypeStack = array();
+	var $currentSimpleType = null;
+	// imports
+	var $imports = array();
+	// parser vars
+	var $parser;
+	var $position = 0;
+	var $depth = 0;
+	var $depth_array = array();
+	var $message = array();
+	var $defaultNamespace = array();
+    
+	/**
+	* constructor
+	*
+	* @param    string $schema schema document URI
+	* @param    string $xml xml document URI
+	* @param	string $namespaces namespaces defined in enclosing XML
+	* @access   public
+	*/
+	function XMLSchema($schema='',$xml='',$namespaces=array()){
+		parent::nusoap_base();
+		$this-&gt;debug('xmlschema class instantiated, inside constructor');
+		// files
+		$this-&gt;schema = $schema;
+		$this-&gt;xml = $xml;
+
+		// namespaces
+		$this-&gt;enclosingNamespaces = $namespaces;
+		$this-&gt;namespaces = array_merge($this-&gt;namespaces, $namespaces);
+
+		// parse schema file
+		if($schema != ''){
+			$this-&gt;debug('initial schema file: '.$schema);
+			$this-&gt;parseFile($schema, 'schema');
+		}
+
+		// parse xml file
+		if($xml != ''){
+			$this-&gt;debug('initial xml file: '.$xml);
+			$this-&gt;parseFile($xml, 'xml');
+		}
+
+	}
+
+    /**
+    * parse an XML file
+    *
+    * @param string $xml, path/URL to XML file
+    * @param string $type, (schema | xml)
+	* @return boolean
+    * @access public
+    */
+	function parseFile($xml,$type){
+		// parse xml file
+		if($xml != &quot;&quot;){
+			$xmlStr = @join(&quot;&quot;<A HREF="https://lists.berlios.de/mailman/listinfo/viperals-svncheckins">, at file</A>($xml));
+			if($xmlStr == &quot;&quot;){
+				$msg = 'Error reading XML from '.$xml;
+				$this-&gt;setError($msg);
+				$this-&gt;debug($msg);
+			return false;
+			} else {
+				$this-&gt;debug(&quot;parsing $xml&quot;);
+				$this-&gt;parseString($xmlStr,$type);
+				$this-&gt;debug(&quot;done parsing $xml&quot;);
+			return true;
+			}
+		}
+		return false;
+	}
+
+	/**
+	* parse an XML string
+	*
+	* @param    string $xml path or URL
+    * @param string $type, (schema|xml)
+	* @access   private
+	*/
+	function parseString($xml,$type){
+		// parse xml string
+		if($xml != &quot;&quot;){
+
+	    	// Create an XML parser.
+	    	$this-&gt;parser = xml_parser_create();
+	    	// Set the options for parsing the XML data.
+	    	xml_parser_set_option($this-&gt;parser, XML_OPTION_CASE_FOLDING, 0);
+
+	    	// Set the object for the parser.
+	    	xml_set_object($this-&gt;parser, $this);
+
+	    	// Set the element handlers for the parser.
+			if($type == &quot;schema&quot;){
+		    	xml_set_element_handler($this-&gt;parser, 'schemaStartElement','schemaEndElement');
+		    	xml_set_character_data_handler($this-&gt;parser,'schemaCharacterData');
+			} elseif($type == &quot;xml&quot;){
+				xml_set_element_handler($this-&gt;parser, 'xmlStartElement','xmlEndElement');
+		    	xml_set_character_data_handler($this-&gt;parser,'xmlCharacterData');
+			}
+
+		    // Parse the XML file.
+		    if(!xml_parse($this-&gt;parser,$xml,true)){
+			// Display an error message.
+				$errstr = sprintf('XML error parsing XML schema on line %d: %s',
+				xml_get_current_line_number($this-&gt;parser),
+				xml_error_string(xml_get_error_code($this-&gt;parser))
+				);
+				$this-&gt;debug($errstr);
+				$this-&gt;debug(&quot;XML payload:\n&quot; . $xml);
+				$this-&gt;setError($errstr);
+	    	}
+            
+			xml_parser_free($this-&gt;parser);
+		} else{
+			$this-&gt;debug('no xml passed to parseString()!!');
+			$this-&gt;setError('no xml passed to parseString()!!');
+		}
+	}
+
+	/**
+	* start-element handler
+	*
+	* @param    string $parser XML parser object
+	* @param    string $name element name
+	* @param    string $attrs associative array of attributes
+	* @access   private
+	*/
+	function schemaStartElement($parser, $name, $attrs) {
+		
+		// position in the total number of elements, starting from 0
+		$pos = $this-&gt;position++;
+		$depth = $this-&gt;depth++;
+		// set self as current value for this depth
+		$this-&gt;depth_array[$depth] = $pos;
+		$this-&gt;message[$pos] = array('cdata' =&gt; ''); 
+		if ($depth &gt; 0) {
+			$this-&gt;defaultNamespace[$pos] = $this-&gt;defaultNamespace[$this-&gt;depth_array[$depth - 1]];
+		} else {
+			$this-&gt;defaultNamespace[$pos] = false;
+		}
+
+		// get element prefix
+		if($prefix = $this-&gt;getPrefix($name)){
+			// get unqualified name
+			$name = $this-&gt;getLocalPart($name);
+		} else {
+        	$prefix = '';
+        }
+		
+        // loop thru attributes, expanding, and registering namespace declarations
+        if(count($attrs) &gt; 0){
+        	foreach($attrs as $k =&gt; $v){
+                // if ns declarations, add to class level array of valid namespaces
+				if(ereg(&quot;^xmlns&quot;,$k)){
+                	//$this-&gt;xdebug(&quot;$k: $v&quot;);
+                	//$this-&gt;xdebug('ns_prefix: '.$this-&gt;getPrefix($k));
+                	if($ns_prefix = substr(strrchr($k,':'),1)){
+                		//$this-&gt;xdebug(&quot;Add namespace[$ns_prefix] = $v&quot;);
+						$this-&gt;namespaces[$ns_prefix] = $v;
+					} else {
+						$this-&gt;defaultNamespace[$pos] = $v;
+						if (! $this-&gt;getPrefixFromNamespace($v)) {
+							$this-&gt;namespaces['ns'.(count($this-&gt;namespaces)+1)] = $v;
+						}
+					}
+					if($v == '<A HREF="http://www.w3.org/2001/XMLSchema">http://www.w3.org/2001/XMLSchema</A>' || $v == '<A HREF="http://www.w3.org/1999/XMLSchema">http://www.w3.org/1999/XMLSchema</A>' || $v == '<A HREF="http://www.w3.org/2000/10/XMLSchema">http://www.w3.org/2000/10/XMLSchema</A>'){
+						$this-&gt;XMLSchemaVersion = $v;
+						$this-&gt;namespaces['xsi'] = $v.'-instance';
+					}
+				}
+        	}
+        	foreach($attrs as $k =&gt; $v){
+                // expand each attribute
+                $k = strpos($k,':') ? $this-&gt;expandQname($k) : $k;
+                $v = strpos($v,':') ? $this-&gt;expandQname($v) : $v;
+        		$eAttrs[$k] = $v;
+        	}
+        	$attrs = $eAttrs;
+        } else {
+        	$attrs = array();
+        }
+		// find status, register data
+		switch($name){
+			case 'all':			// (optional) compositor content for a complexType
+			case 'choice':
+			case 'group':
+			case 'sequence':
+				//$this-&gt;xdebug(&quot;compositor $name for currentComplexType: $this-&gt;currentComplexType and currentElement: $this-&gt;currentElement&quot;);
+				$this-&gt;complexTypes[$this-&gt;currentComplexType]['compositor'] = $name;
+				//if($name == 'all' || $name == 'sequence'){
+				//	$this-&gt;complexTypes[$this-&gt;currentComplexType]['phpType'] = 'struct';
+				//}
+			break;
+			case 'attribute':	// complexType attribute
+            	//$this-&gt;xdebug(&quot;parsing attribute $attrs[name] $attrs[ref] of value: &quot;.$attrs['<A HREF="http://schemas.xmlsoap.org/wsdl/:arrayType">http://schemas.xmlsoap.org/wsdl/:arrayType</A>']);
+            	$this-&gt;xdebug(&quot;parsing attribute:&quot;);
+            	$this-&gt;appendDebug($this-&gt;varDump($attrs));
+				if (!isset($attrs['form'])) {
+					$attrs['form'] = $this-&gt;schemaInfo['attributeFormDefault'];
+				}
+            	if (isset($attrs['<A HREF="http://schemas.xmlsoap.org/wsdl/:arrayType">http://schemas.xmlsoap.org/wsdl/:arrayType</A>'])) {
+					$v = $attrs['<A HREF="http://schemas.xmlsoap.org/wsdl/:arrayType">http://schemas.xmlsoap.org/wsdl/:arrayType</A>'];
+					if (!strpos($v, ':')) {
+						// no namespace in arrayType attribute value...
+						if ($this-&gt;defaultNamespace[$pos]) {
+							// ...so use the default
+							$attrs['<A HREF="http://schemas.xmlsoap.org/wsdl/:arrayType">http://schemas.xmlsoap.org/wsdl/:arrayType</A>'] = $this-&gt;defaultNamespace[$pos] . ':' . $attrs['<A HREF="http://schemas.xmlsoap.org/wsdl/:arrayType">http://schemas.xmlsoap.org/wsdl/:arrayType</A>'];
+						}
+					}
+            	}
+                if(isset($attrs['name'])){
+					$this-&gt;attributes[$attrs['name']] = $attrs;
+					$aname = $attrs['name'];
+				} elseif(isset($attrs['ref']) &amp;&amp; $attrs['ref'] == '<A HREF="http://schemas.xmlsoap.org/soap/encoding/:arrayType">http://schemas.xmlsoap.org/soap/encoding/:arrayType</A>'){
+					if (isset($attrs['<A HREF="http://schemas.xmlsoap.org/wsdl/:arrayType">http://schemas.xmlsoap.org/wsdl/:arrayType</A>'])) {
+	                	$aname = $attrs['<A HREF="http://schemas.xmlsoap.org/wsdl/:arrayType">http://schemas.xmlsoap.org/wsdl/:arrayType</A>'];
+	                } else {
+	                	$aname = '';
+	                }
+				} elseif(isset($attrs['ref'])){
+					$aname = $attrs['ref'];
+                    $this-&gt;attributes[$attrs['ref']] = $attrs;
+				}
+                
+				if($this-&gt;currentComplexType){	// This should *always* be
+					$this-&gt;complexTypes[$this-&gt;currentComplexType]['attrs'][$aname] = $attrs;
+				}
+				// arrayType attribute
+				if(isset($attrs['<A HREF="http://schemas.xmlsoap.org/wsdl/:arrayType">http://schemas.xmlsoap.org/wsdl/:arrayType</A>']) || $this-&gt;getLocalPart($aname) == 'arrayType'){
+					$this-&gt;complexTypes[$this-&gt;currentComplexType]['phpType'] = 'array';
+                	$prefix = $this-&gt;getPrefix($aname);
+					if(isset($attrs['<A HREF="http://schemas.xmlsoap.org/wsdl/:arrayType">http://schemas.xmlsoap.org/wsdl/:arrayType</A>'])){
+						$v = $attrs['<A HREF="http://schemas.xmlsoap.org/wsdl/:arrayType">http://schemas.xmlsoap.org/wsdl/:arrayType</A>'];
+					} else {
+						$v = '';
+					}
+                    if(strpos($v,'[,]')){
+                        $this-&gt;complexTypes[$this-&gt;currentComplexType]['multidimensional'] = true;
+                    }
+                    $v = substr($v,0,strpos($v,'[')); // clip the []
+                    if(!strpos($v,':') &amp;&amp; isset($this-&gt;typemap[$this-&gt;XMLSchemaVersion][$v])){
+                        $v = $this-&gt;XMLSchemaVersion.':'.$v;
+                    }
+                    $this-&gt;complexTypes[$this-&gt;currentComplexType]['arrayType'] = $v;
+				}
+			break;
+			case 'complexContent':	// (optional) content for a complexType
+			break;
+			case 'complexType':
+				array_push($this-&gt;complexTypeStack, $this-&gt;currentComplexType);
+				if(isset($attrs['name'])){
+					$this-&gt;xdebug('processing named complexType '.$attrs['name']);
+					//$this-&gt;currentElement = false;
+					$this-&gt;currentComplexType = $attrs['name'];
+					$this-&gt;complexTypes[$this-&gt;currentComplexType] = $attrs;
+					$this-&gt;complexTypes[$this-&gt;currentComplexType]['typeClass'] = 'complexType';
+					// This is for constructs like
+					//           &lt;complexType name=&quot;ListOfString&quot; base=&quot;soap:Array&quot;&gt;
+					//                &lt;sequence&gt;
+					//                    &lt;element name=&quot;string&quot; type=&quot;xsd:string&quot;
+					//                        minOccurs=&quot;0&quot; maxOccurs=&quot;unbounded&quot; /&gt;
+					//                &lt;/sequence&gt;
+					//            &lt;/complexType&gt;
+					if(isset($attrs['base']) &amp;&amp; ereg(':Array$',$attrs['base'])){
+						$this-&gt;xdebug('complexType is unusual array');
+						$this-&gt;complexTypes[$this-&gt;currentComplexType]['phpType'] = 'array';
+					} else {
+						$this-&gt;complexTypes[$this-&gt;currentComplexType]['phpType'] = 'struct';
+					}
+				}else{
+					$this-&gt;xdebug('processing unnamed complexType for element '.$this-&gt;currentElement);
+					$this-&gt;currentComplexType = $this-&gt;currentElement . '_ContainedType';
+					//$this-&gt;currentElement = false;
+					$this-&gt;complexTypes[$this-&gt;currentComplexType] = $attrs;
+					$this-&gt;complexTypes[$this-&gt;currentComplexType]['typeClass'] = 'complexType';
+					// This is for constructs like
+					//           &lt;complexType name=&quot;ListOfString&quot; base=&quot;soap:Array&quot;&gt;
+					//                &lt;sequence&gt;
+					//                    &lt;element name=&quot;string&quot; type=&quot;xsd:string&quot;
+					//                        minOccurs=&quot;0&quot; maxOccurs=&quot;unbounded&quot; /&gt;
+					//                &lt;/sequence&gt;
+					//            &lt;/complexType&gt;
+					if(isset($attrs['base']) &amp;&amp; ereg(':Array$',$attrs['base'])){
+						$this-&gt;xdebug('complexType is unusual array');
+						$this-&gt;complexTypes[$this-&gt;currentComplexType]['phpType'] = 'array';
+					} else {
+						$this-&gt;complexTypes[$this-&gt;currentComplexType]['phpType'] = 'struct';
+					}
+				}
+			break;
+			case 'element':
+				array_push($this-&gt;elementStack, $this-&gt;currentElement);
+				// elements defined as part of a complex type should
+				// not really be added to $this-&gt;elements, but for some
+				// reason, they are
+				if (!isset($attrs['form'])) {
+					$attrs['form'] = $this-&gt;schemaInfo['elementFormDefault'];
+				}
+				if(isset($attrs['type'])){
+					$this-&gt;xdebug(&quot;processing typed element &quot;.$attrs['name'].&quot; of type &quot;.$attrs['type']);
+					if (! $this-&gt;getPrefix($attrs['type'])) {
+						if ($this-&gt;defaultNamespace[$pos]) {
+							$attrs['type'] = $this-&gt;defaultNamespace[$pos] . ':' . $attrs['type'];
+							$this-&gt;xdebug('used default namespace to make type ' . $attrs['type']);
+						}
+					}
+					// This is for constructs like
+					//           &lt;complexType name=&quot;ListOfString&quot; base=&quot;soap:Array&quot;&gt;
+					//                &lt;sequence&gt;
+					//                    &lt;element name=&quot;string&quot; type=&quot;xsd:string&quot;
+					//                        minOccurs=&quot;0&quot; maxOccurs=&quot;unbounded&quot; /&gt;
+					//                &lt;/sequence&gt;
+					//            &lt;/complexType&gt;
+					if ($this-&gt;currentComplexType &amp;&amp; $this-&gt;complexTypes[$this-&gt;currentComplexType]['phpType'] == 'array') {
+						$this-&gt;xdebug('arrayType for unusual array is ' . $attrs['type']);
+						$this-&gt;complexTypes[$this-&gt;currentComplexType]['arrayType'] = $attrs['type'];
+					}
+					$this-&gt;currentElement = $attrs['name'];
+					$this-&gt;elements[ $attrs['name'] ] = $attrs;
+					$this-&gt;elements[ $attrs['name'] ]['typeClass'] = 'element';
+					$ename = $attrs['name'];
+				} elseif(isset($attrs['ref'])){
+					$this-&gt;xdebug(&quot;processing element as ref to &quot;.$attrs['ref']);
+					$this-&gt;currentElement = &quot;ref to &quot;.$attrs['ref'];
+					$ename = $this-&gt;getLocalPart($attrs['ref']);
+				} else {
+					$this-&gt;xdebug(&quot;processing untyped element &quot;.$attrs['name']);
+					$this-&gt;currentElement = $attrs['name'];
+					$this-&gt;elements[ $attrs['name'] ] = $attrs;
+					$this-&gt;elements[ $attrs['name'] ]['typeClass'] = 'element';
+					$attrs['type'] = $this-&gt;schemaTargetNamespace . ':' . $attrs['name'] . '_ContainedType';
+					$this-&gt;elements[ $attrs['name'] ]['type'] = $attrs['type'];
+					$ename = $attrs['name'];
+				}
+				if(isset($ename) &amp;&amp; $this-&gt;currentComplexType){
+					$this-&gt;complexTypes[$this-&gt;currentComplexType]['elements'][$ename] = $attrs;
+				}
+			break;
+			case 'enumeration':	//	restriction value list member
+				$this-&gt;xdebug('enumeration ' . $attrs['value']);
+				if ($this-&gt;currentSimpleType) {
+					$this-&gt;simpleTypes[$this-&gt;currentSimpleType]['enumeration'][] = $attrs['value'];
+				} elseif ($this-&gt;currentComplexType) {
+					$this-&gt;complexTypes[$this-&gt;currentComplexType]['enumeration'][] = $attrs['value'];
+				}
+			break;
+			case 'extension':	// simpleContent or complexContent type extension
+				$this-&gt;xdebug('extension ' . $attrs['base']);
+				if ($this-&gt;currentComplexType) {
+					$this-&gt;complexTypes[$this-&gt;currentComplexType]['extensionBase'] = $attrs['base'];
+				}
+			break;
+			case 'import':
+			    if (isset($attrs['schemaLocation'])) {
+					//$this-&gt;xdebug('import namespace ' . $attrs['namespace'] . ' from ' . $attrs['schemaLocation']);
+                    $this-&gt;imports[$attrs['namespace']][] = array('location' =&gt; $attrs['schemaLocation'], 'loaded' =&gt; false);
+				} else {
+					//$this-&gt;xdebug('import namespace ' . $attrs['namespace']);
+                    $this-&gt;imports[$attrs['namespace']][] = array('location' =&gt; '', 'loaded' =&gt; true);
+					if (! $this-&gt;getPrefixFromNamespace($attrs['namespace'])) {
+						$this-&gt;namespaces['ns'.(count($this-&gt;namespaces)+1)] = $attrs['namespace'];
+					}
+				}
+			break;
+			case 'list':	// simpleType value list
+			break;
+			case 'restriction':	// simpleType, simpleContent or complexContent value restriction
+				$this-&gt;xdebug('restriction ' . $attrs['base']);
+				if($this-&gt;currentSimpleType){
+					$this-&gt;simpleTypes[$this-&gt;currentSimpleType]['type'] = $attrs['base'];
+				} elseif($this-&gt;currentComplexType){
+					$this-&gt;complexTypes[$this-&gt;currentComplexType]['restrictionBase'] = $attrs['base'];
+					if(strstr($attrs['base'],':') == ':Array'){
+						$this-&gt;complexTypes[$this-&gt;currentComplexType]['phpType'] = 'array';
+					}
+				}
+			break;
+			case 'schema':
+				$this-&gt;schemaInfo = $attrs;
+				$this-&gt;schemaInfo['schemaVersion'] = $this-&gt;getNamespaceFromPrefix($prefix);
+				if (isset($attrs['targetNamespace'])) {
+					$this-&gt;schemaTargetNamespace = $attrs['targetNamespace'];
+				}
+				if (!isset($attrs['elementFormDefault'])) {
+					$this-&gt;schemaInfo['elementFormDefault'] = 'unqualified';
+				}
+				if (!isset($attrs['attributeFormDefault'])) {
+					$this-&gt;schemaInfo['attributeFormDefault'] = 'unqualified';
+				}
+			break;
+			case 'simpleContent':	// (optional) content for a complexType
+			break;
+			case 'simpleType':
+				array_push($this-&gt;simpleTypeStack, $this-&gt;currentSimpleType);
+				if(isset($attrs['name'])){
+					$this-&gt;xdebug(&quot;processing simpleType for name &quot; . $attrs['name']);
+					$this-&gt;currentSimpleType = $attrs['name'];
+					$this-&gt;simpleTypes[ $attrs['name'] ] = $attrs;
+					$this-&gt;simpleTypes[ $attrs['name'] ]['typeClass'] = 'simpleType';
+					$this-&gt;simpleTypes[ $attrs['name'] ]['phpType'] = 'scalar';
+				} else {
+					$this-&gt;xdebug('processing unnamed simpleType for element '.$this-&gt;currentElement);
+					$this-&gt;currentSimpleType = $this-&gt;currentElement . '_ContainedType';
+					//$this-&gt;currentElement = false;
+					$this-&gt;simpleTypes[$this-&gt;currentSimpleType] = $attrs;
+					$this-&gt;simpleTypes[$this-&gt;currentSimpleType]['phpType'] = 'scalar';
+				}
+			break;
+			case 'union':	// simpleType type list
+			break;
+			default:
+				//$this-&gt;xdebug(&quot;do not have anything to do for element $name&quot;);
+		}
+	}
+
+	/**
+	* end-element handler
+	*
+	* @param    string $parser XML parser object
+	* @param    string $name element name
+	* @access   private
+	*/
+	function schemaEndElement($parser, $name) {
+		// bring depth down a notch
+		$this-&gt;depth--;
+		// position of current element is equal to the last value left in depth_array for my depth
+		if(isset($this-&gt;depth_array[$this-&gt;depth])){
+        	$pos = $this-&gt;depth_array[$this-&gt;depth];
+        }
+		// get element prefix
+		if ($prefix = $this-&gt;getPrefix($name)){
+			// get unqualified name
+			$name = $this-&gt;getLocalPart($name);
+		} else {
+        	$prefix = '';
+        }
+		// move on...
+		if($name == 'complexType'){
+			$this-&gt;xdebug('done processing complexType ' . ($this-&gt;currentComplexType ? $this-&gt;currentComplexType : '(unknown)'));
+			$this-&gt;currentComplexType = array_pop($this-&gt;complexTypeStack);
+			//$this-&gt;currentElement = false;
+		}
+		if($name == 'element'){
+			$this-&gt;xdebug('done processing element ' . ($this-&gt;currentElement ? $this-&gt;currentElement : '(unknown)'));
+			$this-&gt;currentElement = array_pop($this-&gt;elementStack);
+		}
+		if($name == 'simpleType'){
+			$this-&gt;xdebug('done processing simpleType ' . ($this-&gt;currentSimpleType ? $this-&gt;currentSimpleType : '(unknown)'));
+			$this-&gt;currentSimpleType = array_pop($this-&gt;simpleTypeStack);
+		}
+	}
+
+	/**
+	* element content handler
+	*
+	* @param    string $parser XML parser object
+	* @param    string $data element content
+	* @access   private
+	*/
+	function schemaCharacterData($parser, $data){
+		$pos = $this-&gt;depth_array[$this-&gt;depth - 1];
+		$this-&gt;message[$pos]['cdata'] .= $data;
+	}
+
+	/**
+	* serialize the schema
+	*
+	* @access   public
+	*/
+	function serializeSchema(){
+
+		$schemaPrefix = $this-&gt;getPrefixFromNamespace($this-&gt;XMLSchemaVersion);
+		$xml = '';
+		// imports
+		if (sizeof($this-&gt;imports) &gt; 0) {
+			foreach($this-&gt;imports as $ns =&gt; $list) {
+				foreach ($list as $ii) {
+					if ($ii['location'] != '') {
+						$xml .= &quot; &lt;$schemaPrefix:import location=\&quot;&quot; . $ii['location'] . '&quot; namespace=&quot;' . $ns . &quot;\&quot; /&gt;\n&quot;;
+					} else {
+						$xml .= &quot; &lt;$schemaPrefix:import namespace=\&quot;&quot; . $ns . &quot;\&quot; /&gt;\n&quot;;
+					}
+				}
+			} 
+		} 
+		// complex types
+		foreach($this-&gt;complexTypes as $typeName =&gt; $attrs){
+			$contentStr = '';
+			// serialize child elements
+			if(isset($attrs['elements']) &amp;&amp; (count($attrs['elements']) &gt; 0)){
+				foreach($attrs['elements'] as $element =&gt; $eParts){
+					if(isset($eParts['ref'])){
+						$contentStr .= &quot;   &lt;$schemaPrefix:element ref=\&quot;$element\&quot;/&gt;\n&quot;;
+					} else {
+						$contentStr .= &quot;   &lt;$schemaPrefix:element name=\&quot;$element\&quot; type=\&quot;&quot; . $this-&gt;contractQName($eParts['type']) . &quot;\&quot;&quot;;
+						foreach ($eParts as $aName =&gt; $aValue) {
+							// handle, e.g., abstract, default, form, minOccurs, maxOccurs, nillable
+							if ($aName != 'name' &amp;&amp; $aName != 'type') {
+								$contentStr .= &quot; $aName=\&quot;$aValue\&quot;&quot;;
+							}
+						}
+						$contentStr .= &quot;/&gt;\n&quot;;
+					}
+				}
+				// compositor wraps elements
+				if (isset($attrs['compositor']) &amp;&amp; ($attrs['compositor'] != '')) {
+					$contentStr = &quot;  &lt;$schemaPrefix:$attrs[compositor]&gt;\n&quot;.$contentStr.&quot;  &lt;/$schemaPrefix:$attrs[compositor]&gt;\n&quot;;
+				}
+			}
+			// attributes
+			if(isset($attrs['attrs']) &amp;&amp; (count($attrs['attrs']) &gt;= 1)){
+				foreach($attrs['attrs'] as $attr =&gt; $aParts){
+					$contentStr .= &quot;    &lt;$schemaPrefix:attribute&quot;;
+					foreach ($aParts as $a =&gt; $v) {
+						if ($a == 'ref' || $a == 'type') {
+							$contentStr .= &quot; $a=\&quot;&quot;.$this-&gt;contractQName($v).'&quot;';
+						} elseif ($a == '<A HREF="http://schemas.xmlsoap.org/wsdl/:arrayType">http://schemas.xmlsoap.org/wsdl/:arrayType</A>') {
+							$this-&gt;usedNamespaces['wsdl'] = $this-&gt;namespaces['wsdl'];
+							$contentStr .= ' wsdl:arrayType=&quot;'.$this-&gt;contractQName($v).'&quot;';
+						} else {
+							$contentStr .= &quot; $a=\&quot;$v\&quot;&quot;;
+						}
+					}
+					$contentStr .= &quot;/&gt;\n&quot;;
+				}
+			}
+			// if restriction
+			if (isset($attrs['restrictionBase']) &amp;&amp; $attrs['restrictionBase'] != ''){
+				$contentStr = &quot;   &lt;$schemaPrefix:restriction base=\&quot;&quot;.$this-&gt;contractQName($attrs['restrictionBase']).&quot;\&quot;&gt;\n&quot;.$contentStr.&quot;   &lt;/$schemaPrefix:restriction&gt;\n&quot;;
+				// complex or simple content
+				if ((isset($attrs['elements']) &amp;&amp; count($attrs['elements']) &gt; 0) || (isset($attrs['attrs']) &amp;&amp; count($attrs['attrs']) &gt; 0)){
+					$contentStr = &quot;  &lt;$schemaPrefix:complexContent&gt;\n&quot;.$contentStr.&quot;  &lt;/$schemaPrefix:complexContent&gt;\n&quot;;
+				}
+			}
+			// finalize complex type
+			if($contentStr != ''){
+				$contentStr = &quot; &lt;$schemaPrefix:complexType name=\&quot;$typeName\&quot;&gt;\n&quot;.$contentStr.&quot; &lt;/$schemaPrefix:complexType&gt;\n&quot;;
+			} else {
+				$contentStr = &quot; &lt;$schemaPrefix:complexType name=\&quot;$typeName\&quot;/&gt;\n&quot;;
+			}
+			$xml .= $contentStr;
+		}
+		// simple types
+		if(isset($this-&gt;simpleTypes) &amp;&amp; count($this-&gt;simpleTypes) &gt; 0){
+			foreach($this-&gt;simpleTypes as $typeName =&gt; $eParts){
+				$xml .= &quot; &lt;$schemaPrefix:simpleType name=\&quot;$typeName\&quot;&gt;\n  &lt;$schemaPrefix:restriction base=\&quot;&quot;.$this-&gt;contractQName($eParts['type']).&quot;\&quot;/&gt;\n&quot;;
+				if (isset($eParts['enumeration'])) {
+					foreach ($eParts['enumeration'] as $e) {
+						$xml .= &quot;  &lt;$schemaPrefix:enumeration value=\&quot;$e\&quot;/&gt;\n&quot;;
+					}
+				}
+				$xml .= &quot; &lt;/$schemaPrefix:simpleType&gt;&quot;;
+			}
+		}
+		// elements
+		if(isset($this-&gt;elements) &amp;&amp; count($this-&gt;elements) &gt; 0){
+			foreach($this-&gt;elements as $element =&gt; $eParts){
+				$xml .= &quot; &lt;$schemaPrefix:element name=\&quot;$element\&quot; type=\&quot;&quot;.$this-&gt;contractQName($eParts['type']).&quot;\&quot;/&gt;\n&quot;;
+			}
+		}
+		// attributes
+		if(isset($this-&gt;attributes) &amp;&amp; count($this-&gt;attributes) &gt; 0){
+			foreach($this-&gt;attributes as $attr =&gt; $aParts){
+				$xml .= &quot; &lt;$schemaPrefix:attribute name=\&quot;$attr\&quot; type=\&quot;&quot;.$this-&gt;contractQName($aParts['type']).&quot;\&quot;\n/&gt;&quot;;
+			}
+		}
+		// finish 'er up
+		$el = &quot;&lt;$schemaPrefix:schema targetNamespace=\&quot;$this-&gt;schemaTargetNamespace\&quot;\n&quot;;
+		foreach (array_diff($this-&gt;usedNamespaces, $this-&gt;enclosingNamespaces) as $nsp =&gt; $ns) {
+			$el .= &quot; xmlns:$nsp=\&quot;$ns\&quot;\n&quot;;
+		}
+		$xml = $el . &quot;&gt;\n&quot;.$xml.&quot;&lt;/$schemaPrefix:schema&gt;\n&quot;;
+		return $xml;
+	}
+
+	/**
+	* adds debug data to the clas level debug string
+	*
+	* @param    string $string debug data
+	* @access   private
+	*/
+	function xdebug($string){
+		$this-&gt;debug('&lt;' . $this-&gt;schemaTargetNamespace . '&gt; '.$string);
+	}
+
+    /**
+    * get the PHP type of a user defined type in the schema
+    * PHP type is kind of a misnomer since it actually returns 'struct' for assoc. arrays
+    * returns false if no type exists, or not w/ the given namespace
+    * else returns a string that is either a native php type, or 'struct'
+    *
+    * @param string $type, name of defined type
+    * @param string $ns, namespace of type
+    * @return mixed
+    * @access public
+    * @deprecated
+    */
+	function getPHPType($type,$ns){
+		if(isset($this-&gt;typemap[$ns][$type])){
+			//print &quot;found type '$type' and ns $ns in typemap&lt;br&gt;&quot;;
+			return $this-&gt;typemap[$ns][$type];
+		} elseif(isset($this-&gt;complexTypes[$type])){
+			//print &quot;getting type '$type' and ns $ns from complexTypes array&lt;br&gt;&quot;;
+			return $this-&gt;complexTypes[$type]['phpType'];
+		}
+		return false;
+	}
+
+	/**
+    * returns an associative array of information about a given type
+    * returns false if no type exists by the given name
+    *
+	*	For a complexType typeDef = array(
+	*	'restrictionBase' =&gt; '',
+	*	'phpType' =&gt; '',
+	*	'compositor' =&gt; '(sequence|all)',
+	*	'elements' =&gt; array(), // refs to elements array
+	*	'attrs' =&gt; array() // refs to attributes array
+	*	... and so on (see addComplexType)
+	*	)
+	*
+	*   For simpleType or element, the array has different keys.
+    *
+    * @param string
+    * @return mixed
+    * @access public
+    * @see addComplexType
+    * @see addSimpleType
+    * @see addElement
+    */
+	function getTypeDef($type){
+		//$this-&gt;debug(&quot;in getTypeDef for type $type&quot;);
+		if(isset($this-&gt;complexTypes[$type])){
+			$this-&gt;xdebug(&quot;in getTypeDef, found complexType $type&quot;);
+			return $this-&gt;complexTypes[$type];
+		} elseif(isset($this-&gt;simpleTypes[$type])){
+			$this-&gt;xdebug(&quot;in getTypeDef, found simpleType $type&quot;);
+			if (!isset($this-&gt;simpleTypes[$type]['phpType'])) {
+				// get info for type to tack onto the simple type
+				// TODO: can this ever really apply (i.e. what is a simpleType really?)
+				$uqType = substr($this-&gt;simpleTypes[$type]['type'], strrpos($this-&gt;simpleTypes[$type]['type'], ':') + 1);
+				$ns = substr($this-&gt;simpleTypes[$type]['type'], 0, strrpos($this-&gt;simpleTypes[$type]['type'], ':'));
+				$etype = $this-&gt;getTypeDef($uqType);
+				if ($etype) {
+					$this-&gt;xdebug(&quot;in getTypeDef, found type for simpleType $type:&quot;);
+					$this-&gt;xdebug($this-&gt;varDump($etype));
+					if (isset($etype['phpType'])) {
+						$this-&gt;simpleTypes[$type]['phpType'] = $etype['phpType'];
+					}
+					if (isset($etype['elements'])) {
+						$this-&gt;simpleTypes[$type]['elements'] = $etype['elements'];
+					}
+				}
+			}
+			return $this-&gt;simpleTypes[$type];
+		} elseif(isset($this-&gt;elements[$type])){
+			$this-&gt;xdebug(&quot;in getTypeDef, found element $type&quot;);
+			if (!isset($this-&gt;elements[$type]['phpType'])) {
+				// get info for type to tack onto the element
+				$uqType = substr($this-&gt;elements[$type]['type'], strrpos($this-&gt;elements[$type]['type'], ':') + 1);
+				$ns = substr($this-&gt;elements[$type]['type'], 0, strrpos($this-&gt;elements[$type]['type'], ':'));
+				$etype = $this-&gt;getTypeDef($uqType);
+				if ($etype) {
+					$this-&gt;xdebug(&quot;in getTypeDef, found type for element $type:&quot;);
+					$this-&gt;xdebug($this-&gt;varDump($etype));
+					if (isset($etype['phpType'])) {
+						$this-&gt;elements[$type]['phpType'] = $etype['phpType'];
+					}
+					if (isset($etype['elements'])) {
+						$this-&gt;elements[$type]['elements'] = $etype['elements'];
+					}
+				} elseif ($ns == '<A HREF="http://www.w3.org/2001/XMLSchema">http://www.w3.org/2001/XMLSchema</A>') {
+					$this-&gt;xdebug(&quot;in getTypeDef, element $type is an XSD type&quot;);
+					$this-&gt;elements[$type]['phpType'] = 'scalar';
+				}
+			}
+			return $this-&gt;elements[$type];
+		} elseif(isset($this-&gt;attributes[$type])){
+			$this-&gt;xdebug(&quot;in getTypeDef, found attribute $type&quot;);
+			return $this-&gt;attributes[$type];
+		} elseif (ereg('_ContainedType$', $type)) {
+			$this-&gt;xdebug(&quot;in getTypeDef, have an untyped element $type&quot;);
+			$typeDef['typeClass'] = 'simpleType';
+			$typeDef['phpType'] = 'scalar';
+			$typeDef['type'] = '<A HREF="http://www.w3.org/2001/XMLSchema:string">http://www.w3.org/2001/XMLSchema:string</A>';
+			return $typeDef;
+		}
+		$this-&gt;xdebug(&quot;in getTypeDef, did not find $type&quot;);
+		return false;
+	}
+
+	/**
+    * returns a sample serialization of a given type, or false if no type by the given name
+    *
+    * @param string $type, name of type
+    * @return mixed
+    * @access public
+    * @deprecated
+    */
+    function serializeTypeDef($type){
+    	//print &quot;in sTD() for type $type&lt;br&gt;&quot;;
+	if($typeDef = $this-&gt;getTypeDef($type)){
+		$str .= '&lt;'.$type;
+	    if(is_array($typeDef['attrs'])){
+		foreach($attrs as $attName =&gt; $data){
+		    $str .= &quot; $attName=\&quot;{type = &quot;.$data['type'].&quot;}\&quot;&quot;;
+		}
+	    }
+	    $str .= &quot; xmlns=\&quot;&quot;.$this-&gt;schema['targetNamespace'].&quot;\&quot;&quot;;
+	    if(count($typeDef['elements']) &gt; 0){
+		$str .= &quot;&gt;&quot;;
+		foreach($typeDef['elements'] as $element =&gt; $eData){
+		    $str .= $this-&gt;serializeTypeDef($element);
+		}
+		$str .= &quot;&lt;/$type&gt;&quot;;
+	    } elseif($typeDef['typeClass'] == 'element') {
+		$str .= &quot;&gt;&lt;/$type&gt;&quot;;
+	    } else {
+		$str .= &quot;/&gt;&quot;;
+	    }
+			return $str;
+	}
+    	return false;
+    }
+
+    /**
+    * returns HTML form elements that allow a user
+    * to enter values for creating an instance of the given type.
+    *
+    * @param string $name, name for type instance
+    * @param string $type, name of type
+    * @return string
+    * @access public
+    * @deprecated
+	*/
+	function typeToForm($name,$type){
+		// get typedef
+		if($typeDef = $this-&gt;getTypeDef($type)){
+			// if struct
+			if($typeDef['phpType'] == 'struct'){
+				$buffer .= '&lt;table&gt;';
+				foreach($typeDef['elements'] as $child =&gt; $childDef){
+					$buffer .= &quot;
+					&lt;tr&gt;&lt;td align='right'&gt;$childDef[name] (type: &quot;.$this-&gt;getLocalPart($childDef['type']).&quot;):&lt;/td&gt;
+					&lt;td&gt;&lt;input type='text' name='parameters[&quot;.$name.&quot;][$childDef[name]]'&gt;&lt;/td&gt;&lt;/tr&gt;&quot;;
+				}
+				$buffer .= '&lt;/table&gt;';
+			// if array
+			} elseif($typeDef['phpType'] == 'array'){
+				$buffer .= '&lt;table&gt;';
+				for($i=0;$i &lt; 3; $i++){
+					$buffer .= &quot;
+					&lt;tr&gt;&lt;td align='right'&gt;array item (type: $typeDef[arrayType]):&lt;/td&gt;
+					&lt;td&gt;&lt;input type='text' name='parameters[&quot;.$name.&quot;][]'&gt;&lt;/td&gt;&lt;/tr&gt;&quot;;
+				}
+				$buffer .= '&lt;/table&gt;';
+			// if scalar
+			} else {
+				$buffer .= &quot;&lt;input type='text' name='parameters[$name]'&gt;&quot;;
+			}
+		} else {
+			$buffer .= &quot;&lt;input type='text' name='parameters[$name]'&gt;&quot;;
+		}
+		return $buffer;
+	}
+	
+	/**
+	* adds a complex type to the schema
+	* 
+	* example: array
+	* 
+	* addType(
+	* 	'ArrayOfstring',
+	* 	'complexType',
+	* 	'array',
+	* 	'',
+	* 	'SOAP-ENC:Array',
+	* 	array('ref'=&gt;'SOAP-ENC:arrayType','wsdl:arrayType'=&gt;'string[]'),
+	* 	'xsd:string'
+	* );
+	* 
+	* example: PHP associative array ( SOAP Struct )
+	* 
+	* addType(
+	* 	'SOAPStruct',
+	* 	'complexType',
+	* 	'struct',
+	* 	'all',
+	* 	array('myVar'=&gt; array('name'=&gt;'myVar','type'=&gt;'string')
+	* );
+	* 
+	* @param name
+	* @param typeClass (complexType|simpleType|attribute)
+	* @param phpType: currently supported are array and struct (php assoc array)
+	* @param compositor (all|sequence|choice)
+	* @param restrictionBase namespace:name (<A HREF="http://schemas.xmlsoap.org/soap/encoding/:Array">http://schemas.xmlsoap.org/soap/encoding/:Array</A>)
+	* @param elements = array ( name = array(name=&gt;'',type=&gt;'') )
+	* @param attrs = array(
+	* 	array(
+	*		'ref' =&gt; &quot;<A HREF="http://schemas.xmlsoap.org/soap/encoding/:arrayType">http://schemas.xmlsoap.org/soap/encoding/:arrayType</A>&quot;,
+	*		&quot;<A HREF="http://schemas.xmlsoap.org/wsdl/:arrayType">http://schemas.xmlsoap.org/wsdl/:arrayType</A>&quot; =&gt; &quot;string[]&quot;
+	* 	)
+	* )
+	* @param arrayType: namespace:name (<A HREF="http://www.w3.org/2001/XMLSchema:string">http://www.w3.org/2001/XMLSchema:string</A>)
+	* @access public
+	* @see getTypeDef
+	*/
+	function addComplexType($name,$typeClass='complexType',$phpType='array',$compositor='',$restrictionBase='',$elements=array(),$attrs=array(),$arrayType=''){
+		$this-&gt;complexTypes[$name] = array(
+	    'name'		=&gt; $name,
+	    'typeClass'	=&gt; $typeClass,
+	    'phpType'	=&gt; $phpType,
+		'compositor'=&gt; $compositor,
+	    'restrictionBase' =&gt; $restrictionBase,
+		'elements'	=&gt; $elements,
+	    'attrs'		=&gt; $attrs,
+	    'arrayType'	=&gt; $arrayType
+		);
+		
+		$this-&gt;xdebug(&quot;addComplexType $name:&quot;);
+		$this-&gt;appendDebug($this-&gt;varDump($this-&gt;complexTypes[$name]));
+	}
+	
+	/**
+	* adds a simple type to the schema
+	*
+	* @param string $name
+	* @param string $restrictionBase namespace:name (<A HREF="http://schemas.xmlsoap.org/soap/encoding/:Array">http://schemas.xmlsoap.org/soap/encoding/:Array</A>)
+	* @param string $typeClass (should always be simpleType)
+	* @param string $phpType (should always be scalar)
+	* @param array $enumeration array of values
+	* @access public
+	* @see xmlschema
+	* @see getTypeDef
+	*/
+	function addSimpleType($name, $restrictionBase='', $typeClass='simpleType', $phpType='scalar', $enumeration=array()) {
+		$this-&gt;simpleTypes[$name] = array(
+	    'name'			=&gt; $name,
+	    'typeClass'		=&gt; $typeClass,
+	    'phpType'		=&gt; $phpType,
+	    'type'			=&gt; $restrictionBase,
+	    'enumeration'	=&gt; $enumeration
+		);
+		
+		$this-&gt;xdebug(&quot;addSimpleType $name:&quot;);
+		$this-&gt;appendDebug($this-&gt;varDump($this-&gt;simpleTypes[$name]));
+	}
+
+	/**
+	* adds an element to the schema
+	*
+	* @param array $attrs attributes that must include name and type
+	* @see xmlschema
+	* @access public
+	*/
+	function addElement($attrs) {
+		if (! $this-&gt;getPrefix($attrs['type'])) {
+			$attrs['type'] = $this-&gt;schemaTargetNamespace . ':' . $attrs['type'];
+		}
+		$this-&gt;elements[ $attrs['name'] ] = $attrs;
+		$this-&gt;elements[ $attrs['name'] ]['typeClass'] = 'element';
+		
+		$this-&gt;xdebug(&quot;addElement &quot; . $attrs['name']);
+		$this-&gt;appendDebug($this-&gt;varDump($this-&gt;elements[ $attrs['name'] ]));
+	}
+}
+
+
+
+
+?&gt;
\ No newline at end of file

Added: cms/trunk/includes/nusoap/nusoap.php
===================================================================
--- cms/trunk/includes/nusoap/nusoap.php	2005-09-20 21:46:50 UTC (rev 136)
+++ cms/trunk/includes/nusoap/nusoap.php	2005-09-21 03:53:30 UTC (rev 137)
@@ -0,0 +1,7241 @@
+&lt;?php
+
+/*
+$Id: nusoap.php,v 1.94 2005/08/04 01:27:42 snichol Exp $
+
+NuSOAP - Web Services Toolkit for PHP
+
+Copyright (c) 2002 NuSphere Corporation
+
+This library is free software; you can redistribute it and/or
+modify it under the terms of the GNU Lesser General Public
+License as published by the Free Software Foundation; either
+version 2.1 of the License, or (at your option) any later version.
+
+This library is distributed in the hope that it will be useful,
+but WITHOUT ANY WARRANTY; without even the implied warranty of
+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+Lesser General Public License for more details.
+
+You should have received a copy of the GNU Lesser General Public
+License along with this library; if not, write to the Free Software
+Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
+
+If you have any questions or comments, please email:
+
+Dietrich Ayala
<A HREF="https://lists.berlios.de/mailman/listinfo/viperals-svncheckins">+dietrich at ganx4.com</A>
+<A HREF="http://dietrich.ganx4.com/nusoap">http://dietrich.ganx4.com/nusoap</A>
+
+NuSphere Corporation
+<A HREF="http://www.nusphere.com">http://www.nusphere.com</A>
+
+*/
+
+/* load classes
+
+// necessary classes
+require_once('class.soapclient.php');
+require_once('class.soap_val.php');
+require_once('class.soap_parser.php');
+require_once('class.soap_fault.php');
+
+// transport classes
+require_once('class.soap_transport_http.php');
+
+// optional add-on classes
+require_once('class.xmlschema.php');
+require_once('class.wsdl.php');
+
+// server class
+require_once('class.soap_server.php');*/
+
+// class variable emulation
+// cf. <A HREF="http://www.webkreator.com/php/techniques/php-static-class-variables.html">http://www.webkreator.com/php/techniques/php-static-class-variables.html</A>
+$GLOBALS['_transient']['static']['nusoap_base']-&gt;globalDebugLevel = 9;
+
+/**
+*
+* nusoap_base
+*
+* @author   Dietrich Ayala &lt;<A HREF="https://lists.berlios.de/mailman/listinfo/viperals-svncheckins">dietrich at ganx4.com</A>&gt;
+* @version  $Id: nusoap.php,v 1.94 2005/08/04 01:27:42 snichol Exp $
+* @access   public
+*/
+class nusoap_base {
+	/**
+	 * Identification for HTTP headers.
+	 *
+	 * @var string
+	 * @access private
+	 */
+	var $title = 'NuSOAP';
+	/**
+	 * Version for HTTP headers.
+	 *
+	 * @var string
+	 * @access private
+	 */
+	var $version = '0.7.2';
+	/**
+	 * CVS revision for HTTP headers.
+	 *
+	 * @var string
+	 * @access private
+	 */
+	var $revision = '$Revision: 1.94 $';
+    /**
+     * Current error string (manipulated by getError/setError)
+	 *
+	 * @var string
+	 * @access private
+	 */
+	var $error_str = '';
+    /**
+     * Current debug string (manipulated by debug/appendDebug/clearDebug/getDebug/getDebugAsXMLComment)
+	 *
+	 * @var string
+	 * @access private
+	 */
+    var $debug_str = '';
+    /**
+	 * toggles automatic encoding of special characters as entities
+	 * (should always be true, I think)
+	 *
+	 * @var boolean
+	 * @access private
+	 */
+	var $charencoding = true;
+	/**
+	 * the debug level for this instance
+	 *
+	 * @var	integer
+	 * @access private
+	 */
+	var $debugLevel;
+
+    /**
+	* set schema version
+	*
+	* @var      string
+	* @access   public
+	*/
+	var $XMLSchemaVersion = '<A HREF="http://www.w3.org/2001/XMLSchema">http://www.w3.org/2001/XMLSchema</A>';
+	
+    /**
+	* charset encoding for outgoing messages
+	*
+	* @var      string
+	* @access   public
+	*/
+    var $soap_defencoding = 'ISO-8859-1';
+	//var $soap_defencoding = 'UTF-8';
+
+	/**
+	* namespaces in an array of prefix =&gt; uri
+	*
+	* this is &quot;seeded&quot; by a set of constants, but it may be altered by code
+	*
+	* @var      array
+	* @access   public
+	*/
+	var $namespaces = array(
+		'SOAP-ENV' =&gt; '<A HREF="http://schemas.xmlsoap.org/soap/envelope/">http://schemas.xmlsoap.org/soap/envelope/</A>',
+		'xsd' =&gt; '<A HREF="http://www.w3.org/2001/XMLSchema">http://www.w3.org/2001/XMLSchema</A>',
+		'xsi' =&gt; '<A HREF="http://www.w3.org/2001/XMLSchema-instance">http://www.w3.org/2001/XMLSchema-instance</A>',
+		'SOAP-ENC' =&gt; '<A HREF="http://schemas.xmlsoap.org/soap/encoding/">http://schemas.xmlsoap.org/soap/encoding/</A>'
+		);
+
+	/**
+	* namespaces used in the current context, e.g. during serialization
+	*
+	* @var      array
+	* @access   private
+	*/
+	var $usedNamespaces = array();
+
+	/**
+	* XML Schema types in an array of uri =&gt; (array of xml type =&gt; php type)
+	* is this legacy yet?
+	* no, this is used by the xmlschema class to verify type =&gt; namespace mappings.
+	* @var      array
+	* @access   public
+	*/
+	var $typemap = array(
+	'<A HREF="http://www.w3.org/2001/XMLSchema">http://www.w3.org/2001/XMLSchema</A>' =&gt; array(
+		'string'=&gt;'string','boolean'=&gt;'boolean','float'=&gt;'double','double'=&gt;'double','decimal'=&gt;'double',
+		'duration'=&gt;'','dateTime'=&gt;'string','time'=&gt;'string','date'=&gt;'string','gYearMonth'=&gt;'',
+		'gYear'=&gt;'','gMonthDay'=&gt;'','gDay'=&gt;'','gMonth'=&gt;'','hexBinary'=&gt;'string','base64Binary'=&gt;'string',
+		// abstract &quot;any&quot; types
+		'anyType'=&gt;'string','anySimpleType'=&gt;'string',
+		// derived datatypes
+		'normalizedString'=&gt;'string','token'=&gt;'string','language'=&gt;'','NMTOKEN'=&gt;'','NMTOKENS'=&gt;'','Name'=&gt;'','NCName'=&gt;'','ID'=&gt;'',
+		'IDREF'=&gt;'','IDREFS'=&gt;'','ENTITY'=&gt;'','ENTITIES'=&gt;'','integer'=&gt;'integer','nonPositiveInteger'=&gt;'integer',
+		'negativeInteger'=&gt;'integer','long'=&gt;'integer','int'=&gt;'integer','short'=&gt;'integer','byte'=&gt;'integer','nonNegativeInteger'=&gt;'integer',
+		'unsignedLong'=&gt;'','unsignedInt'=&gt;'','unsignedShort'=&gt;'','unsignedByte'=&gt;'','positiveInteger'=&gt;''),
+	'<A HREF="http://www.w3.org/2000/10/XMLSchema">http://www.w3.org/2000/10/XMLSchema</A>' =&gt; array(
+		'i4'=&gt;'','int'=&gt;'integer','boolean'=&gt;'boolean','string'=&gt;'string','double'=&gt;'double',
+		'float'=&gt;'double','dateTime'=&gt;'string',
+		'timeInstant'=&gt;'string','base64Binary'=&gt;'string','base64'=&gt;'string','ur-type'=&gt;'array'),
+	'<A HREF="http://www.w3.org/1999/XMLSchema">http://www.w3.org/1999/XMLSchema</A>' =&gt; array(
+		'i4'=&gt;'','int'=&gt;'integer','boolean'=&gt;'boolean','string'=&gt;'string','double'=&gt;'double',
+		'float'=&gt;'double','dateTime'=&gt;'string',
+		'timeInstant'=&gt;'string','base64Binary'=&gt;'string','base64'=&gt;'string','ur-type'=&gt;'array'),
+	'<A HREF="http://soapinterop.org/xsd">http://soapinterop.org/xsd</A>' =&gt; array('SOAPStruct'=&gt;'struct'),
+	'<A HREF="http://schemas.xmlsoap.org/soap/encoding/">http://schemas.xmlsoap.org/soap/encoding/</A>' =&gt; array('base64'=&gt;'string','array'=&gt;'array','Array'=&gt;'array'),
+    '<A HREF="http://xml.apache.org/xml-soap">http://xml.apache.org/xml-soap</A>' =&gt; array('Map')
+	);
+
+	/**
+	* XML entities to convert
+	*
+	* @var      array
+	* @access   public
+	* @deprecated
+	* @see	expandEntities
+	*/
+	var $xmlEntities = array('quot' =&gt; '&quot;','amp' =&gt; '&amp;',
+		'lt' =&gt; '&lt;','gt' =&gt; '&gt;','apos' =&gt; &quot;'&quot;);
+
+	/**
+	* constructor
+	*
+	* @access	public
+	*/
+	function nusoap_base() {
+		$this-&gt;debugLevel = $GLOBALS['_transient']['static']['nusoap_base']-&gt;globalDebugLevel;
+	}
+
+	/**
+	* gets the global debug level, which applies to future instances
+	*
+	* @return	integer	Debug level 0-9, where 0 turns off
+	* @access	public
+	*/
+	function getGlobalDebugLevel() {
+		return $GLOBALS['_transient']['static']['nusoap_base']-&gt;globalDebugLevel;
+	}
+
+	/**
+	* sets the global debug level, which applies to future instances
+	*
+	* @param	int	$level	Debug level 0-9, where 0 turns off
+	* @access	public
+	*/
+	function setGlobalDebugLevel($level) {
+		$GLOBALS['_transient']['static']['nusoap_base']-&gt;globalDebugLevel = $level;
+	}
+
+	/**
+	* gets the debug level for this instance
+	*
+	* @return	int	Debug level 0-9, where 0 turns off
+	* @access	public
+	*/
+	function getDebugLevel() {
+		return $this-&gt;debugLevel;
+	}
+
+	/**
+	* sets the debug level for this instance
+	*
+	* @param	int	$level	Debug level 0-9, where 0 turns off
+	* @access	public
+	*/
+	function setDebugLevel($level) {
+		$this-&gt;debugLevel = $level;
+	}
+
+	/**
+	* adds debug data to the instance debug string with formatting
+	*
+	* @param    string $string debug data
+	* @access   private
+	*/
+	function debug($string){
+		if ($this-&gt;debugLevel &gt; 0) {
+			$this-&gt;appendDebug($this-&gt;getmicrotime().' '.get_class($this).&quot;: $string\n&quot;);
+		}
+	}
+
+	/**
+	* adds debug data to the instance debug string without formatting
+	*
+	* @param    string $string debug data
+	* @access   public
+	*/
+	function appendDebug($string){
+		if ($this-&gt;debugLevel &gt; 0) {
+			// it would be nice to use a memory stream here to use
+			// memory more efficiently
+			$this-&gt;debug_str .= $string;
+		}
+	}
+
+	/**
+	* clears the current debug data for this instance
+	*
+	* @access   public
+	*/
+	function clearDebug() {
+		// it would be nice to use a memory stream here to use
+		// memory more efficiently
+		$this-&gt;debug_str = '';
+	}
+
+	/**
+	* gets the current debug data for this instance
+	*
+	* @return   debug data
+	* @access   public
+	*/
+	function &amp;getDebug() {
+		// it would be nice to use a memory stream here to use
+		// memory more efficiently
+		return $this-&gt;debug_str;
+	}
+
+	/**
+	* gets the current debug data for this instance as an XML comment
+	* this may change the contents of the debug data
+	*
+	* @return   debug data as an XML comment
+	* @access   public
+	*/
+	function &amp;getDebugAsXMLComment() {
+		// it would be nice to use a memory stream here to use
+		// memory more efficiently
+		while (strpos($this-&gt;debug_str, '--')) {
+			$this-&gt;debug_str = str_replace('--', '- -', $this-&gt;debug_str);
+		}
+    	return &quot;&lt;!--\n&quot; . $this-&gt;debug_str . &quot;\n--&gt;&quot;;
+	}
+
+	/**
+	* expands entities, e.g. changes '&lt;' to '&lt;'.
+	*
+	* @param	string	$val	The string in which to expand entities.
+	* @access	private
+	*/
+	function expandEntities($val) {
+		if ($this-&gt;charencoding) {
+	    	$val = str_replace('&amp;', '&amp;', $val);
+	    	$val = str_replace(&quot;'&quot;, '&apos;', $val);
+	    	$val = str_replace('&quot;', '&quot;', $val);
+	    	$val = str_replace('&lt;', '&lt;', $val);
+	    	$val = str_replace('&gt;', '&gt;', $val);
+	    }
+	    return $val;
+	}
+
+	/**
+	* returns error string if present
+	*
+	* @return   mixed error string or false
+	* @access   public
+	*/
+	function getError(){
+		if($this-&gt;error_str != ''){
+			return $this-&gt;error_str;
+		}
+		return false;
+	}
+
+	/**
+	* sets error string
+	*
+	* @return   boolean $string error string
+	* @access   private
+	*/
+	function setError($str){
+		$this-&gt;error_str = $str;
+	}
+
+	/**
+	* detect if array is a simple array or a struct (associative array)
+	*
+	* @param	mixed	$val	The PHP array
+	* @return	string	(arraySimple|arrayStruct)
+	* @access	private
+	*/
+	function isArraySimpleOrStruct($val) {
+        $keyList = array_keys($val);
+		foreach ($keyList as $keyListValue) {
+			if (!is_int($keyListValue)) {
+				return 'arrayStruct';
+			}
+		}
+		return 'arraySimple';
+	}
+
+	/**
+	* serializes PHP values in accordance w/ section 5. Type information is
+	* not serialized if $use == 'literal'.
+	*
+	* @param	mixed	$val	The value to serialize
+	* @param	string	$name	The name (local part) of the XML element
+	* @param	string	$type	The XML schema type (local part) for the element
+	* @param	string	$name_ns	The namespace for the name of the XML element
+	* @param	string	$type_ns	The namespace for the type of the element
+	* @param	array	$attributes	The attributes to serialize as name=&gt;value pairs
+	* @param	string	$use	The WSDL &quot;use&quot; (encoded|literal)
+	* @return	string	The serialized element, possibly with child elements
+    * @access	public
+	*/
+	function serialize_val($val,$name=false,$type=false,$name_ns=false,$type_ns=false,$attributes=false,$use='encoded'){
+		$this-&gt;debug(&quot;in serialize_val: name=$name, type=$type, name_ns=$name_ns, type_ns=$type_ns, use=$use&quot;);
+		$this-&gt;appendDebug('value=' . $this-&gt;varDump($val));
+		$this-&gt;appendDebug('attributes=' . $this-&gt;varDump($attributes));
+		
+    	if(is_object($val) &amp;&amp; get_class($val) == 'soapval'){
+        	return $val-&gt;serialize($use);
+        }
+		// force valid name if necessary
+		if (is_numeric($name)) {
+			$name = '__numeric_' . $name;
+		} elseif (! $name) {
+			$name = 'noname';
+		}
+		// if name has ns, add ns prefix to name
+		$xmlns = '';
+        if($name_ns){
+			$prefix = 'nu'.rand(1000,9999);
+			$name = $prefix.':'.$name;
+			$xmlns .= &quot; xmlns:$prefix=\&quot;$name_ns\&quot;&quot;;
+		}
+		// if type is prefixed, create type prefix
+		if($type_ns != '' &amp;&amp; $type_ns == $this-&gt;namespaces['xsd']){
+			// need to fix this. shouldn't default to xsd if no ns specified
+		    // w/o checking against typemap
+			$type_prefix = 'xsd';
+		} elseif($type_ns){
+			$type_prefix = 'ns'.rand(1000,9999);
+			$xmlns .= &quot; xmlns:$type_prefix=\&quot;$type_ns\&quot;&quot;;
+		}
+		// serialize attributes if present
+		$atts = '';
+		if($attributes){
+			foreach($attributes as $k =&gt; $v){
+				$atts .= &quot; $k=\&quot;&quot;.$this-&gt;expandEntities($v).'&quot;';
+			}
+		}
+		// serialize null value
+		if (is_null($val)) {
+			if ($use == 'literal') {
+				// TODO: depends on minOccurs
+	        	return &quot;&lt;$name$xmlns $atts/&gt;&quot;;
+        	} else {
+				if (isset($type) &amp;&amp; isset($type_prefix)) {
+					$type_str = &quot; xsi:type=\&quot;$type_prefix:$type\&quot;&quot;;
+				} else {
+					$type_str = '';
+				}
+	        	return &quot;&lt;$name$xmlns$type_str $atts xsi:nil=\&quot;true\&quot;/&gt;&quot;;
+        	}
+		}
+        // serialize if an xsd built-in primitive type
+        if($type != '' &amp;&amp; isset($this-&gt;typemap[$this-&gt;XMLSchemaVersion][$type])){
+        	if (is_bool($val)) {
+        		if ($type == 'boolean') {
+	        		$val = $val ? 'true' : 'false';
+	        	} elseif (! $val) {
+	        		$val = 0;
+	        	}
+			} else if (is_string($val)) {
+				$val = $this-&gt;expandEntities($val);
+			}
+			if ($use == 'literal') {
+	        	return &quot;&lt;$name$xmlns $atts&gt;$val&lt;/$name&gt;&quot;;
+        	} else {
+	        	return &quot;&lt;$name$xmlns $atts xsi:type=\&quot;xsd:$type\&quot;&gt;$val&lt;/$name&gt;&quot;;
+        	}
+        }
+		// detect type and serialize
+		$xml = '';
+		switch(true) {
+			case (is_bool($val) || $type == 'boolean'):
+        		if ($type == 'boolean') {
+	        		$val = $val ? 'true' : 'false';
+	        	} elseif (! $val) {
+	        		$val = 0;
+	        	}
+				if ($use == 'literal') {
+					$xml .= &quot;&lt;$name$xmlns $atts&gt;$val&lt;/$name&gt;&quot;;
+				} else {
+					$xml .= &quot;&lt;$name$xmlns xsi:type=\&quot;xsd:boolean\&quot;$atts&gt;$val&lt;/$name&gt;&quot;;
+				}
+				break;
+			case (is_int($val) || is_long($val) || $type == 'int'):
+				if ($use == 'literal') {
+					$xml .= &quot;&lt;$name$xmlns $atts&gt;$val&lt;/$name&gt;&quot;;
+				} else {
+					$xml .= &quot;&lt;$name$xmlns xsi:type=\&quot;xsd:int\&quot;$atts&gt;$val&lt;/$name&gt;&quot;;
+				}
+				break;
+			case (is_float($val)|| is_double($val) || $type == 'float'):
+				if ($use == 'literal') {
+					$xml .= &quot;&lt;$name$xmlns $atts&gt;$val&lt;/$name&gt;&quot;;
+				} else {
+					$xml .= &quot;&lt;$name$xmlns xsi:type=\&quot;xsd:float\&quot;$atts&gt;$val&lt;/$name&gt;&quot;;
+				}
+				break;
+			case (is_string($val) || $type == 'string'):
+				$val = $this-&gt;expandEntities($val);
+				if ($use == 'literal') {
+					$xml .= &quot;&lt;$name$xmlns $atts&gt;$val&lt;/$name&gt;&quot;;
+				} else {
+					$xml .= &quot;&lt;$name$xmlns xsi:type=\&quot;xsd:string\&quot;$atts&gt;$val&lt;/$name&gt;&quot;;
+				}
+				break;
+			case is_object($val):
+				if (! $name) {
+					$name = get_class($val);
+					$this-&gt;debug(&quot;In serialize_val, used class name $name as element name&quot;);
+				} else {
+					$this-&gt;debug(&quot;In serialize_val, do not override name $name for element name for class &quot; . get_class($val));
+				}
+				foreach(get_object_vars($val) as $k =&gt; $v){
+					$pXml = isset($pXml) ? $pXml.$this-&gt;serialize_val($v,$k,false,false,false,false,$use) : $this-&gt;serialize_val($v,$k,false,false,false,false,$use);
+				}
+				$xml .= '&lt;'.$name.'&gt;'.$pXml.'&lt;/'.$name.'&gt;';
+				break;
+			break;
+			case (is_array($val) || $type):
+				// detect if struct or array
+				$valueType = $this-&gt;isArraySimpleOrStruct($val);
+                if($valueType=='arraySimple' || ereg('^ArrayOf',$type)){
+					$i = 0;
+					if(is_array($val) &amp;&amp; count($val)&gt; 0){
+						foreach($val as $v){
+	                    	if(is_object($v) &amp;&amp; get_class($v) ==  'soapval'){
+								$tt_ns = $v-&gt;type_ns;
+								$tt = $v-&gt;type;
+							} elseif (is_array($v)) {
+								$tt = $this-&gt;isArraySimpleOrStruct($v);
+							} else {
+								$tt = gettype($v);
+	                        }
+							$array_types[$tt] = 1;
+							// TODO: for literal, the name should be $name
+							$xml .= $this-&gt;serialize_val($v,'item',false,false,false,false,$use);
+							++$i;
+						}
+						if(count($array_types) &gt; 1){
+							$array_typename = 'xsd:anyType';
+						} elseif(isset($tt) &amp;&amp; isset($this-&gt;typemap[$this-&gt;XMLSchemaVersion][$tt])) {
+							if ($tt == 'integer') {
+								$tt = 'int';
+							}
+							$array_typename = 'xsd:'.$tt;
+						} elseif(isset($tt) &amp;&amp; $tt == 'arraySimple'){
+							$array_typename = 'SOAP-ENC:Array';
+						} elseif(isset($tt) &amp;&amp; $tt == 'arrayStruct'){
+							$array_typename = 'unnamed_struct_use_soapval';
+						} else {
+							// if type is prefixed, create type prefix
+							if ($tt_ns != '' &amp;&amp; $tt_ns == $this-&gt;namespaces['xsd']){
+								 $array_typename = 'xsd:' . $tt;
+							} elseif ($tt_ns) {
+								$tt_prefix = 'ns' . rand(1000, 9999);
+								$array_typename = &quot;$tt_prefix:$tt&quot;;
+								$xmlns .= &quot; xmlns:$tt_prefix=\&quot;$tt_ns\&quot;&quot;;
+							} else {
+								$array_typename = $tt;
+							}
+						}
+						$array_type = $i;
+						if ($use == 'literal') {
+							$type_str = '';
+						} else if (isset($type) &amp;&amp; isset($type_prefix)) {
+							$type_str = &quot; xsi:type=\&quot;$type_prefix:$type\&quot;&quot;;
+						} else {
+							$type_str = &quot; xsi:type=\&quot;SOAP-ENC:Array\&quot; SOAP-ENC:arrayType=\&quot;&quot;.$array_typename.&quot;[$array_type]\&quot;&quot;;
+						}
+					// empty array
+					} else {
+						if ($use == 'literal') {
+							$type_str = '';
+						} else if (isset($type) &amp;&amp; isset($type_prefix)) {
+							$type_str = &quot; xsi:type=\&quot;$type_prefix:$type\&quot;&quot;;
+						} else {
+							$type_str = &quot; xsi:type=\&quot;SOAP-ENC:Array\&quot; SOAP-ENC:arrayType=\&quot;xsd:anyType[0]\&quot;&quot;;
+						}
+					}
+					// TODO: for array in literal, there is no wrapper here
+					$xml = &quot;&lt;$name$xmlns$type_str$atts&gt;&quot;.$xml.&quot;&lt;/$name&gt;&quot;;
+				} else {
+					// got a struct
+					if(isset($type) &amp;&amp; isset($type_prefix)){
+						$type_str = &quot; xsi:type=\&quot;$type_prefix:$type\&quot;&quot;;
+					} else {
+						$type_str = '';
+					}
+					if ($use == 'literal') {
+						$xml .= &quot;&lt;$name$xmlns $atts&gt;&quot;;
+					} else {
+						$xml .= &quot;&lt;$name$xmlns$type_str$atts&gt;&quot;;
+					}
+					foreach($val as $k =&gt; $v){
+						// Apache Map
+						if ($type == 'Map' &amp;&amp; $type_ns == '<A HREF="http://xml.apache.org/xml-soap">http://xml.apache.org/xml-soap</A>') {
+							$xml .= '&lt;item&gt;';
+							$xml .= $this-&gt;serialize_val($k,'key',false,false,false,false,$use);
+							$xml .= $this-&gt;serialize_val($v,'value',false,false,false,false,$use);
+							$xml .= '&lt;/item&gt;';
+						} else {
+							$xml .= $this-&gt;serialize_val($v,$k,false,false,false,false,$use);
+						}
+					}
+					$xml .= &quot;&lt;/$name&gt;&quot;;
+				}
+				break;
+			default:
+				$xml .= 'not detected, got '.gettype($val).' for '.$val;
+				break;
+		}
+		return $xml;
+	}
+
+    /**
+    * serializes a message
+    *
+    * @param string $body the XML of the SOAP body
+    * @param mixed $headers optional string of XML with SOAP header content, or array of soapval objects for SOAP headers
+    * @param array $namespaces optional the namespaces used in generating the body and headers
+    * @param string $style optional (rpc|document)
+    * @param string $use optional (encoded|literal)
+    * @param string $encodingStyle optional (usually '<A HREF="http://schemas.xmlsoap.org/soap/encoding/">http://schemas.xmlsoap.org/soap/encoding/</A>' for encoded)
+    * @return string the message
+    * @access public
+    */
+    function serializeEnvelope($body,$headers=false,$namespaces=array(),$style='rpc',$use='encoded',$encodingStyle='<A HREF="http://schemas.xmlsoap.org/soap/encoding/">http://schemas.xmlsoap.org/soap/encoding/</A>'){
+    // TODO: add an option to automatically run utf8_encode on $body and $headers
+    // if $this-&gt;soap_defencoding is UTF-8.  Not doing this automatically allows
+    // one to send arbitrary UTF-8 characters, not just characters that map to ISO-8859-1
+
+	$this-&gt;debug(&quot;In serializeEnvelope length=&quot; . strlen($body) . &quot; body (max 1000 characters)=&quot; . substr($body, 0, 1000) . &quot; style=$style use=$use encodingStyle=$encodingStyle&quot;);
+	$this-&gt;debug(&quot;headers:&quot;);
+	$this-&gt;appendDebug($this-&gt;varDump($headers));
+	$this-&gt;debug(&quot;namespaces:&quot;);
+	$this-&gt;appendDebug($this-&gt;varDump($namespaces));
+
+	// serialize namespaces
+    $ns_string = '';
+	foreach(array_merge($this-&gt;namespaces,$namespaces) as $k =&gt; $v){
+		$ns_string .= &quot; xmlns:$k=\&quot;$v\&quot;&quot;;
+	}
+	if($encodingStyle) {
+		$ns_string = &quot; SOAP-ENV:encodingStyle=\&quot;$encodingStyle\&quot;$ns_string&quot;;
+	}
+
+	// serialize headers
+	if($headers){
+		if (is_array($headers)) {
+			$xml = '';
+			foreach ($headers as $header) {
+				$xml .= $this-&gt;serialize_val($header, false, false, false, false, false, $use);
+			}
+			$headers = $xml;
+			$this-&gt;debug(&quot;In serializeEnvelope, serialzied array of headers to $headers&quot;);
+		}
+		$headers = &quot;&lt;SOAP-ENV:Header&gt;&quot;.$headers.&quot;&lt;/SOAP-ENV:Header&gt;&quot;;
+	}
+	// serialize envelope
+	return
+	'&lt;?xml version=&quot;1.0&quot; encoding=&quot;'.$this-&gt;soap_defencoding .'&quot;?'.&quot;&gt;&quot;.
+	'&lt;SOAP-ENV:Envelope'.$ns_string.&quot;&gt;&quot;.
+	$headers.
+	&quot;&lt;SOAP-ENV:Body&gt;&quot;.
+		$body.
+	&quot;&lt;/SOAP-ENV:Body&gt;&quot;.
+	&quot;&lt;/SOAP-ENV:Envelope&gt;&quot;;
+    }
+
+	/**
+	 * formats a string to be inserted into an HTML stream
+	 *
+	 * @param string $str The string to format
+	 * @return string The formatted string
+	 * @access public
+	 * @deprecated
+	 */
+    function formatDump($str){
+		$str = htmlspecialchars($str);
+		return nl2br($str);
+    }
+
+	/**
+	* contracts (changes namespace to prefix) a qualified name
+	*
+	* @param    string $qname qname
+	* @return	string contracted qname
+	* @access   private
+	*/
+	function contractQname($qname){
+		// get element namespace
+		//$this-&gt;xdebug(&quot;Contract $qname&quot;);
+		if (strrpos($qname, ':')) {
+			// get unqualified name
+			$name = substr($qname, strrpos($qname, ':') + 1);
+			// get ns
+			$ns = substr($qname, 0, strrpos($qname, ':'));
+			$p = $this-&gt;getPrefixFromNamespace($ns);
+			if ($p) {
+				return $p . ':' . $name;
+			}
+			return $qname;
+		} else {
+			return $qname;
+		}
+	}
+
+	/**
+	* expands (changes prefix to namespace) a qualified name
+	*
+	* @param    string $string qname
+	* @return	string expanded qname
+	* @access   private
+	*/
+	function expandQname($qname){
+		// get element prefix
+		if(strpos($qname,':') &amp;&amp; !ereg('^<A HREF="http://">http://</A>',$qname)){
+			// get unqualified name
+			$name = substr(strstr($qname,':'),1);
+			// get ns prefix
+			$prefix = substr($qname,0,strpos($qname,':'));
+			if(isset($this-&gt;namespaces[$prefix])){
+				return $this-&gt;namespaces[$prefix].':'.$name;
+			} else {
+				return $qname;
+			}
+		} else {
+			return $qname;
+		}
+	}
+
+    /**
+    * returns the local part of a prefixed string
+    * returns the original string, if not prefixed
+    *
+    * @param string $str The prefixed string
+    * @return string The local part
+    * @access public
+    */
+	function getLocalPart($str){
+		if($sstr = strrchr($str,':')){
+			// get unqualified name
+			return substr( $sstr, 1 );
+		} else {
+			return $str;
+		}
+	}
+
+	/**
+    * returns the prefix part of a prefixed string
+    * returns false, if not prefixed
+    *
+    * @param string $str The prefixed string
+    * @return mixed The prefix or false if there is no prefix
+    * @access public
+    */
+	function getPrefix($str){
+		if($pos = strrpos($str,':')){
+			// get prefix
+			return substr($str,0,$pos);
+		}
+		return false;
+	}
+
+	/**
+    * pass it a prefix, it returns a namespace
+    *
+    * @param string $prefix The prefix
+    * @return mixed The namespace, false if no namespace has the specified prefix
+    * @access public
+    */
+	function getNamespaceFromPrefix($prefix){
+		if (isset($this-&gt;namespaces[$prefix])) {
+			return $this-&gt;namespaces[$prefix];
+		}
+		//$this-&gt;setError(&quot;No namespace registered for prefix '$prefix'&quot;);
+		return false;
+	}
+
+	/**
+    * returns the prefix for a given namespace (or prefix)
+    * or false if no prefixes registered for the given namespace
+    *
+    * @param string $ns The namespace
+    * @return mixed The prefix, false if the namespace has no prefixes
+    * @access public
+    */
+	function getPrefixFromNamespace($ns) {
+		foreach ($this-&gt;namespaces as $p =&gt; $n) {
+			if ($ns == $n || $ns == $p) {
+			    $this-&gt;usedNamespaces[$p] = $n;
+				return $p;
+			}
+		}
+		return false;
+	}
+
+	/**
+    * returns the time in ODBC canonical form with microseconds
+    *
+    * @return string The time in ODBC canonical form with microseconds
+    * @access public
+    */
+	function getmicrotime() {
+		if (function_exists('gettimeofday')) {
+			$tod = gettimeofday();
+			$sec = $tod['sec'];
+			$usec = $tod['usec'];
+		} else {
+			$sec = time();
+			$usec = 0;
+		}
+		return strftime('%Y-%m-%d %H:%M:%S', $sec) . '.' . sprintf('%06d', $usec);
+	}
+
+	/**
+	 * Returns a string with the output of var_dump
+	 *
+	 * @param mixed $data The variable to var_dump
+	 * @return string The output of var_dump
+	 * @access public
+	 */
+    function varDump($data) {
+		ob_start();
+		var_dump($data);
+		$ret_val = ob_get_contents();
+		ob_end_clean();
+		return $ret_val;
+	}
+}
+
+// XML Schema Datatype Helper Functions
+
+//xsd:dateTime helpers
+
+/**
+* convert unix timestamp to ISO 8601 compliant date string
+*
+* @param    string $timestamp Unix time stamp
+* @access   public
+*/
+function timestamp_to_iso8601($timestamp,$utc=true){
+	$datestr = date('Y-m-d\TH:i:sO',$timestamp);
+	if($utc){
+		$eregStr =
+		'([0-9]{4})-'.	// centuries &amp; years CCYY-
+		'([0-9]{2})-'.	// months MM-
+		'([0-9]{2})'.	// days DD
+		'T'.			// separator T
+		'([0-9]{2}):'.	// hours hh:
+		'([0-9]{2}):'.	// minutes mm:
+		'([0-9]{2})(\.[0-9]*)?'. // seconds ss.ss...
+		'(Z|[+\-][0-9]{2}:?[0-9]{2})?'; // Z to indicate UTC, -/+HH:MM:SS.SS... for local tz's
+
+		if(ereg($eregStr,$datestr,$regs)){
+			return sprintf('%04d-%02d-%02dT%02d:%02d:%02dZ',$regs[1],$regs[2],$regs[3],$regs[4],$regs[5],$regs[6]);
+		}
+		return false;
+	} else {
+		return $datestr;
+	}
+}
+
+/**
+* convert ISO 8601 compliant date string to unix timestamp
+*
+* @param    string $datestr ISO 8601 compliant date string
+* @access   public
+*/
+function iso8601_to_timestamp($datestr){
+	$eregStr =
+	'([0-9]{4})-'.	// centuries &amp; years CCYY-
+	'([0-9]{2})-'.	// months MM-
+	'([0-9]{2})'.	// days DD
+	'T'.			// separator T
+	'([0-9]{2}):'.	// hours hh:
+	'([0-9]{2}):'.	// minutes mm:
+	'([0-9]{2})(\.[0-9]+)?'. // seconds ss.ss...
+	'(Z|[+\-][0-9]{2}:?[0-9]{2})?'; // Z to indicate UTC, -/+HH:MM:SS.SS... for local tz's
+	if(ereg($eregStr,$datestr,$regs)){
+		// not utc
+		if($regs[8] != 'Z'){
+			$op = substr($regs[8],0,1);
+			$h = substr($regs[8],1,2);
+			$m = substr($regs[8],strlen($regs[8])-2,2);
+			if($op == '-'){
+				$regs[4] = $regs[4] + $h;
+				$regs[5] = $regs[5] + $m;
+			} elseif($op == '+'){
+				$regs[4] = $regs[4] - $h;
+				$regs[5] = $regs[5] - $m;
+			}
+		}
+		return strtotime(&quot;$regs[1]-$regs[2]-$regs[3] $regs[4]:$regs[5]:$regs[6]Z&quot;);
+	} else {
+		return false;
+	}
+}
+
+/**
+* sleeps some number of microseconds
+*
+* @param    string $usec the number of microseconds to sleep
+* @access   public
+* @deprecated
+*/
+function usleepWindows($usec)
+{
+	$start = gettimeofday();
+	
+	do
+	{
+		$stop = gettimeofday();
+		$timePassed = 1000000 * ($stop['sec'] - $start['sec'])
+		+ $stop['usec'] - $start['usec'];
+	}
+	while ($timePassed &lt; $usec);
+}
+
+?&gt;&lt;?php
+
+
+
+/**
+* Contains information for a SOAP fault.
+* Mainly used for returning faults from deployed functions
+* in a server instance.
+* @author   Dietrich Ayala &lt;<A HREF="https://lists.berlios.de/mailman/listinfo/viperals-svncheckins">dietrich at ganx4.com</A>&gt;
+* @version  $Id: nusoap.php,v 1.94 2005/08/04 01:27:42 snichol Exp $
+* @access public
+*/
+class soap_fault extends nusoap_base {
+	/**
+	 * The fault code (client|server)
+	 * @var string
+	 * @access private
+	 */
+	var $faultcode;
+	/**
+	 * The fault actor
+	 * @var string
+	 * @access private
+	 */
+	var $faultactor;
+	/**
+	 * The fault string, a description of the fault
+	 * @var string
+	 * @access private
+	 */
+	var $faultstring;
+	/**
+	 * The fault detail, typically a string or array of string
+	 * @var mixed
+	 * @access private
+	 */
+	var $faultdetail;
+
+	/**
+	* constructor
+    *
+    * @param string $faultcode (client | server)
+    * @param string $faultactor only used when msg routed between multiple actors
+    * @param string $faultstring human readable error message
+    * @param mixed $faultdetail detail, typically a string or array of string
+	*/
+	function soap_fault($faultcode,$faultactor='',$faultstring='',$faultdetail=''){
+		parent::nusoap_base();
+		$this-&gt;faultcode = $faultcode;
+		$this-&gt;faultactor = $faultactor;
+		$this-&gt;faultstring = $faultstring;
+		$this-&gt;faultdetail = $faultdetail;
+	}
+
+	/**
+	* serialize a fault
+	*
+	* @return	string	The serialization of the fault instance.
+	* @access   public
+	*/
+	function serialize(){
+		$ns_string = '';
+		foreach($this-&gt;namespaces as $k =&gt; $v){
+			$ns_string .= &quot;\n  xmlns:$k=\&quot;$v\&quot;&quot;;
+		}
+		$return_msg =
+			'&lt;?xml version=&quot;1.0&quot; encoding=&quot;'.$this-&gt;soap_defencoding.'&quot;?&gt;'.
+			'&lt;SOAP-ENV:Envelope SOAP-ENV:encodingStyle=&quot;<A HREF="http://schemas.xmlsoap.org/soap/encoding/">http://schemas.xmlsoap.org/soap/encoding/</A>&quot;'.$ns_string.&quot;&gt;\n&quot;.
+				'&lt;SOAP-ENV:Body&gt;'.
+				'&lt;SOAP-ENV:Fault&gt;'.
+					$this-&gt;serialize_val($this-&gt;faultcode, 'faultcode').
+					$this-&gt;serialize_val($this-&gt;faultactor, 'faultactor').
+					$this-&gt;serialize_val($this-&gt;faultstring, 'faultstring').
+					$this-&gt;serialize_val($this-&gt;faultdetail, 'detail').
+				'&lt;/SOAP-ENV:Fault&gt;'.
+				'&lt;/SOAP-ENV:Body&gt;'.
+			'&lt;/SOAP-ENV:Envelope&gt;';
+		return $return_msg;
+	}
+}
+
+
+
+?&gt;&lt;?php
+
+
+
+/**
+* parses an XML Schema, allows access to it's data, other utility methods
+* no validation... yet.
+* very experimental and limited. As is discussed on XML-DEV, I'm one of the people
+* that just doesn't have time to read the spec(s) thoroughly, and just have a couple of trusty
+* tutorials I refer to :)
+*
+* @author   Dietrich Ayala &lt;<A HREF="https://lists.berlios.de/mailman/listinfo/viperals-svncheckins">dietrich at ganx4.com</A>&gt;
+* @version  $Id: nusoap.php,v 1.94 2005/08/04 01:27:42 snichol Exp $
+* @access   public
+*/
+class XMLSchema extends nusoap_base  {
+	
+	// files
+	var $schema = '';
+	var $xml = '';
+	// namespaces
+	var $enclosingNamespaces;
+	// schema info
+	var $schemaInfo = array();
+	var $schemaTargetNamespace = '';
+	// types, elements, attributes defined by the schema
+	var $attributes = array();
+	var $complexTypes = array();
+	var $complexTypeStack = array();
+	var $currentComplexType = null;
+	var $elements = array();
+	var $elementStack = array();
+	var $currentElement = null;
+	var $simpleTypes = array();
+	var $simpleTypeStack = array();
+	var $currentSimpleType = null;
+	// imports
+	var $imports = array();
+	// parser vars
+	var $parser;
+	var $position = 0;
+	var $depth = 0;
+	var $depth_array = array();
+	var $message = array();
+	var $defaultNamespace = array();
+    
+	/**
+	* constructor
+	*
+	* @param    string $schema schema document URI
+	* @param    string $xml xml document URI
+	* @param	string $namespaces namespaces defined in enclosing XML
+	* @access   public
+	*/
+	function XMLSchema($schema='',$xml='',$namespaces=array()){
+		parent::nusoap_base();
+		$this-&gt;debug('xmlschema class instantiated, inside constructor');
+		// files
+		$this-&gt;schema = $schema;
+		$this-&gt;xml = $xml;
+
+		// namespaces
+		$this-&gt;enclosingNamespaces = $namespaces;
+		$this-&gt;namespaces = array_merge($this-&gt;namespaces, $namespaces);
+
+		// parse schema file
+		if($schema != ''){
+			$this-&gt;debug('initial schema file: '.$schema);
+			$this-&gt;parseFile($schema, 'schema');
+		}
+
+		// parse xml file
+		if($xml != ''){
+			$this-&gt;debug('initial xml file: '.$xml);
+			$this-&gt;parseFile($xml, 'xml');
+		}
+
+	}
+
+    /**
+    * parse an XML file
+    *
+    * @param string $xml, path/URL to XML file
+    * @param string $type, (schema | xml)
+	* @return boolean
+    * @access public
+    */
+	function parseFile($xml,$type){
+		// parse xml file
+		if($xml != &quot;&quot;){
+			$xmlStr = @join(&quot;&quot;<A HREF="https://lists.berlios.de/mailman/listinfo/viperals-svncheckins">, at file</A>($xml));
+			if($xmlStr == &quot;&quot;){
+				$msg = 'Error reading XML from '.$xml;
+				$this-&gt;setError($msg);
+				$this-&gt;debug($msg);
+			return false;
+			} else {
+				$this-&gt;debug(&quot;parsing $xml&quot;);
+				$this-&gt;parseString($xmlStr,$type);
+				$this-&gt;debug(&quot;done parsing $xml&quot;);
+			return true;
+			}
+		}
+		return false;
+	}
+
+	/**
+	* parse an XML string
+	*
+	* @param    string $xml path or URL
+    * @param string $type, (schema|xml)
+	* @access   private
+	*/
+	function parseString($xml,$type){
+		// parse xml string
+		if($xml != &quot;&quot;){
+
+	    	// Create an XML parser.
+	    	$this-&gt;parser = xml_parser_create();
+	    	// Set the options for parsing the XML data.
+	    	xml_parser_set_option($this-&gt;parser, XML_OPTION_CASE_FOLDING, 0);
+
+	    	// Set the object for the parser.
+	    	xml_set_object($this-&gt;parser, $this);
+
+	    	// Set the element handlers for the parser.
+			if($type == &quot;schema&quot;){
+		    	xml_set_element_handler($this-&gt;parser, 'schemaStartElement','schemaEndElement');
+		    	xml_set_character_data_handler($this-&gt;parser,'schemaCharacterData');
+			} elseif($type == &quot;xml&quot;){
+				xml_set_element_handler($this-&gt;parser, 'xmlStartElement','xmlEndElement');
+		    	xml_set_character_data_handler($this-&gt;parser,'xmlCharacterData');
+			}
+
+		    // Parse the XML file.
+		    if(!xml_parse($this-&gt;parser,$xml,true)){
+			// Display an error message.
+				$errstr = sprintf('XML error parsing XML schema on line %d: %s',
+				xml_get_current_line_number($this-&gt;parser),
+				xml_error_string(xml_get_error_code($this-&gt;parser))
+				);
+				$this-&gt;debug($errstr);
+				$this-&gt;debug(&quot;XML payload:\n&quot; . $xml);
+				$this-&gt;setError($errstr);
+	    	}
+            
+			xml_parser_free($this-&gt;parser);
+		} else{
+			$this-&gt;debug('no xml passed to parseString()!!');
+			$this-&gt;setError('no xml passed to parseString()!!');
+		}
+	}
+
+	/**
+	* start-element handler
+	*
+	* @param    string $parser XML parser object
+	* @param    string $name element name
+	* @param    string $attrs associative array of attributes
+	* @access   private
+	*/
+	function schemaStartElement($parser, $name, $attrs) {
+		
+		// position in the total number of elements, starting from 0
+		$pos = $this-&gt;position++;
+		$depth = $this-&gt;depth++;
+		// set self as current value for this depth
+		$this-&gt;depth_array[$depth] = $pos;
+		$this-&gt;message[$pos] = array('cdata' =&gt; ''); 
+		if ($depth &gt; 0) {
+			$this-&gt;defaultNamespace[$pos] = $this-&gt;defaultNamespace[$this-&gt;depth_array[$depth - 1]];
+		} else {
+			$this-&gt;defaultNamespace[$pos] = false;
+		}
+
+		// get element prefix
+		if($prefix = $this-&gt;getPrefix($name)){
+			// get unqualified name
+			$name = $this-&gt;getLocalPart($name);
+		} else {
+        	$prefix = '';
+        }
+		
+        // loop thru attributes, expanding, and registering namespace declarations
+        if(count($attrs) &gt; 0){
+        	foreach($attrs as $k =&gt; $v){
+                // if ns declarations, add to class level array of valid namespaces
+				if(ereg(&quot;^xmlns&quot;,$k)){
+                	//$this-&gt;xdebug(&quot;$k: $v&quot;);
+                	//$this-&gt;xdebug('ns_prefix: '.$this-&gt;getPrefix($k));
+                	if($ns_prefix = substr(strrchr($k,':'),1)){
+                		//$this-&gt;xdebug(&quot;Add namespace[$ns_prefix] = $v&quot;);
+						$this-&gt;namespaces[$ns_prefix] = $v;
+					} else {
+						$this-&gt;defaultNamespace[$pos] = $v;
+						if (! $this-&gt;getPrefixFromNamespace($v)) {
+							$this-&gt;namespaces['ns'.(count($this-&gt;namespaces)+1)] = $v;
+						}
+					}
+					if($v == '<A HREF="http://www.w3.org/2001/XMLSchema">http://www.w3.org/2001/XMLSchema</A>' || $v == '<A HREF="http://www.w3.org/1999/XMLSchema">http://www.w3.org/1999/XMLSchema</A>' || $v == '<A HREF="http://www.w3.org/2000/10/XMLSchema">http://www.w3.org/2000/10/XMLSchema</A>'){
+						$this-&gt;XMLSchemaVersion = $v;
+						$this-&gt;namespaces['xsi'] = $v.'-instance';
+					}
+				}
+        	}
+        	foreach($attrs as $k =&gt; $v){
+                // expand each attribute
+                $k = strpos($k,':') ? $this-&gt;expandQname($k) : $k;
+                $v = strpos($v,':') ? $this-&gt;expandQname($v) : $v;
+        		$eAttrs[$k] = $v;
+        	}
+        	$attrs = $eAttrs;
+        } else {
+        	$attrs = array();
+        }
+		// find status, register data
+		switch($name){
+			case 'all':			// (optional) compositor content for a complexType
+			case 'choice':
+			case 'group':
+			case 'sequence':
+				//$this-&gt;xdebug(&quot;compositor $name for currentComplexType: $this-&gt;currentComplexType and currentElement: $this-&gt;currentElement&quot;);
+				$this-&gt;complexTypes[$this-&gt;currentComplexType]['compositor'] = $name;
+				//if($name == 'all' || $name == 'sequence'){
+				//	$this-&gt;complexTypes[$this-&gt;currentComplexType]['phpType'] = 'struct';
+				//}
+			break;
+			case 'attribute':	// complexType attribute
+            	//$this-&gt;xdebug(&quot;parsing attribute $attrs[name] $attrs[ref] of value: &quot;.$attrs['<A HREF="http://schemas.xmlsoap.org/wsdl/:arrayType">http://schemas.xmlsoap.org/wsdl/:arrayType</A>']);
+            	$this-&gt;xdebug(&quot;parsing attribute:&quot;);
+            	$this-&gt;appendDebug($this-&gt;varDump($attrs));
+				if (!isset($attrs['form'])) {
+					$attrs['form'] = $this-&gt;schemaInfo['attributeFormDefault'];
+				}
+            	if (isset($attrs['<A HREF="http://schemas.xmlsoap.org/wsdl/:arrayType">http://schemas.xmlsoap.org/wsdl/:arrayType</A>'])) {
+					$v = $attrs['<A HREF="http://schemas.xmlsoap.org/wsdl/:arrayType">http://schemas.xmlsoap.org/wsdl/:arrayType</A>'];
+					if (!strpos($v, ':')) {
+						// no namespace in arrayType attribute value...
+						if ($this-&gt;defaultNamespace[$pos]) {
+							// ...so use the default
+							$attrs['<A HREF="http://schemas.xmlsoap.org/wsdl/:arrayType">http://schemas.xmlsoap.org/wsdl/:arrayType</A>'] = $this-&gt;defaultNamespace[$pos] . ':' . $attrs['<A HREF="http://schemas.xmlsoap.org/wsdl/:arrayType">http://schemas.xmlsoap.org/wsdl/:arrayType</A>'];
+						}
+					}
+            	}
+                if(isset($attrs['name'])){
+					$this-&gt;attributes[$attrs['name']] = $attrs;
+					$aname = $attrs['name'];
+				} elseif(isset($attrs['ref']) &amp;&amp; $attrs['ref'] == '<A HREF="http://schemas.xmlsoap.org/soap/encoding/:arrayType">http://schemas.xmlsoap.org/soap/encoding/:arrayType</A>'){
+					if (isset($attrs['<A HREF="http://schemas.xmlsoap.org/wsdl/:arrayType">http://schemas.xmlsoap.org/wsdl/:arrayType</A>'])) {
+	                	$aname = $attrs['<A HREF="http://schemas.xmlsoap.org/wsdl/:arrayType">http://schemas.xmlsoap.org/wsdl/:arrayType</A>'];
+	                } else {
+	                	$aname = '';
+	                }
+				} elseif(isset($attrs['ref'])){
+					$aname = $attrs['ref'];
+                    $this-&gt;attributes[$attrs['ref']] = $attrs;
+				}
+                
+				if($this-&gt;currentComplexType){	// This should *always* be
+					$this-&gt;complexTypes[$this-&gt;currentComplexType]['attrs'][$aname] = $attrs;
+				}
+				// arrayType attribute
+				if(isset($attrs['<A HREF="http://schemas.xmlsoap.org/wsdl/:arrayType">http://schemas.xmlsoap.org/wsdl/:arrayType</A>']) || $this-&gt;getLocalPart($aname) == 'arrayType'){
+					$this-&gt;complexTypes[$this-&gt;currentComplexType]['phpType'] = 'array';
+                	$prefix = $this-&gt;getPrefix($aname);
+					if(isset($attrs['<A HREF="http://schemas.xmlsoap.org/wsdl/:arrayType">http://schemas.xmlsoap.org/wsdl/:arrayType</A>'])){
+						$v = $attrs['<A HREF="http://schemas.xmlsoap.org/wsdl/:arrayType">http://schemas.xmlsoap.org/wsdl/:arrayType</A>'];
+					} else {
+						$v = '';
+					}
+                    if(strpos($v,'[,]')){
+                        $this-&gt;complexTypes[$this-&gt;currentComplexType]['multidimensional'] = true;
+                    }
+                    $v = substr($v,0,strpos($v,'[')); // clip the []
+                    if(!strpos($v,':') &amp;&amp; isset($this-&gt;typemap[$this-&gt;XMLSchemaVersion][$v])){
+                        $v = $this-&gt;XMLSchemaVersion.':'.$v;
+                    }
+                    $this-&gt;complexTypes[$this-&gt;currentComplexType]['arrayType'] = $v;
+				}
+			break;
+			case 'complexContent':	// (optional) content for a complexType
+			break;
+			case 'complexType':
+				array_push($this-&gt;complexTypeStack, $this-&gt;currentComplexType);
+				if(isset($attrs['name'])){
+					$this-&gt;xdebug('processing named complexType '.$attrs['name']);
+					//$this-&gt;currentElement = false;
+					$this-&gt;currentComplexType = $attrs['name'];
+					$this-&gt;complexTypes[$this-&gt;currentComplexType] = $attrs;
+					$this-&gt;complexTypes[$this-&gt;currentComplexType]['typeClass'] = 'complexType';
+					// This is for constructs like
+					//           &lt;complexType name=&quot;ListOfString&quot; base=&quot;soap:Array&quot;&gt;
+					//                &lt;sequence&gt;
+					//                    &lt;element name=&quot;string&quot; type=&quot;xsd:string&quot;
+					//                        minOccurs=&quot;0&quot; maxOccurs=&quot;unbounded&quot; /&gt;
+					//                &lt;/sequence&gt;
+					//            &lt;/complexType&gt;
+					if(isset($attrs['base']) &amp;&amp; ereg(':Array$',$attrs['base'])){
+						$this-&gt;xdebug('complexType is unusual array');
+						$this-&gt;complexTypes[$this-&gt;currentComplexType]['phpType'] = 'array';
+					} else {
+						$this-&gt;complexTypes[$this-&gt;currentComplexType]['phpType'] = 'struct';
+					}
+				}else{
+					$this-&gt;xdebug('processing unnamed complexType for element '.$this-&gt;currentElement);
+					$this-&gt;currentComplexType = $this-&gt;currentElement . '_ContainedType';
+					//$this-&gt;currentElement = false;
+					$this-&gt;complexTypes[$this-&gt;currentComplexType] = $attrs;
+					$this-&gt;complexTypes[$this-&gt;currentComplexType]['typeClass'] = 'complexType';
+					// This is for constructs like
+					//           &lt;complexType name=&quot;ListOfString&quot; base=&quot;soap:Array&quot;&gt;
+					//                &lt;sequence&gt;
+					//                    &lt;element name=&quot;string&quot; type=&quot;xsd:string&quot;
+					//                        minOccurs=&quot;0&quot; maxOccurs=&quot;unbounded&quot; /&gt;
+					//                &lt;/sequence&gt;
+					//            &lt;/complexType&gt;
+					if(isset($attrs['base']) &amp;&amp; ereg(':Array$',$attrs['base'])){
+						$this-&gt;xdebug('complexType is unusual array');
+						$this-&gt;complexTypes[$this-&gt;currentComplexType]['phpType'] = 'array';
+					} else {
+						$this-&gt;complexTypes[$this-&gt;currentComplexType]['phpType'] = 'struct';
+					}
+				}
+			break;
+			case 'element':
+				array_push($this-&gt;elementStack, $this-&gt;currentElement);
+				// elements defined as part of a complex type should
+				// not really be added to $this-&gt;elements, but for some
+				// reason, they are
+				if (!isset($attrs['form'])) {
+					$attrs['form'] = $this-&gt;schemaInfo['elementFormDefault'];
+				}
+				if(isset($attrs['type'])){
+					$this-&gt;xdebug(&quot;processing typed element &quot;.$attrs['name'].&quot; of type &quot;.$attrs['type']);
+					if (! $this-&gt;getPrefix($attrs['type'])) {
+						if ($this-&gt;defaultNamespace[$pos]) {
+							$attrs['type'] = $this-&gt;defaultNamespace[$pos] . ':' . $attrs['type'];
+							$this-&gt;xdebug('used default namespace to make type ' . $attrs['type']);
+						}
+					}
+					// This is for constructs like
+					//           &lt;complexType name=&quot;ListOfString&quot; base=&quot;soap:Array&quot;&gt;
+					//                &lt;sequence&gt;
+					//                    &lt;element name=&quot;string&quot; type=&quot;xsd:string&quot;
+					//                        minOccurs=&quot;0&quot; maxOccurs=&quot;unbounded&quot; /&gt;
+					//                &lt;/sequence&gt;
+					//            &lt;/complexType&gt;
+					if ($this-&gt;currentComplexType &amp;&amp; $this-&gt;complexTypes[$this-&gt;currentComplexType]['phpType'] == 'array') {
+						$this-&gt;xdebug('arrayType for unusual array is ' . $attrs['type']);
+						$this-&gt;complexTypes[$this-&gt;currentComplexType]['arrayType'] = $attrs['type'];
+					}
+					$this-&gt;currentElement = $attrs['name'];
+					$this-&gt;elements[ $attrs['name'] ] = $attrs;
+					$this-&gt;elements[ $attrs['name'] ]['typeClass'] = 'element';
+					$ename = $attrs['name'];
+				} elseif(isset($attrs['ref'])){
+					$this-&gt;xdebug(&quot;processing element as ref to &quot;.$attrs['ref']);
+					$this-&gt;currentElement = &quot;ref to &quot;.$attrs['ref'];
+					$ename = $this-&gt;getLocalPart($attrs['ref']);
+				} else {
+					$this-&gt;xdebug(&quot;processing untyped element &quot;.$attrs['name']);
+					$this-&gt;currentElement = $attrs['name'];
+					$this-&gt;elements[ $attrs['name'] ] = $attrs;
+					$this-&gt;elements[ $attrs['name'] ]['typeClass'] = 'element';
+					$attrs['type'] = $this-&gt;schemaTargetNamespace . ':' . $attrs['name'] . '_ContainedType';
+					$this-&gt;elements[ $attrs['name'] ]['type'] = $attrs['type'];
+					$ename = $attrs['name'];
+				}
+				if(isset($ename) &amp;&amp; $this-&gt;currentComplexType){
+					$this-&gt;complexTypes[$this-&gt;currentComplexType]['elements'][$ename] = $attrs;
+				}
+			break;
+			case 'enumeration':	//	restriction value list member
+				$this-&gt;xdebug('enumeration ' . $attrs['value']);
+				if ($this-&gt;currentSimpleType) {
+					$this-&gt;simpleTypes[$this-&gt;currentSimpleType]['enumeration'][] = $attrs['value'];
+				} elseif ($this-&gt;currentComplexType) {
+					$this-&gt;complexTypes[$this-&gt;currentComplexType]['enumeration'][] = $attrs['value'];
+				}
+			break;
+			case 'extension':	// simpleContent or complexContent type extension
+				$this-&gt;xdebug('extension ' . $attrs['base']);
+				if ($this-&gt;currentComplexType) {
+					$this-&gt;complexTypes[$this-&gt;currentComplexType]['extensionBase'] = $attrs['base'];
+				}
+			break;
+			case 'import':
+			    if (isset($attrs['schemaLocation'])) {
+					//$this-&gt;xdebug('import namespace ' . $attrs['namespace'] . ' from ' . $attrs['schemaLocation']);
+                    $this-&gt;imports[$attrs['namespace']][] = array('location' =&gt; $attrs['schemaLocation'], 'loaded' =&gt; false);
+				} else {
+					//$this-&gt;xdebug('import namespace ' . $attrs['namespace']);
+                    $this-&gt;imports[$attrs['namespace']][] = array('location' =&gt; '', 'loaded' =&gt; true);
+					if (! $this-&gt;getPrefixFromNamespace($attrs['namespace'])) {
+						$this-&gt;namespaces['ns'.(count($this-&gt;namespaces)+1)] = $attrs['namespace'];
+					}
+				}
+			break;
+			case 'list':	// simpleType value list
+			break;
+			case 'restriction':	// simpleType, simpleContent or complexContent value restriction
+				$this-&gt;xdebug('restriction ' . $attrs['base']);
+				if($this-&gt;currentSimpleType){
+					$this-&gt;simpleTypes[$this-&gt;currentSimpleType]['type'] = $attrs['base'];
+				} elseif($this-&gt;currentComplexType){
+					$this-&gt;complexTypes[$this-&gt;currentComplexType]['restrictionBase'] = $attrs['base'];
+					if(strstr($attrs['base'],':') == ':Array'){
+						$this-&gt;complexTypes[$this-&gt;currentComplexType]['phpType'] = 'array';
+					}
+				}
+			break;
+			case 'schema':
+				$this-&gt;schemaInfo = $attrs;
+				$this-&gt;schemaInfo['schemaVersion'] = $this-&gt;getNamespaceFromPrefix($prefix);
+				if (isset($attrs['targetNamespace'])) {
+					$this-&gt;schemaTargetNamespace = $attrs['targetNamespace'];
+				}
+				if (!isset($attrs['elementFormDefault'])) {
+					$this-&gt;schemaInfo['elementFormDefault'] = 'unqualified';
+				}
+				if (!isset($attrs['attributeFormDefault'])) {
+					$this-&gt;schemaInfo['attributeFormDefault'] = 'unqualified';
+				}
+			break;
+			case 'simpleContent':	// (optional) content for a complexType
+			break;
+			case 'simpleType':
+				array_push($this-&gt;simpleTypeStack, $this-&gt;currentSimpleType);
+				if(isset($attrs['name'])){
+					$this-&gt;xdebug(&quot;processing simpleType for name &quot; . $attrs['name']);
+					$this-&gt;currentSimpleType = $attrs['name'];
+					$this-&gt;simpleTypes[ $attrs['name'] ] = $attrs;
+					$this-&gt;simpleTypes[ $attrs['name'] ]['typeClass'] = 'simpleType';
+					$this-&gt;simpleTypes[ $attrs['name'] ]['phpType'] = 'scalar';
+				} else {
+					$this-&gt;xdebug('processing unnamed simpleType for element '.$this-&gt;currentElement);
+					$this-&gt;currentSimpleType = $this-&gt;currentElement . '_ContainedType';
+					//$this-&gt;currentElement = false;
+					$this-&gt;simpleTypes[$this-&gt;currentSimpleType] = $attrs;
+					$this-&gt;simpleTypes[$this-&gt;currentSimpleType]['phpType'] = 'scalar';
+				}
+			break;
+			case 'union':	// simpleType type list
+			break;
+			default:
+				//$this-&gt;xdebug(&quot;do not have anything to do for element $name&quot;);
+		}
+	}
+
+	/**
+	* end-element handler
+	*
+	* @param    string $parser XML parser object
+	* @param    string $name element name
+	* @access   private
+	*/
+	function schemaEndElement($parser, $name) {
+		// bring depth down a notch
+		$this-&gt;depth--;
+		// position of current element is equal to the last value left in depth_array for my depth
+		if(isset($this-&gt;depth_array[$this-&gt;depth])){
+        	$pos = $this-&gt;depth_array[$this-&gt;depth];
+        }
+		// get element prefix
+		if ($prefix = $this-&gt;getPrefix($name)){
+			// get unqualified name
+			$name = $this-&gt;getLocalPart($name);
+		} else {
+        	$prefix = '';
+        }
+		// move on...
+		if($name == 'complexType'){
+			$this-&gt;xdebug('done processing complexType ' . ($this-&gt;currentComplexType ? $this-&gt;currentComplexType : '(unknown)'));
+			$this-&gt;currentComplexType = array_pop($this-&gt;complexTypeStack);
+			//$this-&gt;currentElement = false;
+		}
+		if($name == 'element'){
+			$this-&gt;xdebug('done processing element ' . ($this-&gt;currentElement ? $this-&gt;currentElement : '(unknown)'));
+			$this-&gt;currentElement = array_pop($this-&gt;elementStack);
+		}
+		if($name == 'simpleType'){
+			$this-&gt;xdebug('done processing simpleType ' . ($this-&gt;currentSimpleType ? $this-&gt;currentSimpleType : '(unknown)'));
+			$this-&gt;currentSimpleType = array_pop($this-&gt;simpleTypeStack);
+		}
+	}
+
+	/**
+	* element content handler
+	*
+	* @param    string $parser XML parser object
+	* @param    string $data element content
+	* @access   private
+	*/
+	function schemaCharacterData($parser, $data){
+		$pos = $this-&gt;depth_array[$this-&gt;depth - 1];
+		$this-&gt;message[$pos]['cdata'] .= $data;
+	}
+
+	/**
+	* serialize the schema
+	*
+	* @access   public
+	*/
+	function serializeSchema(){
+
+		$schemaPrefix = $this-&gt;getPrefixFromNamespace($this-&gt;XMLSchemaVersion);
+		$xml = '';
+		// imports
+		if (sizeof($this-&gt;imports) &gt; 0) {
+			foreach($this-&gt;imports as $ns =&gt; $list) {
+				foreach ($list as $ii) {
+					if ($ii['location'] != '') {
+						$xml .= &quot; &lt;$schemaPrefix:import location=\&quot;&quot; . $ii['location'] . '&quot; namespace=&quot;' . $ns . &quot;\&quot; /&gt;\n&quot;;
+					} else {
+						$xml .= &quot; &lt;$schemaPrefix:import namespace=\&quot;&quot; . $ns . &quot;\&quot; /&gt;\n&quot;;
+					}
+				}
+			} 
+		} 
+		// complex types
+		foreach($this-&gt;complexTypes as $typeName =&gt; $attrs){
+			$contentStr = '';
+			// serialize child elements
+			if(isset($attrs['elements']) &amp;&amp; (count($attrs['elements']) &gt; 0)){
+				foreach($attrs['elements'] as $element =&gt; $eParts){
+					if(isset($eParts['ref'])){
+						$contentStr .= &quot;   &lt;$schemaPrefix:element ref=\&quot;$element\&quot;/&gt;\n&quot;;
+					} else {
+						$contentStr .= &quot;   &lt;$schemaPrefix:element name=\&quot;$element\&quot; type=\&quot;&quot; . $this-&gt;contractQName($eParts['type']) . &quot;\&quot;&quot;;
+						foreach ($eParts as $aName =&gt; $aValue) {
+							// handle, e.g., abstract, default, form, minOccurs, maxOccurs, nillable
+							if ($aName != 'name' &amp;&amp; $aName != 'type') {
+								$contentStr .= &quot; $aName=\&quot;$aValue\&quot;&quot;;
+							}
+						}
+						$contentStr .= &quot;/&gt;\n&quot;;
+					}
+				}
+				// compositor wraps elements
+				if (isset($attrs['compositor']) &amp;&amp; ($attrs['compositor'] != '')) {
+					$contentStr = &quot;  &lt;$schemaPrefix:$attrs[compositor]&gt;\n&quot;.$contentStr.&quot;  &lt;/$schemaPrefix:$attrs[compositor]&gt;\n&quot;;
+				}
+			}
+			// attributes
+			if(isset($attrs['attrs']) &amp;&amp; (count($attrs['attrs']) &gt;= 1)){
+				foreach($attrs['attrs'] as $attr =&gt; $aParts){
+					$contentStr .= &quot;    &lt;$schemaPrefix:attribute&quot;;
+					foreach ($aParts as $a =&gt; $v) {
+						if ($a == 'ref' || $a == 'type') {
+							$contentStr .= &quot; $a=\&quot;&quot;.$this-&gt;contractQName($v).'&quot;';
+						} elseif ($a == '<A HREF="http://schemas.xmlsoap.org/wsdl/:arrayType">http://schemas.xmlsoap.org/wsdl/:arrayType</A>') {
+							$this-&gt;usedNamespaces['wsdl'] = $this-&gt;namespaces['wsdl'];
+							$contentStr .= ' wsdl:arrayType=&quot;'.$this-&gt;contractQName($v).'&quot;';
+						} else {
+							$contentStr .= &quot; $a=\&quot;$v\&quot;&quot;;
+						}
+					}
+					$contentStr .= &quot;/&gt;\n&quot;;
+				}
+			}
+			// if restriction
+			if (isset($attrs['restrictionBase']) &amp;&amp; $attrs['restrictionBase'] != ''){
+				$contentStr = &quot;   &lt;$schemaPrefix:restriction base=\&quot;&quot;.$this-&gt;contractQName($attrs['restrictionBase']).&quot;\&quot;&gt;\n&quot;.$contentStr.&quot;   &lt;/$schemaPrefix:restriction&gt;\n&quot;;
+				// complex or simple content
+				if ((isset($attrs['elements']) &amp;&amp; count($attrs['elements']) &gt; 0) || (isset($attrs['attrs']) &amp;&amp; count($attrs['attrs']) &gt; 0)){
+					$contentStr = &quot;  &lt;$schemaPrefix:complexContent&gt;\n&quot;.$contentStr.&quot;  &lt;/$schemaPrefix:complexContent&gt;\n&quot;;
+				}
+			}
+			// finalize complex type
+			if($contentStr != ''){
+				$contentStr = &quot; &lt;$schemaPrefix:complexType name=\&quot;$typeName\&quot;&gt;\n&quot;.$contentStr.&quot; &lt;/$schemaPrefix:complexType&gt;\n&quot;;
+			} else {
+				$contentStr = &quot; &lt;$schemaPrefix:complexType name=\&quot;$typeName\&quot;/&gt;\n&quot;;
+			}
+			$xml .= $contentStr;
+		}
+		// simple types
+		if(isset($this-&gt;simpleTypes) &amp;&amp; count($this-&gt;simpleTypes) &gt; 0){
+			foreach($this-&gt;simpleTypes as $typeName =&gt; $eParts){
+				$xml .= &quot; &lt;$schemaPrefix:simpleType name=\&quot;$typeName\&quot;&gt;\n  &lt;$schemaPrefix:restriction base=\&quot;&quot;.$this-&gt;contractQName($eParts['type']).&quot;\&quot;/&gt;\n&quot;;
+				if (isset($eParts['enumeration'])) {
+					foreach ($eParts['enumeration'] as $e) {
+						$xml .= &quot;  &lt;$schemaPrefix:enumeration value=\&quot;$e\&quot;/&gt;\n&quot;;
+					}
+				}
+				$xml .= &quot; &lt;/$schemaPrefix:simpleType&gt;&quot;;
+			}
+		}
+		// elements
+		if(isset($this-&gt;elements) &amp;&amp; count($this-&gt;elements) &gt; 0){
+			foreach($this-&gt;elements as $element =&gt; $eParts){
+				$xml .= &quot; &lt;$schemaPrefix:element name=\&quot;$element\&quot; type=\&quot;&quot;.$this-&gt;contractQName($eParts['type']).&quot;\&quot;/&gt;\n&quot;;
+			}
+		}
+		// attributes
+		if(isset($this-&gt;attributes) &amp;&amp; count($this-&gt;attributes) &gt; 0){
+			foreach($this-&gt;attributes as $attr =&gt; $aParts){
+				$xml .= &quot; &lt;$schemaPrefix:attribute name=\&quot;$attr\&quot; type=\&quot;&quot;.$this-&gt;contractQName($aParts['type']).&quot;\&quot;\n/&gt;&quot;;
+			}
+		}
+		// finish 'er up
+		$el = &quot;&lt;$schemaPrefix:schema targetNamespace=\&quot;$this-&gt;schemaTargetNamespace\&quot;\n&quot;;
+		foreach (array_diff($this-&gt;usedNamespaces, $this-&gt;enclosingNamespaces) as $nsp =&gt; $ns) {
+			$el .= &quot; xmlns:$nsp=\&quot;$ns\&quot;\n&quot;;
+		}
+		$xml = $el . &quot;&gt;\n&quot;.$xml.&quot;&lt;/$schemaPrefix:schema&gt;\n&quot;;
+		return $xml;
+	}
+
+	/**
+	* adds debug data to the clas level debug string
+	*
+	* @param    string $string debug data
+	* @access   private
+	*/
+	function xdebug($string){
+		$this-&gt;debug('&lt;' . $this-&gt;schemaTargetNamespace . '&gt; '.$string);
+	}
+
+    /**
+    * get the PHP type of a user defined type in the schema
+    * PHP type is kind of a misnomer since it actually returns 'struct' for assoc. arrays
+    * returns false if no type exists, or not w/ the given namespace
+    * else returns a string that is either a native php type, or 'struct'
+    *
+    * @param string $type, name of defined type
+    * @param string $ns, namespace of type
+    * @return mixed
+    * @access public
+    * @deprecated
+    */
+	function getPHPType($type,$ns){
+		if(isset($this-&gt;typemap[$ns][$type])){
+			//print &quot;found type '$type' and ns $ns in typemap&lt;br&gt;&quot;;
+			return $this-&gt;typemap[$ns][$type];
+		} elseif(isset($this-&gt;complexTypes[$type])){
+			//print &quot;getting type '$type' and ns $ns from complexTypes array&lt;br&gt;&quot;;
+			return $this-&gt;complexTypes[$type]['phpType'];
+		}
+		return false;
+	}
+
+	/**
+    * returns an associative array of information about a given type
+    * returns false if no type exists by the given name
+    *
+	*	For a complexType typeDef = array(
+	*	'restrictionBase' =&gt; '',
+	*	'phpType' =&gt; '',
+	*	'compositor' =&gt; '(sequence|all)',
+	*	'elements' =&gt; array(), // refs to elements array
+	*	'attrs' =&gt; array() // refs to attributes array
+	*	... and so on (see addComplexType)
+	*	)
+	*
+	*   For simpleType or element, the array has different keys.
+    *
+    * @param string
+    * @return mixed
+    * @access public
+    * @see addComplexType
+    * @see addSimpleType
+    * @see addElement
+    */
+	function getTypeDef($type){
+		//$this-&gt;debug(&quot;in getTypeDef for type $type&quot;);
+		if(isset($this-&gt;complexTypes[$type])){
+			$this-&gt;xdebug(&quot;in getTypeDef, found complexType $type&quot;);
+			return $this-&gt;complexTypes[$type];
+		} elseif(isset($this-&gt;simpleTypes[$type])){
+			$this-&gt;xdebug(&quot;in getTypeDef, found simpleType $type&quot;);
+			if (!isset($this-&gt;simpleTypes[$type]['phpType'])) {
+				// get info for type to tack onto the simple type
+				// TODO: can this ever really apply (i.e. what is a simpleType really?)
+				$uqType = substr($this-&gt;simpleTypes[$type]['type'], strrpos($this-&gt;simpleTypes[$type]['type'], ':') + 1);
+				$ns = substr($this-&gt;simpleTypes[$type]['type'], 0, strrpos($this-&gt;simpleTypes[$type]['type'], ':'));
+				$etype = $this-&gt;getTypeDef($uqType);
+				if ($etype) {
+					$this-&gt;xdebug(&quot;in getTypeDef, found type for simpleType $type:&quot;);
+					$this-&gt;xdebug($this-&gt;varDump($etype));
+					if (isset($etype['phpType'])) {
+						$this-&gt;simpleTypes[$type]['phpType'] = $etype['phpType'];
+					}
+					if (isset($etype['elements'])) {
+						$this-&gt;simpleTypes[$type]['elements'] = $etype['elements'];
+					}
+				}
+			}
+			return $this-&gt;simpleTypes[$type];
+		} elseif(isset($this-&gt;elements[$type])){
+			$this-&gt;xdebug(&quot;in getTypeDef, found element $type&quot;);
+			if (!isset($this-&gt;elements[$type]['phpType'])) {
+				// get info for type to tack onto the element
+				$uqType = substr($this-&gt;elements[$type]['type'], strrpos($this-&gt;elements[$type]['type'], ':') + 1);
+				$ns = substr($this-&gt;elements[$type]['type'], 0, strrpos($this-&gt;elements[$type]['type'], ':'));
+				$etype = $this-&gt;getTypeDef($uqType);
+				if ($etype) {
+					$this-&gt;xdebug(&quot;in getTypeDef, found type for element $type:&quot;);
+					$this-&gt;xdebug($this-&gt;varDump($etype));
+					if (isset($etype['phpType'])) {
+						$this-&gt;elements[$type]['phpType'] = $etype['phpType'];
+					}
+					if (isset($etype['elements'])) {
+						$this-&gt;elements[$type]['elements'] = $etype['elements'];
+					}
+				} elseif ($ns == '<A HREF="http://www.w3.org/2001/XMLSchema">http://www.w3.org/2001/XMLSchema</A>') {
+					$this-&gt;xdebug(&quot;in getTypeDef, element $type is an XSD type&quot;);
+					$this-&gt;elements[$type]['phpType'] = 'scalar';
+				}
+			}
+			return $this-&gt;elements[$type];
+		} elseif(isset($this-&gt;attributes[$type])){
+			$this-&gt;xdebug(&quot;in getTypeDef, found attribute $type&quot;);
+			return $this-&gt;attributes[$type];
+		} elseif (ereg('_ContainedType$', $type)) {
+			$this-&gt;xdebug(&quot;in getTypeDef, have an untyped element $type&quot;);
+			$typeDef['typeClass'] = 'simpleType';
+			$typeDef['phpType'] = 'scalar';
+			$typeDef['type'] = '<A HREF="http://www.w3.org/2001/XMLSchema:string">http://www.w3.org/2001/XMLSchema:string</A>';
+			return $typeDef;
+		}
+		$this-&gt;xdebug(&quot;in getTypeDef, did not find $type&quot;);
+		return false;
+	}
+
+	/**
+    * returns a sample serialization of a given type, or false if no type by the given name
+    *
+    * @param string $type, name of type
+    * @return mixed
+    * @access public
+    * @deprecated
+    */
+    function serializeTypeDef($type){
+    	//print &quot;in sTD() for type $type&lt;br&gt;&quot;;
+	if($typeDef = $this-&gt;getTypeDef($type)){
+		$str .= '&lt;'.$type;
+	    if(is_array($typeDef['attrs'])){
+		foreach($attrs as $attName =&gt; $data){
+		    $str .= &quot; $attName=\&quot;{type = &quot;.$data['type'].&quot;}\&quot;&quot;;
+		}
+	    }
+	    $str .= &quot; xmlns=\&quot;&quot;.$this-&gt;schema['targetNamespace'].&quot;\&quot;&quot;;
+	    if(count($typeDef['elements']) &gt; 0){
+		$str .= &quot;&gt;&quot;;
+		foreach($typeDef['elements'] as $element =&gt; $eData){
+		    $str .= $this-&gt;serializeTypeDef($element);
+		}
+		$str .= &quot;&lt;/$type&gt;&quot;;
+	    } elseif($typeDef['typeClass'] == 'element') {
+		$str .= &quot;&gt;&lt;/$type&gt;&quot;;
+	    } else {
+		$str .= &quot;/&gt;&quot;;
+	    }
+			return $str;
+	}
+    	return false;
+    }
+
+    /**
+    * returns HTML form elements that allow a user
+    * to enter values for creating an instance of the given type.
+    *
+    * @param string $name, name for type instance
+    * @param string $type, name of type
+    * @return string
+    * @access public
+    * @deprecated
+	*/
+	function typeToForm($name,$type){
+		// get typedef
+		if($typeDef = $this-&gt;getTypeDef($type)){
+			// if struct
+			if($typeDef['phpType'] == 'struct'){
+				$buffer .= '&lt;table&gt;';
+				foreach($typeDef['elements'] as $child =&gt; $childDef){
+					$buffer .= &quot;
+					&lt;tr&gt;&lt;td align='right'&gt;$childDef[name] (type: &quot;.$this-&gt;getLocalPart($childDef['type']).&quot;):&lt;/td&gt;
+					&lt;td&gt;&lt;input type='text' name='parameters[&quot;.$name.&quot;][$childDef[name]]'&gt;&lt;/td&gt;&lt;/tr&gt;&quot;;
+				}
+				$buffer .= '&lt;/table&gt;';
+			// if array
+			} elseif($typeDef['phpType'] == 'array'){
+				$buffer .= '&lt;table&gt;';
+				for($i=0;$i &lt; 3; $i++){
+					$buffer .= &quot;
+					&lt;tr&gt;&lt;td align='right'&gt;array item (type: $typeDef[arrayType]):&lt;/td&gt;
+					&lt;td&gt;&lt;input type='text' name='parameters[&quot;.$name.&quot;][]'&gt;&lt;/td&gt;&lt;/tr&gt;&quot;;
+				}
+				$buffer .= '&lt;/table&gt;';
+			// if scalar
+			} else {
+				$buffer .= &quot;&lt;input type='text' name='parameters[$name]'&gt;&quot;;
+			}
+		} else {
+			$buffer .= &quot;&lt;input type='text' name='parameters[$name]'&gt;&quot;;
+		}
+		return $buffer;
+	}
+	
+	/**
+	* adds a complex type to the schema
+	* 
+	* example: array
+	* 
+	* addType(
+	* 	'ArrayOfstring',
+	* 	'complexType',
+	* 	'array',
+	* 	'',
+	* 	'SOAP-ENC:Array',
+	* 	array('ref'=&gt;'SOAP-ENC:arrayType','wsdl:arrayType'=&gt;'string[]'),
+	* 	'xsd:string'
+	* );
+	* 
+	* example: PHP associative array ( SOAP Struct )
+	* 
+	* addType(
+	* 	'SOAPStruct',
+	* 	'complexType',
+	* 	'struct',
+	* 	'all',
+	* 	array('myVar'=&gt; array('name'=&gt;'myVar','type'=&gt;'string')
+	* );
+	* 
+	* @param name
+	* @param typeClass (complexType|simpleType|attribute)
+	* @param phpType: currently supported are array and struct (php assoc array)
+	* @param compositor (all|sequence|choice)
+	* @param restrictionBase namespace:name (<A HREF="http://schemas.xmlsoap.org/soap/encoding/:Array">http://schemas.xmlsoap.org/soap/encoding/:Array</A>)
+	* @param elements = array ( name = array(name=&gt;'',type=&gt;'') )
+	* @param attrs = array(
+	* 	array(
+	*		'ref' =&gt; &quot;<A HREF="http://schemas.xmlsoap.org/soap/encoding/:arrayType">http://schemas.xmlsoap.org/soap/encoding/:arrayType</A>&quot;,
+	*		&quot;<A HREF="http://schemas.xmlsoap.org/wsdl/:arrayType">http://schemas.xmlsoap.org/wsdl/:arrayType</A>&quot; =&gt; &quot;string[]&quot;
+	* 	)
+	* )
+	* @param arrayType: namespace:name (<A HREF="http://www.w3.org/2001/XMLSchema:string">http://www.w3.org/2001/XMLSchema:string</A>)
+	* @access public
+	* @see getTypeDef
+	*/
+	function addComplexType($name,$typeClass='complexType',$phpType='array',$compositor='',$restrictionBase='',$elements=array(),$attrs=array(),$arrayType=''){
+		$this-&gt;complexTypes[$name] = array(
+	    'name'		=&gt; $name,
+	    'typeClass'	=&gt; $typeClass,
+	    'phpType'	=&gt; $phpType,
+		'compositor'=&gt; $compositor,
+	    'restrictionBase' =&gt; $restrictionBase,
+		'elements'	=&gt; $elements,
+	    'attrs'		=&gt; $attrs,
+	    'arrayType'	=&gt; $arrayType
+		);
+		
+		$this-&gt;xdebug(&quot;addComplexType $name:&quot;);
+		$this-&gt;appendDebug($this-&gt;varDump($this-&gt;complexTypes[$name]));
+	}
+	
+	/**
+	* adds a simple type to the schema
+	*
+	* @param string $name
+	* @param string $restrictionBase namespace:name (<A HREF="http://schemas.xmlsoap.org/soap/encoding/:Array">http://schemas.xmlsoap.org/soap/encoding/:Array</A>)
+	* @param string $typeClass (should always be simpleType)
+	* @param string $phpType (should always be scalar)
+	* @param array $enumeration array of values
+	* @access public
+	* @see xmlschema
+	* @see getTypeDef
+	*/
+	function addSimpleType($name, $restrictionBase='', $typeClass='simpleType', $phpType='scalar', $enumeration=array()) {
+		$this-&gt;simpleTypes[$name] = array(
+	    'name'			=&gt; $name,
+	    'typeClass'		=&gt; $typeClass,
+	    'phpType'		=&gt; $phpType,
+	    'type'			=&gt; $restrictionBase,
+	    'enumeration'	=&gt; $enumeration
+		);
+		
+		$this-&gt;xdebug(&quot;addSimpleType $name:&quot;);
+		$this-&gt;appendDebug($this-&gt;varDump($this-&gt;simpleTypes[$name]));
+	}
+
+	/**
+	* adds an element to the schema
+	*
+	* @param array $attrs attributes that must include name and type
+	* @see xmlschema
+	* @access public
+	*/
+	function addElement($attrs) {
+		if (! $this-&gt;getPrefix($attrs['type'])) {
+			$attrs['type'] = $this-&gt;schemaTargetNamespace . ':' . $attrs['type'];
+		}
+		$this-&gt;elements[ $attrs['name'] ] = $attrs;
+		$this-&gt;elements[ $attrs['name'] ]['typeClass'] = 'element';
+		
+		$this-&gt;xdebug(&quot;addElement &quot; . $attrs['name']);
+		$this-&gt;appendDebug($this-&gt;varDump($this-&gt;elements[ $attrs['name'] ]));
+	}
+}
+
+
+
+?&gt;&lt;?php
+
+
+
+/**
+* For creating serializable abstractions of native PHP types.  This class
+* allows element name/namespace, XSD type, and XML attributes to be
+* associated with a value.  This is extremely useful when WSDL is not
+* used, but is also useful when WSDL is used with polymorphic types, including
+* xsd:anyType and user-defined types.
+*
+* @author   Dietrich Ayala &lt;<A HREF="https://lists.berlios.de/mailman/listinfo/viperals-svncheckins">dietrich at ganx4.com</A>&gt;
+* @version  $Id: nusoap.php,v 1.94 2005/08/04 01:27:42 snichol Exp $
+* @access   public
+*/
+class soapval extends nusoap_base {
+	/**
+	 * The XML element name
+	 *
+	 * @var string
+	 * @access private
+	 */
+	var $name;
+	/**
+	 * The XML type name (string or false)
+	 *
+	 * @var mixed
+	 * @access private
+	 */
+	var $type;
+	/**
+	 * The PHP value
+	 *
+	 * @var mixed
+	 * @access private
+	 */
+	var $value;
+	/**
+	 * The XML element namespace (string or false)
+	 *
+	 * @var mixed
+	 * @access private
+	 */
+	var $element_ns;
+	/**
+	 * The XML type namespace (string or false)
+	 *
+	 * @var mixed
+	 * @access private
+	 */
+	var $type_ns;
+	/**
+	 * The XML element attributes (array or false)
+	 *
+	 * @var mixed
+	 * @access private
+	 */
+	var $attributes;
+
+	/**
+	* constructor
+	*
+	* @param    string $name optional name
+	* @param    mixed $type optional type name
+	* @param	mixed $value optional value
+	* @param	mixed $element_ns optional namespace of value
+	* @param	mixed $type_ns optional namespace of type
+	* @param	mixed $attributes associative array of attributes to add to element serialization
+	* @access   public
+	*/
+  	function soapval($name='soapval',$type=false,$value=-1,$element_ns=false,$type_ns=false,$attributes=false) {
+		parent::nusoap_base();
+		$this-&gt;name = $name;
+		$this-&gt;type = $type;
+		$this-&gt;value = $value;
+		$this-&gt;element_ns = $element_ns;
+		$this-&gt;type_ns = $type_ns;
+		$this-&gt;attributes = $attributes;
+    }
+
+	/**
+	* return serialized value
+	*
+	* @param	string $use The WSDL use value (encoded|literal)
+	* @return	string XML data
+	* @access   public
+	*/
+	function serialize($use='encoded') {
+		return $this-&gt;serialize_val($this-&gt;value,$this-&gt;name,$this-&gt;type,$this-&gt;element_ns,$this-&gt;type_ns,$this-&gt;attributes,$use);
+    }
+
+	/**
+	* decodes a soapval object into a PHP native type
+	*
+	* @return	mixed
+	* @access   public
+	*/
+	function decode(){
+		return $this-&gt;value;
+	}
+}
+
+
+
+?&gt;&lt;?php
+
+
+
+/**
+* transport class for sending/receiving data via HTTP and HTTPS
+* NOTE: PHP must be compiled with the CURL extension for HTTPS support
+*
+* @author   Dietrich Ayala &lt;<A HREF="https://lists.berlios.de/mailman/listinfo/viperals-svncheckins">dietrich at ganx4.com</A>&gt;
+* @version  $Id: nusoap.php,v 1.94 2005/08/04 01:27:42 snichol Exp $
+* @access public
+*/
+class soap_transport_http extends nusoap_base {
+
+	var $url = '';
+	var $uri = '';
+	var $digest_uri = '';
+	var $scheme = '';
+	var $host = '';
+	var $port = '';
+	var $path = '';
+	var $request_method = 'POST';
+	var $protocol_version = '1.0';
+	var $encoding = '';
+	var $outgoing_headers = array();
+	var $incoming_headers = array();
+	var $incoming_cookies = array();
+	var $outgoing_payload = '';
+	var $incoming_payload = '';
+	var $useSOAPAction = true;
+	var $persistentConnection = false;
+	var $ch = false;	// cURL handle
+	var $username = '';
+	var $password = '';
+	var $authtype = '';
+	var $digestRequest = array();
+	var $certRequest = array();	// keys must be cainfofile (optional), sslcertfile, sslkeyfile, passphrase, verifypeer (optional), verifyhost (optional)
+								// cainfofile: certificate authority file, e.g. '$pathToPemFiles/rootca.pem'
+								// sslcertfile: SSL certificate file, e.g. '$pathToPemFiles/mycert.pem'
+								// sslkeyfile: SSL key file, e.g. '$pathToPemFiles/mykey.pem'
+								// passphrase: SSL key password/passphrase
+								// verifypeer: default is 1
+								// verifyhost: default is 1
+
+	/**
+	* constructor
+	*/
+	function soap_transport_http($url){
+		parent::nusoap_base();
+		$this-&gt;setURL($url);
+		ereg('\$Revisio' . 'n: ([^ ]+)', $this-&gt;revision, $rev);
+		$this-&gt;outgoing_headers['User-Agent'] = $this-&gt;title.'/'.$this-&gt;version.' ('.$rev[1].')';
+		$this-&gt;debug('set User-Agent: ' . $this-&gt;outgoing_headers['User-Agent']);
+	}
+
+	function setURL($url) {
+		$this-&gt;url = $url;
+
+		$u = parse_url($url);
+		foreach($u as $k =&gt; $v){
+			$this-&gt;debug(&quot;$k = $v&quot;);
+			$this-&gt;$k = $v;
+		}
+		
+		// add any GET params to path
+		if(isset($u['query']) &amp;&amp; $u['query'] != ''){
+            $this-&gt;path .= '?' . $u['query'];
+		}
+		
+		// set default port
+		if(!isset($u['port'])){
+			if($u['scheme'] == 'https'){
+				$this-&gt;port = 443;
+			} else {
+				$this-&gt;port = 80;
+			}
+		}
+		
+		$this-&gt;uri = $this-&gt;path;
+		$this-&gt;digest_uri = $this-&gt;uri;
+		
+		// build headers
+		if (!isset($u['port'])) {
+			$this-&gt;outgoing_headers['Host'] = $this-&gt;host;
+		} else {
+			$this-&gt;outgoing_headers['Host'] = $this-&gt;host.':'.$this-&gt;port;
+		}
+		$this-&gt;debug('set Host: ' . $this-&gt;outgoing_headers['Host']);
+
+		if (isset($u['user']) &amp;&amp; $u['user'] != '') {
+			$this-&gt;setCredentials(urldecode($u['user']), isset($u['pass']) ? urldecode($u['pass']) : '');
+		}
+	}
+	
+	function connect($connection_timeout=0,$response_timeout=30){
+	  	// For PHP 4.3 with OpenSSL, change https scheme to ssl, then treat like
+	  	// &quot;regular&quot; socket.
+	  	// TODO: disabled for now because OpenSSL must be *compiled* in (not just
+	  	//       loaded), and until PHP5 stream_get_wrappers is not available.
+//	  	if ($this-&gt;scheme == 'https') {
+//		  	if (version_compare(phpversion(), '4.3.0') &gt;= 0) {
+//		  		if (extension_loaded('openssl')) {
+//		  			$this-&gt;scheme = 'ssl';
+//		  			$this-&gt;debug('Using SSL over OpenSSL');
+//		  		}
+//		  	}
+//		}
+		$this-&gt;debug(&quot;connect connection_timeout $connection_timeout, response_timeout $response_timeout, scheme $this-&gt;scheme, host $this-&gt;host, port $this-&gt;port&quot;);
+	  if ($this-&gt;scheme == 'http' || $this-&gt;scheme == 'ssl') {
+		// use persistent connection
+		if($this-&gt;persistentConnection &amp;&amp; isset($this-&gt;fp) &amp;&amp; is_resource($this-&gt;fp)){
+			if (!feof($this-&gt;fp)) {
+				$this-&gt;debug('Re-use persistent connection');
+				return true;
+			}
+			fclose($this-&gt;fp);
+			$this-&gt;debug('Closed persistent connection at EOF');
+		}
+
+		// munge host if using OpenSSL
+		if ($this-&gt;scheme == 'ssl') {
+			$host = '<A HREF="ssl://">ssl://</A>' . $this-&gt;host;
+		} else {
+			$host = $this-&gt;host;
+		}
+		$this-&gt;debug('calling fsockopen with host ' . $host . ' connection_timeout ' . $connection_timeout);
+
+		// open socket
+		if($connection_timeout &gt; 0){
+			$this-&gt;fp = @fsockopen( $host, $this-&gt;port, $this-&gt;errno, $this-&gt;error_str, $connection_timeout);
+		} else {
+			$this-&gt;fp = @fsockopen( $host, $this-&gt;port, $this-&gt;errno, $this-&gt;error_str);
+		}
+		
+		// test pointer
+		if(!$this-&gt;fp) {
+			$msg = 'Couldn\'t open socket connection to server ' . $this-&gt;url;
+			if ($this-&gt;errno) {
+				$msg .= ', Error ('.$this-&gt;errno.'): '.$this-&gt;error_str;
+			} else {
+				$msg .= ' prior to connect().  This is often a problem looking up the host name.';
+			}
+			$this-&gt;debug($msg);
+			$this-&gt;setError($msg);
+			return false;
+		}
+		
+		// set response timeout
+		$this-&gt;debug('set response timeout to ' . $response_timeout);
+		socket_set_timeout( $this-&gt;fp, $response_timeout);
+
+		$this-&gt;debug('socket connected');
+		return true;
+	  } else if ($this-&gt;scheme == 'https') {
+		if (!extension_loaded('curl')) {
+			$this-&gt;setError('CURL Extension, or OpenSSL extension w/ PHP version &gt;= 4.3 is required for HTTPS');
+			return false;
+		}
+		$this-&gt;debug('connect using https');
+		// init CURL
+		$this-&gt;ch = curl_init();
+		// set url
+		$hostURL = ($this-&gt;port != '') ? &quot;<A HREF="https://$this-">https://$this-</A>&gt;host:$this-&gt;port&quot; : &quot;<A HREF="https://$this-">https://$this-</A>&gt;host&quot;;
+		// add path
+		$hostURL .= $this-&gt;path;
+		curl_setopt($this-&gt;ch, CURLOPT_URL, $hostURL);
+		// follow location headers (re-directs)
+		curl_setopt($this-&gt;ch, CURLOPT_FOLLOWLOCATION, 1);
+		// ask for headers in the response output
+		curl_setopt($this-&gt;ch, CURLOPT_HEADER, 1);
+		// ask for the response output as the return value
+		curl_setopt($this-&gt;ch, CURLOPT_RETURNTRANSFER, 1);
+		// encode
+		// We manage this ourselves through headers and encoding
+//		if(function_exists('gzuncompress')){
+//			curl_setopt($this-&gt;ch, CURLOPT_ENCODING, 'deflate');
+//		}
+		// persistent connection
+		if ($this-&gt;persistentConnection) {
+			// The way we send data, we cannot use persistent connections, since
+			// there will be some &quot;junk&quot; at the end of our request.
+			//curl_setopt($this-&gt;ch, CURL_HTTP_VERSION_1_1, true);
+			$this-&gt;persistentConnection = false;
+			$this-&gt;outgoing_headers['Connection'] = 'close';
+			$this-&gt;debug('set Connection: ' . $this-&gt;outgoing_headers['Connection']);
+		}
+		// set timeout
+		if ($connection_timeout != 0) {
+			curl_setopt($this-&gt;ch, CURLOPT_TIMEOUT, $connection_timeout);
+		}
+		// TODO: cURL has added a connection timeout separate from the response timeout
+		//if ($connection_timeout != 0) {
+		//	curl_setopt($this-&gt;ch, CURLOPT_CONNECTIONTIMEOUT, $connection_timeout);
+		//}
+		//if ($response_timeout != 0) {
+		//	curl_setopt($this-&gt;ch, CURLOPT_TIMEOUT, $response_timeout);
+		//}
+
+		// recent versions of cURL turn on peer/host checking by default,
+		// while PHP binaries are not compiled with a default location for the
+		// CA cert bundle, so disable peer/host checking.
+//curl_setopt($this-&gt;ch, CURLOPT_CAINFO, 'f:\php-4.3.2-win32\extensions\curl-ca-bundle.crt');		
+		curl_setopt($this-&gt;ch, CURLOPT_SSL_VERIFYPEER, 0);
+		curl_setopt($this-&gt;ch, CURLOPT_SSL_VERIFYHOST, 0);
+
+		// support client certificates (thanks Tobias Boes, Doug Anarino, Eryan Ariobowo)
+		if ($this-&gt;authtype == 'certificate') {
+			if (isset($this-&gt;certRequest['cainfofile'])) {
+				curl_setopt($this-&gt;ch, CURLOPT_CAINFO, $this-&gt;certRequest['cainfofile']);
+			}
+			if (isset($this-&gt;certRequest['verifypeer'])) {
+				curl_setopt($this-&gt;ch, CURLOPT_SSL_VERIFYPEER, $this-&gt;certRequest['verifypeer']);
+			} else {
+				curl_setopt($this-&gt;ch, CURLOPT_SSL_VERIFYPEER, 1);
+			}
+			if (isset($this-&gt;certRequest['verifyhost'])) {
+				curl_setopt($this-&gt;ch, CURLOPT_SSL_VERIFYHOST, $this-&gt;certRequest['verifyhost']);
+			} else {
+				curl_setopt($this-&gt;ch, CURLOPT_SSL_VERIFYHOST, 1);
+			}
+			if (isset($this-&gt;certRequest['sslcertfile'])) {
+				curl_setopt($this-&gt;ch, CURLOPT_SSLCERT, $this-&gt;certRequest['sslcertfile']);
+			}
+			if (isset($this-&gt;certRequest['sslkeyfile'])) {
+				curl_setopt($this-&gt;ch, CURLOPT_SSLKEY, $this-&gt;certRequest['sslkeyfile']);
+			}
+			if (isset($this-&gt;certRequest['passphrase'])) {
+				curl_setopt($this-&gt;ch, CURLOPT_SSLKEYPASSWD , $this-&gt;certRequest['passphrase']);
+			}
+		}
+		$this-&gt;debug('cURL connection set up');
+		return true;
+	  } else {
+		$this-&gt;setError('Unknown scheme ' . $this-&gt;scheme);
+		$this-&gt;debug('Unknown scheme ' . $this-&gt;scheme);
+		return false;
+	  }
+	}
+	
+	/**
+	* send the SOAP message via HTTP
+	*
+	* @param    string $data message data
+	* @param    integer $timeout set connection timeout in seconds
+	* @param	integer $response_timeout set response timeout in seconds
+	* @param	array $cookies cookies to send
+	* @return	string data
+	* @access   public
+	*/
+	function send($data, $timeout=0, $response_timeout=30, $cookies=NULL) {
+		
+		$this-&gt;debug('entered send() with data of length: '.strlen($data));
+
+		$this-&gt;tryagain = true;
+		$tries = 0;
+		while ($this-&gt;tryagain) {
+			$this-&gt;tryagain = false;
+			if ($tries++ &lt; 2) {
+				// make connnection
+				if (!$this-&gt;connect($timeout, $response_timeout)){
+					return false;
+				}
+				
+				// send request
+				if (!$this-&gt;sendRequest($data, $cookies)){
+					return false;
+				}
+				
+				// get response
+				$respdata = $this-&gt;getResponse();
+			} else {
+				$this-&gt;setError('Too many tries to get an OK response');
+			}
+		}		
+		$this-&gt;debug('end of send()');
+		return $respdata;
+	}
+
+
+	/**
+	* send the SOAP message via HTTPS 1.0 using CURL
+	*
+	* @param    string $msg message data
+	* @param    integer $timeout set connection timeout in seconds
+	* @param	integer $response_timeout set response timeout in seconds
+	* @param	array $cookies cookies to send
+	* @return	string data
+	* @access   public
+	*/
+	function sendHTTPS($data, $timeout=0, $response_timeout=30, $cookies) {
+		return $this-&gt;send($data, $timeout, $response_timeout, $cookies);
+	}
+	
+	/**
+	* if authenticating, set user credentials here
+	*
+	* @param    string $username
+	* @param    string $password
+	* @param	string $authtype (basic, digest, certificate)
+	* @param	array $digestRequest (keys must be nonce, nc, realm, qop)
+	* @param	array $certRequest (keys must be cainfofile (optional), sslcertfile, sslkeyfile, passphrase, verifypeer (optional), verifyhost (optional): see corresponding options in cURL docs)
+	* @access   public
+	*/
+	function setCredentials($username, $password, $authtype = 'basic', $digestRequest = array(), $certRequest = array()) {
+		$this-&gt;debug(&quot;Set credentials for authtype $authtype&quot;);
+		// cf. RFC 2617
+		if ($authtype == 'basic') {
+			$this-&gt;outgoing_headers['Authorization'] = 'Basic '.base64_encode(str_replace(':','',$username).':'.$password);
+		} elseif ($authtype == 'digest') {
+			if (isset($digestRequest['nonce'])) {
+				$digestRequest['nc'] = isset($digestRequest['nc']) ? $digestRequest['nc']++ : 1;
+				
+				// calculate the Digest hashes (calculate code based on digest implementation found at: <A HREF="http://www.rassoc.com/gregr/weblog/stories/2002/07/09/webServicesSecurityHttpDigestAuthenticationWithoutActiveDirectory.html">http://www.rassoc.com/gregr/weblog/stories/2002/07/09/webServicesSecurityHttpDigestAuthenticationWithoutActiveDirectory.html</A>)
+	
+				// A1 = unq(username-value) &quot;:&quot; unq(realm-value) &quot;:&quot; passwd
+				$A1 = $username. ':' . (isset($digestRequest['realm']) ? $digestRequest['realm'] : '') . ':' . $password;
+	
+				// H(A1) = MD5(A1)
+				$HA1 = md5($A1);
+	
+				// A2 = Method &quot;:&quot; digest-uri-value
+				$A2 = 'POST:' . $this-&gt;digest_uri;
+	
+				// H(A2)
+				$HA2 =  md5($A2);
+	
+				// KD(secret, data) = H(concat(secret, &quot;:&quot;, data))
+				// if qop == auth:
+				// request-digest  = &lt;&quot;&gt; &lt; KD ( H(A1),     unq(nonce-value)
+				//                              &quot;:&quot; nc-value
+				//                              &quot;:&quot; unq(cnonce-value)
+				//                              &quot;:&quot; unq(qop-value)
+				//                              &quot;:&quot; H(A2)
+				//                            ) &lt;&quot;&gt;
+				// if qop is missing,
+				// request-digest  = &lt;&quot;&gt; &lt; KD ( H(A1), unq(nonce-value) &quot;:&quot; H(A2) ) &gt; &lt;&quot;&gt;
+	
+				$unhashedDigest = '';
+				$nonce = isset($digestRequest['nonce']) ? $digestRequest['nonce'] : '';
+				$cnonce = $nonce;
+				if ($digestRequest['qop'] != '') {
+					$unhashedDigest = $HA1 . ':' . $nonce . ':' . sprintf(&quot;%08d&quot;, $digestRequest['nc']) . ':' . $cnonce . ':' . $digestRequest['qop'] . ':' . $HA2;
+				} else {
+					$unhashedDigest = $HA1 . ':' . $nonce . ':' . $HA2;
+				}
+	
+				$hashedDigest = md5($unhashedDigest);
+	
+				$this-&gt;outgoing_headers['Authorization'] = 'Digest username=&quot;' . $username . '&quot;, realm=&quot;' . $digestRequest['realm'] . '&quot;, nonce=&quot;' . $nonce . '&quot;, uri=&quot;' . $this-&gt;digest_uri . '&quot;, cnonce=&quot;' . $cnonce . '&quot;, nc=' . sprintf(&quot;%08x&quot;, $digestRequest['nc']) . ', qop=&quot;' . $digestRequest['qop'] . '&quot;, response=&quot;' . $hashedDigest . '&quot;';
+			}
+		} elseif ($authtype == 'certificate') {
+			$this-&gt;certRequest = $certRequest;
+		}
+		$this-&gt;username = $username;
+		$this-&gt;password = $password;
+		$this-&gt;authtype = $authtype;
+		$this-&gt;digestRequest = $digestRequest;
+		
+		if (isset($this-&gt;outgoing_headers['Authorization'])) {
+			$this-&gt;debug('set Authorization: ' . substr($this-&gt;outgoing_headers['Authorization'], 0, 12) . '...');
+		} else {
+			$this-&gt;debug('Authorization header not set');
+		}
+	}
+	
+	/**
+	* set the soapaction value
+	*
+	* @param    string $soapaction
+	* @access   public
+	*/
+	function setSOAPAction($soapaction) {
+		$this-&gt;outgoing_headers['SOAPAction'] = '&quot;' . $soapaction . '&quot;';
+		$this-&gt;debug('set SOAPAction: ' . $this-&gt;outgoing_headers['SOAPAction']);
+	}
+	
+	/**
+	* use http encoding
+	*
+	* @param    string $enc encoding style. supported values: gzip, deflate, or both
+	* @access   public
+	*/
+	function setEncoding($enc='gzip, deflate') {
+		if (function_exists('gzdeflate')) {
+			$this-&gt;protocol_version = '1.1';
+			$this-&gt;outgoing_headers['Accept-Encoding'] = $enc;
+			$this-&gt;debug('set Accept-Encoding: ' . $this-&gt;outgoing_headers['Accept-Encoding']);
+			if (!isset($this-&gt;outgoing_headers['Connection'])) {
+				$this-&gt;outgoing_headers['Connection'] = 'close';
+				$this-&gt;persistentConnection = false;
+				$this-&gt;debug('set Connection: ' . $this-&gt;outgoing_headers['Connection']);
+			}
+			set_magic_quotes_runtime(0);
+			// deprecated
+			$this-&gt;encoding = $enc;
+		}
+	}
+	
+	/**
+	* set proxy info here
+	*
+	* @param    string $proxyhost
+	* @param    string $proxyport
+	* @param	string $proxyusername
+	* @param	string $proxypassword
+	* @access   public
+	*/
+	function setProxy($proxyhost, $proxyport, $proxyusername = '', $proxypassword = '') {
+		$this-&gt;uri = $this-&gt;url;
+		$this-&gt;host = $proxyhost;
+		$this-&gt;port = $proxyport;
+		if ($proxyusername != '' &amp;&amp; $proxypassword != '') {
+			$this-&gt;outgoing_headers['Proxy-Authorization'] = ' Basic '.base64_encode($proxyusername.':'.$proxypassword);
+			$this-&gt;debug('set Proxy-Authorization: ' . $this-&gt;outgoing_headers['Proxy-Authorization']);
+		}
+	}
+	
+	/**
+	* decode a string that is encoded w/ &quot;chunked' transfer encoding
+ 	* as defined in RFC2068 19.4.6
+	*
+	* @param    string $buffer
+	* @param    string $lb
+	* @returns	string
+	* @access   public
+	* @deprecated
+	*/
+	function decodeChunked($buffer, $lb){
+		// length := 0
+		$length = 0;
+		$new = '';
+		
+		// read chunk-size, chunk-extension (if any) and CRLF
+		// get the position of the linebreak
+		$chunkend = strpos($buffer, $lb);
+		if ($chunkend == FALSE) {
+			$this-&gt;debug('no linebreak found in decodeChunked');
+			return $new;
+		}
+		$temp = substr($buffer,0,$chunkend);
+		$chunk_size = hexdec( trim($temp) );
+		$chunkstart = $chunkend + strlen($lb);
+		// while (chunk-size &gt; 0) {
+		while ($chunk_size &gt; 0) {
+			$this-&gt;debug(&quot;chunkstart: $chunkstart chunk_size: $chunk_size&quot;);
+			$chunkend = strpos( $buffer, $lb, $chunkstart + $chunk_size);
+		  	
+			// Just in case we got a broken connection
+		  	if ($chunkend == FALSE) {
+		  	    $chunk = substr($buffer,$chunkstart);
+				// append chunk-data to entity-body
+		    	$new .= $chunk;
+		  	    $length += strlen($chunk);
+		  	    break;
+			}
+			
+		  	// read chunk-data and CRLF
+		  	$chunk = substr($buffer,$chunkstart,$chunkend-$chunkstart);
+		  	// append chunk-data to entity-body
+		  	$new .= $chunk;
+		  	// length := length + chunk-size
+		  	$length += strlen($chunk);
+		  	// read chunk-size and CRLF
+		  	$chunkstart = $chunkend + strlen($lb);
+			
+		  	$chunkend = strpos($buffer, $lb, $chunkstart) + strlen($lb);
+			if ($chunkend == FALSE) {
+				break; //Just in case we got a broken connection
+			}
+			$temp = substr($buffer,$chunkstart,$chunkend-$chunkstart);
+			$chunk_size = hexdec( trim($temp) );
+			$chunkstart = $chunkend;
+		}
+		return $new;
+	}
+	
+	/*
+	 *	Writes payload, including HTTP headers, to $this-&gt;outgoing_payload.
+	 */
+	function buildPayload($data, $cookie_str = '') {
+		// add content-length header
+		$this-&gt;outgoing_headers['Content-Length'] = strlen($data);
+		$this-&gt;debug('set Content-Length: ' . $this-&gt;outgoing_headers['Content-Length']);
+
+		// start building outgoing payload:
+		$req = &quot;$this-&gt;request_method $this-&gt;uri HTTP/$this-&gt;protocol_version&quot;;
+		$this-&gt;debug(&quot;HTTP request: $req&quot;);
+		$this-&gt;outgoing_payload = &quot;$req\r\n&quot;;
+
+		// loop thru headers, serializing
+		foreach($this-&gt;outgoing_headers as $k =&gt; $v){
+			$hdr = $k.': '.$v;
+			$this-&gt;debug(&quot;HTTP header: $hdr&quot;);
+			$this-&gt;outgoing_payload .= &quot;$hdr\r\n&quot;;
+		}
+
+		// add any cookies
+		if ($cookie_str != '') {
+			$hdr = 'Cookie: '.$cookie_str;
+			$this-&gt;debug(&quot;HTTP header: $hdr&quot;);
+			$this-&gt;outgoing_payload .= &quot;$hdr\r\n&quot;;
+		}
+
+		// header/body separator
+		$this-&gt;outgoing_payload .= &quot;\r\n&quot;;
+		
+		// add data
+		$this-&gt;outgoing_payload .= $data;
+	}
+
+	function sendRequest($data, $cookies = NULL) {
+		// build cookie string
+		$cookie_str = $this-&gt;getCookiesForRequest($cookies, (($this-&gt;scheme == 'ssl') || ($this-&gt;scheme == 'https')));
+
+		// build payload
+		$this-&gt;buildPayload($data, $cookie_str);
+
+	  if ($this-&gt;scheme == 'http' || $this-&gt;scheme == 'ssl') {
+		// send payload
+		if(!fputs($this-&gt;fp, $this-&gt;outgoing_payload, strlen($this-&gt;outgoing_payload))) {
+			$this-&gt;setError('couldn\'t write message data to socket');
+			$this-&gt;debug('couldn\'t write message data to socket');
+			return false;
+		}
+		$this-&gt;debug('wrote data to socket, length = ' . strlen($this-&gt;outgoing_payload));
+		return true;
+	  } else if ($this-&gt;scheme == 'https') {
+		// set payload
+		// TODO: cURL does say this should only be the verb, and in fact it
+		// turns out that the URI and HTTP version are appended to this, which
+		// some servers refuse to work with
+		//curl_setopt($this-&gt;ch, CURLOPT_CUSTOMREQUEST, $this-&gt;outgoing_payload);
+		foreach($this-&gt;outgoing_headers as $k =&gt; $v){
+			$curl_headers[] = &quot;$k: $v&quot;;
+		}
+		if ($cookie_str != '') {
+			$curl_headers[] = 'Cookie: ' . $cookie_str;
+		}
+		curl_setopt($this-&gt;ch, CURLOPT_HTTPHEADER, $curl_headers);
+		if ($this-&gt;request_method == &quot;POST&quot;) {
+	  		curl_setopt($this-&gt;ch, CURLOPT_POST, 1);
+	  		curl_setopt($this-&gt;ch, CURLOPT_POSTFIELDS, $data);
+	  	} else {
+	  	}
+		$this-&gt;debug('set cURL payload');
+		return true;
+	  }
+	}
+
+	function getResponse(){
+		$this-&gt;incoming_payload = '';
+	    
+	  if ($this-&gt;scheme == 'http' || $this-&gt;scheme == 'ssl') {
+	    // loop until headers have been retrieved
+	    $data = '';
+	    while (!isset($lb)){
+
+			// We might EOF during header read.
+			if(feof($this-&gt;fp)) {
+				$this-&gt;incoming_payload = $data;
+				$this-&gt;debug('found no headers before EOF after length ' . strlen($data));
+				$this-&gt;debug(&quot;received before EOF:\n&quot; . $data);
+				$this-&gt;setError('server failed to send headers');
+				return false;
+			}
+
+			$tmp = fgets($this-&gt;fp, 256);
+			$tmplen = strlen($tmp);
+			$this-&gt;debug(&quot;read line of $tmplen bytes: &quot; . trim($tmp));
+
+			if ($tmplen == 0) {
+				$this-&gt;incoming_payload = $data;
+				$this-&gt;debug('socket read of headers timed out after length ' . strlen($data));
+				$this-&gt;debug(&quot;read before timeout: &quot; . $data);
+				$this-&gt;setError('socket read of headers timed out');
+				return false;
+			}
+
+			$data .= $tmp;
+			$pos = strpos($data,&quot;\r\n\r\n&quot;);
+			if($pos &gt; 1){
+				$lb = &quot;\r\n&quot;;
+			} else {
+				$pos = strpos($data,&quot;\n\n&quot;);
+				if($pos &gt; 1){
+					$lb = &quot;\n&quot;;
+				}
+			}
+			// remove 100 header
+			if(isset($lb) &amp;&amp; ereg('^HTTP/1.1 100',$data)){
+				unset($lb);
+				$data = '';
+			}//
+		}
+		// store header data
+		$this-&gt;incoming_payload .= $data;
+		$this-&gt;debug('found end of headers after length ' . strlen($data));
+		// process headers
+		$header_data = trim(substr($data,0,$pos));
+		$header_array = explode($lb,$header_data);
+		$this-&gt;incoming_headers = array();
+		$this-&gt;incoming_cookies = array();
+		foreach($header_array as $header_line){
+			$arr = explode(':',$header_line, 2);
+			if(count($arr) &gt; 1){
+				$header_name = strtolower(trim($arr[0]));
+				$this-&gt;incoming_headers[$header_name] = trim($arr[1]);
+				if ($header_name == 'set-cookie') {
+					// TODO: allow multiple cookies from parseCookie
+					$cookie = $this-&gt;parseCookie(trim($arr[1]));
+					if ($cookie) {
+						$this-&gt;incoming_cookies[] = $cookie;
+						$this-&gt;debug('found cookie: ' . $cookie['name'] . ' = ' . $cookie['value']);
+					} else {
+						$this-&gt;debug('did not find cookie in ' . trim($arr[1]));
+					}
+    			}
+			} else if (isset($header_name)) {
+				// append continuation line to previous header
+				$this-&gt;incoming_headers[$header_name] .= $lb . ' ' . $header_line;
+			}
+		}
+		
+		// loop until msg has been received
+		if (isset($this-&gt;incoming_headers['transfer-encoding']) &amp;&amp; strtolower($this-&gt;incoming_headers['transfer-encoding']) == 'chunked') {
+			$content_length =  2147483647;	// ignore any content-length header
+			$chunked = true;
+			$this-&gt;debug(&quot;want to read chunked content&quot;);
+		} elseif (isset($this-&gt;incoming_headers['content-length'])) {
+			$content_length = $this-&gt;incoming_headers['content-length'];
+			$chunked = false;
+			$this-&gt;debug(&quot;want to read content of length $content_length&quot;);
+		} else {
+			$content_length =  2147483647;
+			$chunked = false;
+			$this-&gt;debug(&quot;want to read content to EOF&quot;);
+		}
+		$data = '';
+		do {
+			if ($chunked) {
+				$tmp = fgets($this-&gt;fp, 256);
+				$tmplen = strlen($tmp);
+				$this-&gt;debug(&quot;read chunk line of $tmplen bytes&quot;);
+				if ($tmplen == 0) {
+					$this-&gt;incoming_payload = $data;
+					$this-&gt;debug('socket read of chunk length timed out after length ' . strlen($data));
+					$this-&gt;debug(&quot;read before timeout:\n&quot; . $data);
+					$this-&gt;setError('socket read of chunk length timed out');
+					return false;
+				}
+				$content_length = hexdec(trim($tmp));
+				$this-&gt;debug(&quot;chunk length $content_length&quot;);
+			}
+			$strlen = 0;
+		    while (($strlen &lt; $content_length) &amp;&amp; (!feof($this-&gt;fp))) {
+		    	$readlen = min(8192, $content_length - $strlen);
+				$tmp = fread($this-&gt;fp, $readlen);
+				$tmplen = strlen($tmp);
+				$this-&gt;debug(&quot;read buffer of $tmplen bytes&quot;);
+				if (($tmplen == 0) &amp;&amp; (!feof($this-&gt;fp))) {
+					$this-&gt;incoming_payload = $data;
+					$this-&gt;debug('socket read of body timed out after length ' . strlen($data));
+					$this-&gt;debug(&quot;read before timeout:\n&quot; . $data);
+					$this-&gt;setError('socket read of body timed out');
+					return false;
+				}
+				$strlen += $tmplen;
+				$data .= $tmp;
+			}
+			if ($chunked &amp;&amp; ($content_length &gt; 0)) {
+				$tmp = fgets($this-&gt;fp, 256);
+				$tmplen = strlen($tmp);
+				$this-&gt;debug(&quot;read chunk terminator of $tmplen bytes&quot;);
+				if ($tmplen == 0) {
+					$this-&gt;incoming_payload = $data;
+					$this-&gt;debug('socket read of chunk terminator timed out after length ' . strlen($data));
+					$this-&gt;debug(&quot;read before timeout:\n&quot; . $data);
+					$this-&gt;setError('socket read of chunk terminator timed out');
+					return false;
+				}
+			}
+		} while ($chunked &amp;&amp; ($content_length &gt; 0) &amp;&amp; (!feof($this-&gt;fp)));
+		if (feof($this-&gt;fp)) {
+			$this-&gt;debug('read to EOF');
+		}
+		$this-&gt;debug('read body of length ' . strlen($data));
+		$this-&gt;incoming_payload .= $data;
+		$this-&gt;debug('received a total of '.strlen($this-&gt;incoming_payload).' bytes of data from server');
+		
+		// close filepointer
+		if(
+			(isset($this-&gt;incoming_headers['connection']) &amp;&amp; strtolower($this-&gt;incoming_headers['connection']) == 'close') || 
+			(! $this-&gt;persistentConnection) || feof($this-&gt;fp)){
+			fclose($this-&gt;fp);
+			$this-&gt;fp = false;
+			$this-&gt;debug('closed socket');
+		}
+		
+		// connection was closed unexpectedly
+		if($this-&gt;incoming_payload == ''){
+			$this-&gt;setError('no response from server');
+			return false;
+		}
+		
+		// decode transfer-encoding
+//		if(isset($this-&gt;incoming_headers['transfer-encoding']) &amp;&amp; strtolower($this-&gt;incoming_headers['transfer-encoding']) == 'chunked'){
+//			if(!$data = $this-&gt;decodeChunked($data, $lb)){
+//				$this-&gt;setError('Decoding of chunked data failed');
+//				return false;
+//			}
+			//print &quot;&lt;pre&gt;\nde-chunked:\n---------------\n$data\n\n---------------\n&lt;/pre&gt;&quot;;
+			// set decoded payload
+//			$this-&gt;incoming_payload = $header_data.$lb.$lb.$data;
+//		}
+	
+	  } else if ($this-&gt;scheme == 'https') {
+		// send and receive
+		$this-&gt;debug('send and receive with cURL');
+		$this-&gt;incoming_payload = curl_exec($this-&gt;ch);
+		$data = $this-&gt;incoming_payload;
+
+        $cErr = curl_error($this-&gt;ch);
+		if ($cErr != '') {
+        	$err = 'cURL ERROR: '.curl_errno($this-&gt;ch).': '.$cErr.'&lt;br&gt;';
+        	// TODO: there is a PHP bug that can cause this to SEGV for CURLINFO_CONTENT_TYPE
+			foreach(curl_getinfo($this-&gt;ch) as $k =&gt; $v){
+				$err .= &quot;$k: $v&lt;br&gt;&quot;;
+			}
+			$this-&gt;debug($err);
+			$this-&gt;setError($err);
+			curl_close($this-&gt;ch);
+	    	return false;
+		} else {
+			//echo '&lt;pre&gt;';
+			//var_dump(curl_getinfo($this-&gt;ch));
+			//echo '&lt;/pre&gt;';
+		}
+		// close curl
+		$this-&gt;debug('No cURL error, closing cURL');
+		curl_close($this-&gt;ch);
+		
+		// remove 100 header(s)
+		while (ereg('^HTTP/1.1 100',$data)) {
+			if ($pos = strpos($data,&quot;\r\n\r\n&quot;)) {
+				$data = ltrim(substr($data,$pos));
+			} elseif($pos = strpos($data,&quot;\n\n&quot;) ) {
+				$data = ltrim(substr($data,$pos));
+			}
+		}
+		
+		// separate content from HTTP headers
+		if ($pos = strpos($data,&quot;\r\n\r\n&quot;)) {
+			$lb = &quot;\r\n&quot;;
+		} elseif( $pos = strpos($data,&quot;\n\n&quot;)) {
+			$lb = &quot;\n&quot;;
+		} else {
+			$this-&gt;debug('no proper separation of headers and document');
+			$this-&gt;setError('no proper separation of headers and document');
+			return false;
+		}
+		$header_data = trim(substr($data,0,$pos));
+		$header_array = explode($lb,$header_data);
+		$data = ltrim(substr($data,$pos));
+		$this-&gt;debug('found proper separation of headers and document');
+		$this-&gt;debug('cleaned data, stringlen: '.strlen($data));
+		// clean headers
+		foreach ($header_array as $header_line) {
+			$arr = explode(':',$header_line,2);
+			if(count($arr) &gt; 1){
+				$header_name = strtolower(trim($arr[0]));
+				$this-&gt;incoming_headers[$header_name] = trim($arr[1]);
+				if ($header_name == 'set-cookie') {
+					// TODO: allow multiple cookies from parseCookie
+					$cookie = $this-&gt;parseCookie(trim($arr[1]));
+					if ($cookie) {
+						$this-&gt;incoming_cookies[] = $cookie;
+						$this-&gt;debug('found cookie: ' . $cookie['name'] . ' = ' . $cookie['value']);
+					} else {
+						$this-&gt;debug('did not find cookie in ' . trim($arr[1]));
+					}
+    			}
+			} else if (isset($header_name)) {
+				// append continuation line to previous header
+				$this-&gt;incoming_headers[$header_name] .= $lb . ' ' . $header_line;
+			}
+		}
+	  }
+
+		$arr = explode(' ', $header_array[0], 3);
+		$http_version = $arr[0];
+		$http_status = intval($arr[1]);
+		$http_reason = count($arr) &gt; 2 ? $arr[2] : '';
+
+ 		// see if we need to resend the request with http digest authentication
+ 		if (isset($this-&gt;incoming_headers['location']) &amp;&amp; $http_status == 301) {
+ 			$this-&gt;debug(&quot;Got 301 $http_reason with Location: &quot; . $this-&gt;incoming_headers['location']);
+ 			$this-&gt;setURL($this-&gt;incoming_headers['location']);
+			$this-&gt;tryagain = true;
+			return false;
+		}
+
+ 		// see if we need to resend the request with http digest authentication
+ 		if (isset($this-&gt;incoming_headers['www-authenticate']) &amp;&amp; $http_status == 401) {
+ 			$this-&gt;debug(&quot;Got 401 $http_reason with WWW-Authenticate: &quot; . $this-&gt;incoming_headers['www-authenticate']);
+ 			if (strstr($this-&gt;incoming_headers['www-authenticate'], &quot;Digest &quot;)) {
+ 				$this-&gt;debug('Server wants digest authentication');
+ 				// remove &quot;Digest &quot; from our elements
+ 				$digestString = str_replace('Digest ', '', $this-&gt;incoming_headers['www-authenticate']);
+ 				
+ 				// parse elements into array
+ 				$digestElements = explode(',', $digestString);
+ 				foreach ($digestElements as $val) {
+ 					$tempElement = explode('=', trim($val), 2);
+ 					$digestRequest[$tempElement[0]] = str_replace(&quot;\&quot;&quot;, '', $tempElement[1]);
+ 				}
+
+				// should have (at least) qop, realm, nonce
+ 				if (isset($digestRequest['nonce'])) {
+ 					$this-&gt;setCredentials($this-&gt;username, $this-&gt;password, 'digest', $digestRequest);
+ 					$this-&gt;tryagain = true;
+ 					return false;
+ 				}
+ 			}
+			$this-&gt;debug('HTTP authentication failed');
+			$this-&gt;setError('HTTP authentication failed');
+			return false;
+ 		}
+		
+		if (
+			($http_status &gt;= 300 &amp;&amp; $http_status &lt;= 307) ||
+			($http_status &gt;= 400 &amp;&amp; $http_status &lt;= 417) ||
+			($http_status &gt;= 501 &amp;&amp; $http_status &lt;= 505)
+		   ) {
+			$this-&gt;setError(&quot;Unsupported HTTP response status $http_status $http_reason (soapclient-&gt;response has contents of the response)&quot;);
+			return false;
+		}
+
+		// decode content-encoding
+		if(isset($this-&gt;incoming_headers['content-encoding']) &amp;&amp; $this-&gt;incoming_headers['content-encoding'] != ''){
+			if(strtolower($this-&gt;incoming_headers['content-encoding']) == 'deflate' || strtolower($this-&gt;incoming_headers['content-encoding']) == 'gzip'){
+    			// if decoding works, use it. else assume data wasn't gzencoded
+    			if(function_exists('gzinflate')){
+					//$timer-&gt;setMarker('starting decoding of gzip/deflated content');
+					// IIS 5 requires gzinflate instead of gzuncompress (similar to IE 5 and gzdeflate v. gzcompress)
+					// this means there are no Zlib headers, although there should be
+					$this-&gt;debug('The gzinflate function exists');
+					$datalen = strlen($data);
+					if ($this-&gt;incoming_headers['content-encoding'] == 'deflate') {
+						if ($degzdata = @gzinflate($data)) {
+	    					$data = $degzdata;
+	    					$this-&gt;debug('The payload has been inflated to ' . strlen($data) . ' bytes');
+	    					if (strlen($data) &lt; $datalen) {
+	    						// test for the case that the payload has been compressed twice
+		    					$this-&gt;debug('The inflated payload is smaller than the gzipped one; try again');
+								if ($degzdata = @gzinflate($data)) {
+			    					$data = $degzdata;
+			    					$this-&gt;debug('The payload has been inflated again to ' . strlen($data) . ' bytes');
+								}
+	    					}
+	    				} else {
+	    					$this-&gt;debug('Error using gzinflate to inflate the payload');
+	    					$this-&gt;setError('Error using gzinflate to inflate the payload');
+	    				}
+					} elseif ($this-&gt;incoming_headers['content-encoding'] == 'gzip') {
+						if ($degzdata = @gzinflate(substr($data, 10))) {	// do our best
+							$data = $degzdata;
+	    					$this-&gt;debug('The payload has been un-gzipped to ' . strlen($data) . ' bytes');
+	    					if (strlen($data) &lt; $datalen) {
+	    						// test for the case that the payload has been compressed twice
+		    					$this-&gt;debug('The un-gzipped payload is smaller than the gzipped one; try again');
+								if ($degzdata = @gzinflate(substr($data, 10))) {
+			    					$data = $degzdata;
+			    					$this-&gt;debug('The payload has been un-gzipped again to ' . strlen($data) . ' bytes');
+								}
+	    					}
+	    				} else {
+	    					$this-&gt;debug('Error using gzinflate to un-gzip the payload');
+							$this-&gt;setError('Error using gzinflate to un-gzip the payload');
+	    				}
+					}
+					//$timer-&gt;setMarker('finished decoding of gzip/deflated content');
+					//print &quot;&lt;xmp&gt;\nde-inflated:\n---------------\n$data\n-------------\n&lt;/xmp&gt;&quot;;
+					// set decoded payload
+					$this-&gt;incoming_payload = $header_data.$lb.$lb.$data;
+    			} else {
+					$this-&gt;debug('The server sent compressed data. Your php install must have the Zlib extension compiled in to support this.');
+					$this-&gt;setError('The server sent compressed data. Your php install must have the Zlib extension compiled in to support this.');
+				}
+			} else {
+				$this-&gt;debug('Unsupported Content-Encoding ' . $this-&gt;incoming_headers['content-encoding']);
+				$this-&gt;setError('Unsupported Content-Encoding ' . $this-&gt;incoming_headers['content-encoding']);
+			}
+		} else {
+			$this-&gt;debug('No Content-Encoding header');
+		}
+		
+		if(strlen($data) == 0){
+			$this-&gt;debug('no data after headers!');
+			$this-&gt;setError('no data present after HTTP headers');
+			return false;
+		}
+		
+		return $data;
+	}
+
+	function setContentType($type, $charset = false) {
+		$this-&gt;outgoing_headers['Content-Type'] = $type . ($charset ? '; charset=' . $charset : '');
+		$this-&gt;debug('set Content-Type: ' . $this-&gt;outgoing_headers['Content-Type']);
+	}
+
+	function usePersistentConnection(){
+		if (isset($this-&gt;outgoing_headers['Accept-Encoding'])) {
+			return false;
+		}
+		$this-&gt;protocol_version = '1.1';
+		$this-&gt;persistentConnection = true;
+		$this-&gt;outgoing_headers['Connection'] = 'Keep-Alive';
+		$this-&gt;debug('set Connection: ' . $this-&gt;outgoing_headers['Connection']);
+		return true;
+	}
+
+	/**
+	 * parse an incoming Cookie into it's parts
+	 *
+	 * @param	string $cookie_str content of cookie
+	 * @return	array with data of that cookie
+	 * @access	private
+	 */
+	/*
+	 * TODO: allow a Set-Cookie string to be parsed into multiple cookies
+	 */
+	function parseCookie($cookie_str) {
+		$cookie_str = str_replace('; ', ';', $cookie_str) . ';';
+		$data = split(';', $cookie_str);
+		$value_str = $data[0];
+
+		$cookie_param = 'domain=';
+		$start = strpos($cookie_str, $cookie_param);
+		if ($start &gt; 0) {
+			$domain = substr($cookie_str, $start + strlen($cookie_param));
+			$domain = substr($domain, 0, strpos($domain, ';'));
+		} else {
+			$domain = '';
+		}
+
+		$cookie_param = 'expires=';
+		$start = strpos($cookie_str, $cookie_param);
+		if ($start &gt; 0) {
+			$expires = substr($cookie_str, $start + strlen($cookie_param));
+			$expires = substr($expires, 0, strpos($expires, ';'));
+		} else {
+			$expires = '';
+		}
+
+		$cookie_param = 'path=';
+		$start = strpos($cookie_str, $cookie_param);
+		if ( $start &gt; 0 ) {
+			$path = substr($cookie_str, $start + strlen($cookie_param));
+			$path = substr($path, 0, strpos($path, ';'));
+		} else {
+			$path = '/';
+		}
+						
+		$cookie_param = ';secure;';
+		if (strpos($cookie_str, $cookie_param) !== FALSE) {
+			$secure = true;
+		} else {
+			$secure = false;
+		}
+
+		$sep_pos = strpos($value_str, '=');
+
+		if ($sep_pos) {
+			$name = substr($value_str, 0, $sep_pos);
+			$value = substr($value_str, $sep_pos + 1);
+			$cookie= array(	'name' =&gt; $name,
+			                'value' =&gt; $value,
+							'domain' =&gt; $domain,
+							'path' =&gt; $path,
+							'expires' =&gt; $expires,
+							'secure' =&gt; $secure
+							);		
+			return $cookie;
+		}
+		return false;
+	}
+  
+	/**
+	 * sort out cookies for the current request
+	 *
+	 * @param	array $cookies array with all cookies
+	 * @param	boolean $secure is the send-content secure or not?
+	 * @return	string for Cookie-HTTP-Header
+	 * @access	private
+	 */
+	function getCookiesForRequest($cookies, $secure=false) {
+		$cookie_str = '';
+		if ((! is_null($cookies)) &amp;&amp; (is_array($cookies))) {
+			foreach ($cookies as $cookie) {
+				if (! is_array($cookie)) {
+					continue;
+				}
+	    		$this-&gt;debug(&quot;check cookie for validity: &quot;.$cookie['name'].'='.$cookie['value']);
+				if ((isset($cookie['expires'])) &amp;&amp; (! empty($cookie['expires']))) {
+					if (strtotime($cookie['expires']) &lt;= time()) {
+						$this-&gt;debug('cookie has expired');
+						continue;
+					}
+				}
+				if ((isset($cookie['domain'])) &amp;&amp; (! empty($cookie['domain']))) {
+					$domain = preg_quote($cookie['domain']);
+					if (! preg_match(&quot;'.*$domain$'i&quot;, $this-&gt;host)) {
+						$this-&gt;debug('cookie has different domain');
+						continue;
+					}
+				}
+				if ((isset($cookie['path'])) &amp;&amp; (! empty($cookie['path']))) {
+					$path = preg_quote($cookie['path']);
+					if (! preg_match(&quot;'^$path.*'i&quot;, $this-&gt;path)) {
+						$this-&gt;debug('cookie is for a different path');
+						continue;
+					}
+				}
+				if ((! $secure) &amp;&amp; (isset($cookie['secure'])) &amp;&amp; ($cookie['secure'])) {
+					$this-&gt;debug('cookie is secure, transport is not');
+					continue;
+				}
+				$cookie_str .= $cookie['name'] . '=' . $cookie['value'] . '; ';
+	    		$this-&gt;debug('add cookie to Cookie-String: ' . $cookie['name'] . '=' . $cookie['value']);
+			}
+		}
+		return $cookie_str;
+  }
+}
+
+?&gt;&lt;?php
+
+
+
+/**
+*
+* soap_server allows the user to create a SOAP server
+* that is capable of receiving messages and returning responses
+*
+* NOTE: WSDL functionality is experimental
+*
+* @author   Dietrich Ayala &lt;<A HREF="https://lists.berlios.de/mailman/listinfo/viperals-svncheckins">dietrich at ganx4.com</A>&gt;
+* @version  $Id: nusoap.php,v 1.94 2005/08/04 01:27:42 snichol Exp $
+* @access   public
+*/
+class soap_server extends nusoap_base {
+	/**
+	 * HTTP headers of request
+	 * @var array
+	 * @access private
+	 */
+	var $headers = array();
+	/**
+	 * HTTP request
+	 * @var string
+	 * @access private
+	 */
+	var $request = '';
+	/**
+	 * SOAP headers from request (incomplete namespace resolution; special characters not escaped) (text)
+	 * @var string
+	 * @access public
+	 */
+	var $requestHeaders = '';
+	/**
+	 * SOAP body request portion (incomplete namespace resolution; special characters not escaped) (text)
+	 * @var string
+	 * @access public
+	 */
+	var $document = '';
+	/**
+	 * SOAP payload for request (text)
+	 * @var string
+	 * @access public
+	 */
+	var $requestSOAP = '';
+	/**
+	 * requested method namespace URI
+	 * @var string
+	 * @access private
+	 */
+	var $methodURI = '';
+	/**
+	 * name of method requested
+	 * @var string
+	 * @access private
+	 */
+	var $methodname = '';
+	/**
+	 * method parameters from request
+	 * @var array
+	 * @access private
+	 */
+	var $methodparams = array();
+	/**
+	 * SOAP Action from request
+	 * @var string
+	 * @access private
+	 */
+	var $SOAPAction = '';
+	/**
+	 * character set encoding of incoming (request) messages
+	 * @var string
+	 * @access public
+	 */
+	var $xml_encoding = '';
+	/**
+	 * toggles whether the parser decodes element content w/ utf8_decode()
+	 * @var boolean
+	 * @access public
+	 */
+    var $decode_utf8 = true;
+
+	/**
+	 * HTTP headers of response
+	 * @var array
+	 * @access public
+	 */
+	var $outgoing_headers = array();
+	/**
+	 * HTTP response
+	 * @var string
+	 * @access private
+	 */
+	var $response = '';
+	/**
+	 * SOAP headers for response (text)
+	 * @var string
+	 * @access public
+	 */
+	var $responseHeaders = '';
+	/**
+	 * SOAP payload for response (text)
+	 * @var string
+	 * @access private
+	 */
+	var $responseSOAP = '';
+	/**
+	 * method return value to place in response
+	 * @var mixed
+	 * @access private
+	 */
+	var $methodreturn = false;
+	/**
+	 * whether $methodreturn is a string of literal XML
+	 * @var boolean
+	 * @access public
+	 */
+	var $methodreturnisliteralxml = false;
+	/**
+	 * SOAP fault for response (or false)
+	 * @var mixed
+	 * @access private
+	 */
+	var $fault = false;
+	/**
+	 * text indication of result (for debugging)
+	 * @var string
+	 * @access private
+	 */
+	var $result = 'successful';
+
+	/**
+	 * assoc array of operations =&gt; opData; operations are added by the register()
+	 * method or by parsing an external WSDL definition
+	 * @var array
+	 * @access private
+	 */
+	var $operations = array();
+	/**
+	 * wsdl instance (if one)
+	 * @var mixed
+	 * @access private
+	 */
+	var $wsdl = false;
+	/**
+	 * URL for WSDL (if one)
+	 * @var mixed
+	 * @access private
+	 */
+	var $externalWSDLURL = false;
+	/**
+	 * whether to append debug to response as XML comment
+	 * @var boolean
+	 * @access public
+	 */
+	var $debug_flag = false;
+
+
+	/**
+	* constructor
+    * the optional parameter is a path to a WSDL file that you'd like to bind the server instance to.
+	*
+    * @param mixed $wsdl file path or URL (string), or wsdl instance (object)
+	* @access   public
+	*/
+	function soap_server($wsdl=false){
+		parent::nusoap_base();
+		// turn on debugging?
+		global $debug;
+		global $HTTP_SERVER_VARS;
+
+		if (isset($_SERVER)) {
+			$this-&gt;debug(&quot;_SERVER is defined:&quot;);
+			$this-&gt;appendDebug($this-&gt;varDump($_SERVER));
+		} elseif (isset($HTTP_SERVER_VARS)) {
+			$this-&gt;debug(&quot;HTTP_SERVER_VARS is defined:&quot;);
+			$this-&gt;appendDebug($this-&gt;varDump($HTTP_SERVER_VARS));
+		} else {
+			$this-&gt;debug(&quot;Neither _SERVER nor HTTP_SERVER_VARS is defined.&quot;);
+		}
+
+		if (isset($debug)) {
+			$this-&gt;debug(&quot;In soap_server, set debug_flag=$debug based on global flag&quot;);
+			$this-&gt;debug_flag = $debug;
+		} elseif (isset($_SERVER['QUERY_STRING'])) {
+			$qs = explode('&amp;', $_SERVER['QUERY_STRING']);
+			foreach ($qs as $v) {
+				if (substr($v, 0, 6) == 'debug=') {
+					$this-&gt;debug(&quot;In soap_server, set debug_flag=&quot; . substr($v, 6) . &quot; based on query string #1&quot;);
+					$this-&gt;debug_flag = substr($v, 6);
+				}
+			}
+		} elseif (isset($HTTP_SERVER_VARS['QUERY_STRING'])) {
+			$qs = explode('&amp;', $HTTP_SERVER_VARS['QUERY_STRING']);
+			foreach ($qs as $v) {
+				if (substr($v, 0, 6) == 'debug=') {
+					$this-&gt;debug(&quot;In soap_server, set debug_flag=&quot; . substr($v, 6) . &quot; based on query string #2&quot;);
+					$this-&gt;debug_flag = substr($v, 6);
+				}
+			}
+		}
+
+		// wsdl
+		if($wsdl){
+			$this-&gt;debug(&quot;In soap_server, WSDL is specified&quot;);
+			if (is_object($wsdl) &amp;&amp; (get_class($wsdl) == 'wsdl')) {
+				$this-&gt;wsdl = $wsdl;
+				$this-&gt;externalWSDLURL = $this-&gt;wsdl-&gt;wsdl;
+				$this-&gt;debug('Use existing wsdl instance from ' . $this-&gt;externalWSDLURL);
+			} else {
+				$this-&gt;debug('Create wsdl from ' . $wsdl);
+				$this-&gt;wsdl = new wsdl($wsdl);
+				$this-&gt;externalWSDLURL = $wsdl;
+			}
+			$this-&gt;appendDebug($this-&gt;wsdl-&gt;getDebug());
+			$this-&gt;wsdl-&gt;clearDebug();
+			if($err = $this-&gt;wsdl-&gt;getError()){
+				die('WSDL ERROR: '.$err);
+			}
+		}
+	}
+
+	/**
+	* processes request and returns response
+	*
+	* @param    string $data usually is the value of $HTTP_RAW_POST_DATA
+	* @access   public
+	*/
+	function service($data){
+		global $HTTP_SERVER_VARS;
+
+		if (isset($_SERVER['QUERY_STRING'])) {
+			$qs = $_SERVER['QUERY_STRING'];
+		} elseif (isset($HTTP_SERVER_VARS['QUERY_STRING'])) {
+			$qs = $HTTP_SERVER_VARS['QUERY_STRING'];
+		} else {
+			$qs = '';
+		}
+		$this-&gt;debug(&quot;In service, query string=$qs&quot;);
+
+		if (ereg('wsdl', $qs) ){
+			$this-&gt;debug(&quot;In service, this is a request for WSDL&quot;);
+			if($this-&gt;externalWSDLURL){
+              if (strpos($this-&gt;externalWSDLURL,&quot;://&quot;)!==false) { // assume URL
+				header('Location: '.$this-&gt;externalWSDLURL);
+              } else { // assume file
+                header(&quot;Content-Type: text/xml\r\n&quot;);
+                $fp = fopen($this-&gt;externalWSDLURL, 'r');
+                fpassthru($fp);
+              }
+			} elseif ($this-&gt;wsdl) {
+				header(&quot;Content-Type: text/xml; charset=ISO-8859-1\r\n&quot;);
+				print $this-&gt;wsdl-&gt;serialize($this-&gt;debug_flag);
+				if ($this-&gt;debug_flag) {
+					$this-&gt;debug('wsdl:');
+					$this-&gt;appendDebug($this-&gt;varDump($this-&gt;wsdl));
+					print $this-&gt;getDebugAsXMLComment();
+				}
+			} else {
+				header(&quot;Content-Type: text/html; charset=ISO-8859-1\r\n&quot;);
+				print &quot;This service does not provide WSDL&quot;;
+			}
+		} elseif ($data == '' &amp;&amp; $this-&gt;wsdl) {
+			$this-&gt;debug(&quot;In service, there is no data, so return Web description&quot;);
+			print $this-&gt;wsdl-&gt;webDescription();
+		} else {
+			$this-&gt;debug(&quot;In service, invoke the request&quot;);
+			$this-&gt;parse_request($data);
+			if (! $this-&gt;fault) {
+				$this-&gt;invoke_method();
+			}
+			if (! $this-&gt;fault) {
+				$this-&gt;serialize_return();
+			}
+			$this-&gt;send_response();
+		}
+	}
+
+	/**
+	* parses HTTP request headers.
+	*
+	* The following fields are set by this function (when successful)
+	*
+	* headers
+	* request
+	* xml_encoding
+	* SOAPAction
+	*
+	* @access   private
+	*/
+	function parse_http_headers() {
+		global $HTTP_SERVER_VARS;
+
+		$this-&gt;request = '';
+		$this-&gt;SOAPAction = '';
+		if(function_exists('getallheaders')){
+			$this-&gt;debug(&quot;In parse_http_headers, use getallheaders&quot;);
+			$headers = getallheaders();
+			foreach($headers as $k=&gt;$v){
+				$k = strtolower($k);
+				$this-&gt;headers[$k] = $v;
+				$this-&gt;request .= &quot;$k: $v\r\n&quot;;
+				$this-&gt;debug(&quot;$k: $v&quot;);
+			}
+			// get SOAPAction header
+			if(isset($this-&gt;headers['soapaction'])){
+				$this-&gt;SOAPAction = str_replace('&quot;','',$this-&gt;headers['soapaction']);
+			}
+			// get the character encoding of the incoming request
+			if(isset($this-&gt;headers['content-type']) &amp;&amp; strpos($this-&gt;headers['content-type'],'=')){
+				$enc = str_replace('&quot;','',substr(strstr($this-&gt;headers[&quot;content-type&quot;],'='),1));
+				if(eregi('^(ISO-8859-1|US-ASCII|UTF-8)$',$enc)){
+					$this-&gt;xml_encoding = strtoupper($enc);
+				} else {
+					$this-&gt;xml_encoding = 'US-ASCII';
+				}
+			} else {
+				// should be US-ASCII for HTTP 1.0 or ISO-8859-1 for HTTP 1.1
+				$this-&gt;xml_encoding = 'ISO-8859-1';
+			}
+		} elseif(isset($_SERVER) &amp;&amp; is_array($_SERVER)){
+			$this-&gt;debug(&quot;In parse_http_headers, use _SERVER&quot;);
+			foreach ($_SERVER as $k =&gt; $v) {
+				if (substr($k, 0, 5) == 'HTTP_') {
+					$k = str_replace(' ', '-', strtolower(str_replace('_', ' ', substr($k, 5)))); 	                                         $k = strtolower(substr($k, 5));
+				} else {
+					$k = str_replace(' ', '-', strtolower(str_replace('_', ' ', $k))); 	                                         $k = strtolower($k);
+				}
+				if ($k == 'soapaction') {
+					// get SOAPAction header
+					$k = 'SOAPAction';
+					$v = str_replace('&quot;', '', $v);
+					$v = str_replace('\\', '', $v);
+					$this-&gt;SOAPAction = $v;
+				} else if ($k == 'content-type') {
+					// get the character encoding of the incoming request
+					if (strpos($v, '=')) {
+						$enc = substr(strstr($v, '='), 1);
+						$enc = str_replace('&quot;', '', $enc);
+						$enc = str_replace('\\', '', $enc);
+						if (eregi('^(ISO-8859-1|US-ASCII|UTF-8)$', $enc)) {
+							$this-&gt;xml_encoding = strtoupper($enc);
+						} else {
+							$this-&gt;xml_encoding = 'US-ASCII';
+						}
+					} else {
+						// should be US-ASCII for HTTP 1.0 or ISO-8859-1 for HTTP 1.1
+						$this-&gt;xml_encoding = 'ISO-8859-1';
+					}
+				}
+				$this-&gt;headers[$k] = $v;
+				$this-&gt;request .= &quot;$k: $v\r\n&quot;;
+				$this-&gt;debug(&quot;$k: $v&quot;);
+			}
+		} elseif (is_array($HTTP_SERVER_VARS)) {
+			$this-&gt;debug(&quot;In parse_http_headers, use HTTP_SERVER_VARS&quot;);
+			foreach ($HTTP_SERVER_VARS as $k =&gt; $v) {
+				if (substr($k, 0, 5) == 'HTTP_') {
+					$k = str_replace(' ', '-', strtolower(str_replace('_', ' ', substr($k, 5)))); 	                                         $k = strtolower(substr($k, 5));
+				} else {
+					$k = str_replace(' ', '-', strtolower(str_replace('_', ' ', $k))); 	                                         $k = strtolower($k);
+				}
+				if ($k == 'soapaction') {
+					// get SOAPAction header
+					$k = 'SOAPAction';
+					$v = str_replace('&quot;', '', $v);
+					$v = str_replace('\\', '', $v);
+					$this-&gt;SOAPAction = $v;
+				} else if ($k == 'content-type') {
+					// get the character encoding of the incoming request
+					if (strpos($v, '=')) {
+						$enc = substr(strstr($v, '='), 1);
+						$enc = str_replace('&quot;', '', $enc);
+						$enc = str_replace('\\', '', $enc);
+						if (eregi('^(ISO-8859-1|US-ASCII|UTF-8)$', $enc)) {
+							$this-&gt;xml_encoding = strtoupper($enc);
+						} else {
+							$this-&gt;xml_encoding = 'US-ASCII';
+						}
+					} else {
+						// should be US-ASCII for HTTP 1.0 or ISO-8859-1 for HTTP 1.1
+						$this-&gt;xml_encoding = 'ISO-8859-1';
+					}
+				}
+				$this-&gt;headers[$k] = $v;
+				$this-&gt;request .= &quot;$k: $v\r\n&quot;;
+				$this-&gt;debug(&quot;$k: $v&quot;);
+			}
+		} else {
+			$this-&gt;debug(&quot;In parse_http_headers, HTTP headers not accessible&quot;);
+			$this-&gt;setError(&quot;HTTP headers not accessible&quot;);
+		}
+	}
+
+	/**
+	* parses a request
+	*
+	* The following fields are set by this function (when successful)
+	*
+	* headers
+	* request
+	* xml_encoding
+	* SOAPAction
+	* request
+	* requestSOAP
+	* methodURI
+	* methodname
+	* methodparams
+	* requestHeaders
+	* document
+	*
+	* This sets the fault field on error
+	*
+	* @param    string $data XML string
+	* @access   private
+	*/
+	function parse_request($data='') {
+		$this-&gt;debug('entering parse_request()');
+		$this-&gt;parse_http_headers();
+		$this-&gt;debug('got character encoding: '.$this-&gt;xml_encoding);
+		// uncompress if necessary
+		if (isset($this-&gt;headers['content-encoding']) &amp;&amp; $this-&gt;headers['content-encoding'] != '') {
+			$this-&gt;debug('got content encoding: ' . $this-&gt;headers['content-encoding']);
+			if ($this-&gt;headers['content-encoding'] == 'deflate' || $this-&gt;headers['content-encoding'] == 'gzip') {
+		    	// if decoding works, use it. else assume data wasn't gzencoded
+				if (function_exists('gzuncompress')) {
+					if ($this-&gt;headers['content-encoding'] == 'deflate' &amp;&amp; $degzdata = @gzuncompress($data)) {
+						$data = $degzdata;
+					} elseif ($this-&gt;headers['content-encoding'] == 'gzip' &amp;&amp; $degzdata = gzinflate(substr($data, 10))) {
+						$data = $degzdata;
+					} else {
+						$this-&gt;fault('Client', 'Errors occurred when trying to decode the data');
+						return;
+					}
+				} else {
+					$this-&gt;fault('Client', 'This Server does not support compressed data');
+					return;
+				}
+			}
+		}
+		$this-&gt;request .= &quot;\r\n&quot;.$data;
+		$data = $this-&gt;parseRequest($this-&gt;headers, $data);
+		$this-&gt;requestSOAP = $data;
+		$this-&gt;debug('leaving parse_request');
+	}
+
+	/**
+	* invokes a PHP function for the requested SOAP method
+	*
+	* The following fields are set by this function (when successful)
+	*
+	* methodreturn
+	*
+	* Note that the PHP function that is called may also set the following
+	* fields to affect the response sent to the client
+	*
+	* responseHeaders
+	* outgoing_headers
+	*
+	* This sets the fault field on error
+	*
+	* @access   private
+	*/
+	function invoke_method() {
+		$this-&gt;debug('in invoke_method, methodname=' . $this-&gt;methodname . ' methodURI=' . $this-&gt;methodURI . ' SOAPAction=' . $this-&gt;SOAPAction);
+
+		if ($this-&gt;wsdl) {
+			if ($this-&gt;opData = $this-&gt;wsdl-&gt;getOperationData($this-&gt;methodname)) {
+				$this-&gt;debug('in invoke_method, found WSDL operation=' . $this-&gt;methodname);
+				$this-&gt;appendDebug('opData=' . $this-&gt;varDump($this-&gt;opData));
+			} elseif ($this-&gt;opData = $this-&gt;wsdl-&gt;getOperationDataForSoapAction($this-&gt;SOAPAction)) {
+				// Note: hopefully this case will only be used for doc/lit, since rpc services should have wrapper element
+				$this-&gt;debug('in invoke_method, found WSDL soapAction=' . $this-&gt;SOAPAction . ' for operation=' . $this-&gt;opData['name']);
+				$this-&gt;appendDebug('opData=' . $this-&gt;varDump($this-&gt;opData));
+				$this-&gt;methodname = $this-&gt;opData['name'];
+			} else {
+				$this-&gt;debug('in invoke_method, no WSDL for operation=' . $this-&gt;methodname);
+				$this-&gt;fault('Client', &quot;Operation '&quot; . $this-&gt;methodname . &quot;' is not defined in the WSDL for this service&quot;);
+				return;
+			}
+		} else {
+			$this-&gt;debug('in invoke_method, no WSDL to validate method');
+		}
+
+		// if a . is present in $this-&gt;methodname, we see if there is a class in scope,
+		// which could be referred to. We will also distinguish between two deliminators,
+		// to allow methods to be called a the class or an instance
+		$class = '';
+		$method = '';
+		if (strpos($this-&gt;methodname, '..') &gt; 0) {
+			$delim = '..';
+		} else if (strpos($this-&gt;methodname, '.') &gt; 0) {
+			$delim = '.';
+		} else {
+			$delim = '';
+		}
+
+		if (strlen($delim) &gt; 0 &amp;&amp; substr_count($this-&gt;methodname, $delim) == 1 &amp;&amp;
+			class_exists(substr($this-&gt;methodname, 0, strpos($this-&gt;methodname, $delim)))) {
+			// get the class and method name
+			$class = substr($this-&gt;methodname, 0, strpos($this-&gt;methodname, $delim));
+			$method = substr($this-&gt;methodname, strpos($this-&gt;methodname, $delim) + strlen($delim));
+			$this-&gt;debug(&quot;in invoke_method, class=$class method=$method delim=$delim&quot;);
+		}
+
+		// does method exist?
+		if ($class == '') {
+			if (!function_exists($this-&gt;methodname)) {
+				$this-&gt;debug(&quot;in invoke_method, function '$this-&gt;methodname' not found!&quot;);
+				$this-&gt;result = 'fault: method not found';
+				$this-&gt;fault('Client',&quot;method '$this-&gt;methodname' not defined in service&quot;);
+				return;
+			}
+		} else {
+			$method_to_compare = (substr(phpversion(), 0, 2) == '4.') ? strtolower($method) : $method;
+			if (!in_array($method_to_compare, get_class_methods($class))) {
+				$this-&gt;debug(&quot;in invoke_method, method '$this-&gt;methodname' not found in class '$class'!&quot;);
+				$this-&gt;result = 'fault: method not found';
+				$this-&gt;fault('Client',&quot;method '$this-&gt;methodname' not defined in service&quot;);
+				return;
+			}
+		}
+
+		// evaluate message, getting back parameters
+		// verify that request parameters match the method's signature
+		if(! $this-&gt;verify_method($this-&gt;methodname,$this-&gt;methodparams)){
+			// debug
+			$this-&gt;debug('ERROR: request not verified against method signature');
+			$this-&gt;result = 'fault: request failed validation against method signature';
+			// return fault
+			$this-&gt;fault('Client',&quot;Operation '$this-&gt;methodname' not defined in service.&quot;);
+			return;
+		}
+
+		// if there are parameters to pass
+		$this-&gt;debug('in invoke_method, params:');
+		$this-&gt;appendDebug($this-&gt;varDump($this-&gt;methodparams));
+		$this-&gt;debug(&quot;in invoke_method, calling '$this-&gt;methodname'&quot;);
+		if (!function_exists('call_user_func_array')) {
+			if ($class == '') {
+				$this-&gt;debug('in invoke_method, calling function using eval()');
+				$funcCall = &quot;\$this-&gt;methodreturn = $this-&gt;methodname(&quot;;
+			} else {
+				if ($delim == '..') {
+					$this-&gt;debug('in invoke_method, calling class method using eval()');
+					$funcCall = &quot;\$this-&gt;methodreturn = &quot;.$class.&quot;::&quot;.$method.&quot;(&quot;;
+				} else {
+					$this-&gt;debug('in invoke_method, calling instance method using eval()');
+					// generate unique instance name
+					$instname = &quot;\$inst_&quot;.time();
+					$funcCall = $instname.&quot; = new &quot;.$class.&quot;(); &quot;;
+					$funcCall .= &quot;\$this-&gt;methodreturn = &quot;.$instname.&quot;-&gt;&quot;.$method.&quot;(&quot;;
+				}
+			}
+			if ($this-&gt;methodparams) {
+				foreach ($this-&gt;methodparams as $param) {
+					if (is_array($param)) {
+						$this-&gt;fault('Client', 'NuSOAP does not handle complexType parameters correctly when using eval; call_user_func_array must be available');
+						return;
+					}
+					$funcCall .= &quot;\&quot;$param\&quot;,&quot;;
+				}
+				$funcCall = substr($funcCall, 0, -1);
+			}
+			$funcCall .= ');';
+			$this-&gt;debug('in invoke_method, function call: '.$funcCall);
+			@eval($funcCall);
+		} else {
+			if ($class == '') {
+				$this-&gt;debug('in invoke_method, calling function using call_user_func_array()');
+				$call_arg = &quot;$this-&gt;methodname&quot;;	// straight assignment changes $this-&gt;methodname to lower case after call_user_func_array()
+			} elseif ($delim == '..') {
+				$this-&gt;debug('in invoke_method, calling class method using call_user_func_array()');
+				$call_arg = array ($class, $method);
+			} else {
+				$this-&gt;debug('in invoke_method, calling instance method using call_user_func_array()');
+				$instance = new $class ();
+				$call_arg = array(&amp;$instance, $method);
+			}
+			$this-&gt;methodreturn = call_user_func_array($call_arg, $this-&gt;methodparams);
+		}
+        $this-&gt;debug('in invoke_method, methodreturn:');
+        $this-&gt;appendDebug($this-&gt;varDump($this-&gt;methodreturn));
+		$this-&gt;debug(&quot;in invoke_method, called method $this-&gt;methodname, received $this-&gt;methodreturn of type &quot;.gettype($this-&gt;methodreturn));
+	}
+
+	/**
+	* serializes the return value from a PHP function into a full SOAP Envelope
+	*
+	* The following fields are set by this function (when successful)
+	*
+	* responseSOAP
+	*
+	* This sets the fault field on error
+	*
+	* @access   private
+	*/
+	function serialize_return() {
+		$this-&gt;debug('Entering serialize_return methodname: ' . $this-&gt;methodname . ' methodURI: ' . $this-&gt;methodURI);
+		// if fault
+		if (isset($this-&gt;methodreturn) &amp;&amp; (get_class($this-&gt;methodreturn) == 'soap_fault')) {
+			$this-&gt;debug('got a fault object from method');
+			$this-&gt;fault = $this-&gt;methodreturn;
+			return;
+		} elseif ($this-&gt;methodreturnisliteralxml) {
+			$return_val = $this-&gt;methodreturn;
+		// returned value(s)
+		} else {
+			$this-&gt;debug('got a(n) '.gettype($this-&gt;methodreturn).' from method');
+			$this-&gt;debug('serializing return value');
+			if($this-&gt;wsdl){
+				// weak attempt at supporting multiple output params
+				if(sizeof($this-&gt;opData['output']['parts']) &gt; 1){
+			    	$opParams = $this-&gt;methodreturn;
+			    } else {
+			    	// TODO: is this really necessary?
+			    	$opParams = array($this-&gt;methodreturn);
+			    }
+			    $return_val = $this-&gt;wsdl-&gt;serializeRPCParameters($this-&gt;methodname,'output',$opParams);
+			    $this-&gt;appendDebug($this-&gt;wsdl-&gt;getDebug());
+			    $this-&gt;wsdl-&gt;clearDebug();
+				if($errstr = $this-&gt;wsdl-&gt;getError()){
+					$this-&gt;debug('got wsdl error: '.$errstr);
+					$this-&gt;fault('Server', 'unable to serialize result');
+					return;
+				}
+			} else {
+				if (isset($this-&gt;methodreturn)) {
+					$return_val = $this-&gt;serialize_val($this-&gt;methodreturn, 'return');
+				} else {
+					$return_val = '';
+					$this-&gt;debug('in absence of WSDL, assume void return for backward compatibility');
+				}
+			}
+		}
+		$this-&gt;debug('return value:');
+		$this-&gt;appendDebug($this-&gt;varDump($return_val));
+
+		$this-&gt;debug('serializing response');
+		if ($this-&gt;wsdl) {
+			$this-&gt;debug('have WSDL for serialization: style is ' . $this-&gt;opData['style']);
+			if ($this-&gt;opData['style'] == 'rpc') {
+				$this-&gt;debug('style is rpc for serialization: use is ' . $this-&gt;opData['output']['use']);
+				if ($this-&gt;opData['output']['use'] == 'literal') {
+					$payload = '&lt;'.$this-&gt;methodname.'Response xmlns=&quot;'.$this-&gt;methodURI.'&quot;&gt;'.$return_val.'&lt;/'.$this-&gt;methodname.&quot;Response&gt;&quot;;
+				} else {
+					$payload = '&lt;ns1:'.$this-&gt;methodname.'Response xmlns:ns1=&quot;'.$this-&gt;methodURI.'&quot;&gt;'.$return_val.'&lt;/ns1:'.$this-&gt;methodname.&quot;Response&gt;&quot;;
+				}
+			} else {
+				$this-&gt;debug('style is not rpc for serialization: assume document');
+				$payload = $return_val;
+			}
+		} else {
+			$this-&gt;debug('do not have WSDL for serialization: assume rpc/encoded');
+			$payload = '&lt;ns1:'.$this-&gt;methodname.'Response xmlns:ns1=&quot;'.$this-&gt;methodURI.'&quot;&gt;'.$return_val.'&lt;/ns1:'.$this-&gt;methodname.&quot;Response&gt;&quot;;
+		}
+		$this-&gt;result = 'successful';
+		if($this-&gt;wsdl){
+			//if($this-&gt;debug_flag){
+            	$this-&gt;appendDebug($this-&gt;wsdl-&gt;getDebug());
+            //	}
+			if (isset($opData['output']['encodingStyle'])) {
+				$encodingStyle = $opData['output']['encodingStyle'];
+			} else {
+				$encodingStyle = '';
+			}
+			// Added: In case we use a WSDL, return a serialized env. WITH the usedNamespaces.
+			$this-&gt;responseSOAP = $this-&gt;serializeEnvelope($payload,$this-&gt;responseHeaders,$this-&gt;wsdl-&gt;usedNamespaces,$this-&gt;opData['style'],$encodingStyle);
+		} else {
+			$this-&gt;responseSOAP = $this-&gt;serializeEnvelope($payload,$this-&gt;responseHeaders);
+		}
+		$this-&gt;debug(&quot;Leaving serialize_return&quot;);
+	}
+
+	/**
+	* sends an HTTP response
+	*
+	* The following fields are set by this function (when successful)
+	*
+	* outgoing_headers
+	* response
+	*
+	* @access   private
+	*/
+	function send_response() {
+		$this-&gt;debug('Enter send_response');
+		if ($this-&gt;fault) {
+			$payload = $this-&gt;fault-&gt;serialize();
+			$this-&gt;outgoing_headers[] = &quot;HTTP/1.0 500 Internal Server Error&quot;;
+			$this-&gt;outgoing_headers[] = &quot;Status: 500 Internal Server Error&quot;;
+		} else {
+			$payload = $this-&gt;responseSOAP;
+			// Some combinations of PHP+Web server allow the Status
+			// to come through as a header.  Since OK is the default
+			// just do nothing.
+			// $this-&gt;outgoing_headers[] = &quot;HTTP/1.0 200 OK&quot;;
+			// $this-&gt;outgoing_headers[] = &quot;Status: 200 OK&quot;;
+		}
+        // add debug data if in debug mode
+		if(isset($this-&gt;debug_flag) &amp;&amp; $this-&gt;debug_flag){
+        	$payload .= $this-&gt;getDebugAsXMLComment();
+        }
+		$this-&gt;outgoing_headers[] = &quot;Server: $this-&gt;title Server v$this-&gt;version&quot;;
+		ereg('\$Revisio' . 'n: ([^ ]+)', $this-&gt;revision, $rev);
+		$this-&gt;outgoing_headers[] = &quot;X-SOAP-Server: $this-&gt;title/$this-&gt;version (&quot;.$rev[1].&quot;)&quot;;
+		// Let the Web server decide about this
+		//$this-&gt;outgoing_headers[] = &quot;Connection: Close\r\n&quot;;
+		$payload = $this-&gt;getHTTPBody($payload);
+		$type = $this-&gt;getHTTPContentType();
+		$charset = $this-&gt;getHTTPContentTypeCharset();
+		$this-&gt;outgoing_headers[] = &quot;Content-Type: $type&quot; . ($charset ? '; charset=' . $charset : '');
+		//begin code to compress payload - by John
+		// NOTE: there is no way to know whether the Web server will also compress
+		// this data.
+		if (strlen($payload) &gt; 1024 &amp;&amp; isset($this-&gt;headers) &amp;&amp; isset($this-&gt;headers['accept-encoding'])) {	
+			if (strstr($this-&gt;headers['accept-encoding'], 'gzip')) {
+				if (function_exists('gzencode')) {
+					if (isset($this-&gt;debug_flag) &amp;&amp; $this-&gt;debug_flag) {
+						$payload .= &quot;&lt;!-- Content being gzipped --&gt;&quot;;
+					}
+					$this-&gt;outgoing_headers[] = &quot;Content-Encoding: gzip&quot;;
+					$payload = gzencode($payload);
+				} else {
+					if (isset($this-&gt;debug_flag) &amp;&amp; $this-&gt;debug_flag) {
+						$payload .= &quot;&lt;!-- Content will not be gzipped: no gzencode --&gt;&quot;;
+					}
+				}
+			} elseif (strstr($this-&gt;headers['accept-encoding'], 'deflate')) {
+				// Note: MSIE requires gzdeflate output (no Zlib header and checksum),
+				// instead of gzcompress output,
+				// which conflicts with HTTP 1.1 spec (<A HREF="http://www.w3.org/Protocols/rfc2616/rfc2616-sec3.html#sec3.5">http://www.w3.org/Protocols/rfc2616/rfc2616-sec3.html#sec3.5</A>)
+				if (function_exists('gzdeflate')) {
+					if (isset($this-&gt;debug_flag) &amp;&amp; $this-&gt;debug_flag) {
+						$payload .= &quot;&lt;!-- Content being deflated --&gt;&quot;;
+					}
+					$this-&gt;outgoing_headers[] = &quot;Content-Encoding: deflate&quot;;
+					$payload = gzdeflate($payload);
+				} else {
+					if (isset($this-&gt;debug_flag) &amp;&amp; $this-&gt;debug_flag) {
+						$payload .= &quot;&lt;!-- Content will not be deflated: no gzcompress --&gt;&quot;;
+					}
+				}
+			}
+		}
+		//end code
+		$this-&gt;outgoing_headers[] = &quot;Content-Length: &quot;.strlen($payload);
+		reset($this-&gt;outgoing_headers);
+		foreach($this-&gt;outgoing_headers as $hdr){
+			header($hdr, false);
+		}
+		print $payload;
+		$this-&gt;response = join(&quot;\r\n&quot;,$this-&gt;outgoing_headers).&quot;\r\n\r\n&quot;.$payload;
+	}
+
+	/**
+	* takes the value that was created by parsing the request
+	* and compares to the method's signature, if available.
+	*
+	* @param	string	$operation	The operation to be invoked
+	* @param	array	$request	The array of parameter values
+	* @return	boolean	Whether the operation was found
+	* @access   private
+	*/
+	function verify_method($operation,$request){
+		if(isset($this-&gt;wsdl) &amp;&amp; is_object($this-&gt;wsdl)){
+			if($this-&gt;wsdl-&gt;getOperationData($operation)){
+				return true;
+			}
+	    } elseif(isset($this-&gt;operations[$operation])){
+			return true;
+		}
+		return false;
+	}
+
+	/**
+	* processes SOAP message received from client
+	*
+	* @param	array	$headers	The HTTP headers
+	* @param	string	$data		unprocessed request data from client
+	* @return	mixed	value of the message, decoded into a PHP type
+	* @access   private
+	*/
+    function parseRequest($headers, $data) {
+		$this-&gt;debug('Entering parseRequest() for data of length ' . strlen($data) . ' and type ' . $headers['content-type']);
+		if (!strstr($headers['content-type'], 'text/xml')) {
+			$this-&gt;setError('Request not of type text/xml');
+			return false;
+		}
+		if (strpos($headers['content-type'], '=')) {
+			$enc = str_replace('&quot;', '', substr(strstr($headers[&quot;content-type&quot;], '='), 1));
+			$this-&gt;debug('Got response encoding: ' . $enc);
+			if(eregi('^(ISO-8859-1|US-ASCII|UTF-8)$',$enc)){
+				$this-&gt;xml_encoding = strtoupper($enc);
+			} else {
+				$this-&gt;xml_encoding = 'US-ASCII';
+			}
+		} else {
+			// should be US-ASCII for HTTP 1.0 or ISO-8859-1 for HTTP 1.1
+			$this-&gt;xml_encoding = 'ISO-8859-1';
+		}
+		$this-&gt;debug('Use encoding: ' . $this-&gt;xml_encoding . ' when creating soap_parser');
+		// parse response, get soap parser obj
+		$parser = new soap_parser($data,$this-&gt;xml_encoding,'',$this-&gt;decode_utf8);
+		// parser debug
+		$this-&gt;debug(&quot;parser debug: \n&quot;.$parser-&gt;getDebug());
+		// if fault occurred during message parsing
+		if($err = $parser-&gt;getError()){
+			$this-&gt;result = 'fault: error in msg parsing: '.$err;
+			$this-&gt;fault('Client',&quot;error in msg parsing:\n&quot;.$err);
+		// else successfully parsed request into soapval object
+		} else {
+			// get/set methodname
+			$this-&gt;methodURI = $parser-&gt;root_struct_namespace;
+			$this-&gt;methodname = $parser-&gt;root_struct_name;
+			$this-&gt;debug('methodname: '.$this-&gt;methodname.' methodURI: '.$this-&gt;methodURI);
+			$this-&gt;debug('calling parser-&gt;get_response()');
+			$this-&gt;methodparams = $parser-&gt;get_response();
+			// get SOAP headers
+			$this-&gt;requestHeaders = $parser-&gt;getHeaders();
+            // add document for doclit support
+            $this-&gt;document = $parser-&gt;document;
+		}
+	 }
+
+	/**
+	* gets the HTTP body for the current response.
+	*
+	* @param string $soapmsg The SOAP payload
+	* @return string The HTTP body, which includes the SOAP payload
+	* @access private
+	*/
+	function getHTTPBody($soapmsg) {
+		return $soapmsg;
+	}
+	
+	/**
+	* gets the HTTP content type for the current response.
+	*
+	* Note: getHTTPBody must be called before this.
+	*
+	* @return string the HTTP content type for the current response.
+	* @access private
+	*/
+	function getHTTPContentType() {
+		return 'text/xml';
+	}
+	
+	/**
+	* gets the HTTP content type charset for the current response.
+	* returns false for non-text content types.
+	*
+	* Note: getHTTPBody must be called before this.
+	*
+	* @return string the HTTP content type charset for the current response.
+	* @access private
+	*/
+	function getHTTPContentTypeCharset() {
+		return $this-&gt;soap_defencoding;
+	}
+
+	/**
+	* add a method to the dispatch map (this has been replaced by the register method)
+	*
+	* @param    string $methodname
+	* @param    string $in array of input values
+	* @param    string $out array of output values
+	* @access   public
+	* @deprecated
+	*/
+	function add_to_map($methodname,$in,$out){
+			$this-&gt;operations[$methodname] = array('name' =&gt; $methodname,'in' =&gt; $in,'out' =&gt; $out);
+	}
+
+	/**
+	* register a service function with the server
+	*
+	* @param    string $name the name of the PHP function, class.method or class..method
+	* @param    array $in assoc array of input values: key = param name, value = param type
+	* @param    array $out assoc array of output values: key = param name, value = param type
+	* @param	mixed $namespace the element namespace for the method or false
+	* @param	mixed $soapaction the soapaction for the method or false
+	* @param	mixed $style optional (rpc|document) or false Note: when 'document' is specified, parameter and return wrappers are created for you automatically
+	* @param	mixed $use optional (encoded|literal) or false
+	* @param	string $documentation optional Description to include in WSDL
+	* @param	string $encodingStyle optional (usually '<A HREF="http://schemas.xmlsoap.org/soap/encoding/">http://schemas.xmlsoap.org/soap/encoding/</A>' for encoded)
+	* @access   public
+	*/
+	function register($name,$in=array(),$out=array(),$namespace=false,$soapaction=false,$style=false,$use=false,$documentation='',$encodingStyle=''){
+		global $HTTP_SERVER_VARS;
+
+		if($this-&gt;externalWSDLURL){
+			die('You cannot bind to an external WSDL file, and register methods outside of it! Please choose either WSDL or no WSDL.');
+		}
+		if (! $name) {
+			die('You must specify a name when you register an operation');
+		}
+		if (!is_array($in)) {
+			die('You must provide an array for operation inputs');
+		}
+		if (!is_array($out)) {
+			die('You must provide an array for operation outputs');
+		}
+		if(false == $namespace) {
+		}
+		if(false == $soapaction) {
+			if (isset($_SERVER)) {
+				$SERVER_NAME = $_SERVER['SERVER_NAME'];
+				$SCRIPT_NAME = isset($_SERVER['PHP_SELF']) ? $_SERVER['PHP_SELF'] : $_SERVER['SCRIPT_NAME'];
+			} elseif (isset($HTTP_SERVER_VARS)) {
+				$SERVER_NAME = $HTTP_SERVER_VARS['SERVER_NAME'];
+				$SCRIPT_NAME = isset($HTTP_SERVER_VARS['PHP_SELF']) ? $HTTP_SERVER_VARS['PHP_SELF'] : $HTTP_SERVER_VARS['SCRIPT_NAME'];
+			} else {
+				$this-&gt;setError(&quot;Neither _SERVER nor HTTP_SERVER_VARS is available&quot;);
+			}
+			$soapaction = &quot;<A HREF="http://$SERVER_NAME$SCRIPT_NAME/$name">http://$SERVER_NAME$SCRIPT_NAME/$name</A>&quot;;
+		}
+		if(false == $style) {
+			$style = &quot;rpc&quot;;
+		}
+		if(false == $use) {
+			$use = &quot;encoded&quot;;
+		}
+		if ($use == 'encoded' &amp;&amp; $encodingStyle = '') {
+			$encodingStyle = '<A HREF="http://schemas.xmlsoap.org/soap/encoding/">http://schemas.xmlsoap.org/soap/encoding/</A>';
+		}
+
+		$this-&gt;operations[$name] = array(
+	    'name' =&gt; $name,
+	    'in' =&gt; $in,
+	    'out' =&gt; $out,
+	    'namespace' =&gt; $namespace,
+	    'soapaction' =&gt; $soapaction,
+	    'style' =&gt; $style);
+        if($this-&gt;wsdl){
+        	$this-&gt;wsdl-&gt;addOperation($name,$in,$out,$namespace,$soapaction,$style,$use,$documentation,$encodingStyle);
+	    }
+		return true;
+	}
+
+	/**
+	* Specify a fault to be returned to the client.
+	* This also acts as a flag to the server that a fault has occured.
+	*
+	* @param	string $faultcode
+	* @param	string $faultstring
+	* @param	string $faultactor
+	* @param	string $faultdetail
+	* @access   public
+	*/
+	function fault($faultcode,$faultstring,$faultactor='',$faultdetail=''){
+		if ($faultdetail == '' &amp;&amp; $this-&gt;debug_flag) {
+			$faultdetail = $this-&gt;getDebug();
+		}
+		$this-&gt;fault = new soap_fault($faultcode,$faultactor,$faultstring,$faultdetail);
+		$this-&gt;fault-&gt;soap_defencoding = $this-&gt;soap_defencoding;
+	}
+
+    /**
+    * Sets up wsdl object.
+    * Acts as a flag to enable internal WSDL generation
+    *
+    * @param string $serviceName, name of the service
+    * @param mixed $namespace optional 'tns' service namespace or false
+    * @param mixed $endpoint optional URL of service endpoint or false
+    * @param string $style optional (rpc|document) WSDL style (also specified by operation)
+    * @param string $transport optional SOAP transport
+    * @param mixed $schemaTargetNamespace optional 'types' targetNamespace for service schema or false
+    */
+    function configureWSDL($serviceName,$namespace = false,$endpoint = false,$style='rpc', $transport = '<A HREF="http://schemas.xmlsoap.org/soap/http">http://schemas.xmlsoap.org/soap/http</A>', $schemaTargetNamespace = false)
+    {
+    	global $HTTP_SERVER_VARS;
+
+		if (isset($_SERVER)) {
+			$SERVER_NAME = $_SERVER['SERVER_NAME'];
+			$SERVER_PORT = $_SERVER['SERVER_PORT'];
+			$SCRIPT_NAME = isset($_SERVER['PHP_SELF']) ? $_SERVER['PHP_SELF'] : $_SERVER['SCRIPT_NAME'];
+			$HTTPS = $_SERVER['HTTPS'];
+		} elseif (isset($HTTP_SERVER_VARS)) {
+			$SERVER_NAME = $HTTP_SERVER_VARS['SERVER_NAME'];
+			$SERVER_PORT = $HTTP_SERVER_VARS['SERVER_PORT'];
+			$SCRIPT_NAME = isset($HTTP_SERVER_VARS['PHP_SELF']) ? $HTTP_SERVER_VARS['PHP_SELF'] : $HTTP_SERVER_VARS['SCRIPT_NAME'];
+			$HTTPS = $HTTP_SERVER_VARS['HTTPS'];
+		} else {
+			$this-&gt;setError(&quot;Neither _SERVER nor HTTP_SERVER_VARS is available&quot;);
+		}
+		if ($SERVER_PORT == 80) {
+			$SERVER_PORT = '';
+		} else {
+			$SERVER_PORT = ':' . $SERVER_PORT;
+		}
+        if(false == $namespace) {
+            $namespace = &quot;<A HREF="http://$SERVER_NAME/soap/$serviceName">http://$SERVER_NAME/soap/$serviceName</A>&quot;;
+        }
+        
+        if(false == $endpoint) {
+        	if ($HTTPS == '1' || $HTTPS == 'on') {
+        		$SCHEME = 'https';
+        	} else {
+        		$SCHEME = 'http';
+        	}
+            $endpoint = &quot;$<A HREF="SCHEME://$SERVER_NAME$SERVER_PORT$SCRIPT_NAME">SCHEME://$SERVER_NAME$SERVER_PORT$SCRIPT_NAME</A>&quot;;
+        }
+        
+        if(false == $schemaTargetNamespace) {
+            $schemaTargetNamespace = $namespace;
+        }
+        
+		$this-&gt;wsdl = new wsdl;
+		$this-&gt;wsdl-&gt;serviceName = $serviceName;
+        $this-&gt;wsdl-&gt;endpoint = $endpoint;
+		$this-&gt;wsdl-&gt;namespaces['tns'] = $namespace;
+		$this-&gt;wsdl-&gt;namespaces['soap'] = '<A HREF="http://schemas.xmlsoap.org/wsdl/soap/">http://schemas.xmlsoap.org/wsdl/soap/</A>';
+		$this-&gt;wsdl-&gt;namespaces['wsdl'] = '<A HREF="http://schemas.xmlsoap.org/wsdl/">http://schemas.xmlsoap.org/wsdl/</A>';
+		if ($schemaTargetNamespace != $namespace) {
+			$this-&gt;wsdl-&gt;namespaces['types'] = $schemaTargetNamespace;
+		}
+        $this-&gt;wsdl-&gt;schemas[$schemaTargetNamespace][0] = new xmlschema('', '', $this-&gt;wsdl-&gt;namespaces);
+        $this-&gt;wsdl-&gt;schemas[$schemaTargetNamespace][0]-&gt;schemaTargetNamespace = $schemaTargetNamespace;
+        $this-&gt;wsdl-&gt;schemas[$schemaTargetNamespace][0]-&gt;imports['<A HREF="http://schemas.xmlsoap.org/soap/encoding/">http://schemas.xmlsoap.org/soap/encoding/</A>'][0] = array('location' =&gt; '', 'loaded' =&gt; true);
+        $this-&gt;wsdl-&gt;schemas[$schemaTargetNamespace][0]-&gt;imports['<A HREF="http://schemas.xmlsoap.org/wsdl/">http://schemas.xmlsoap.org/wsdl/</A>'][0] = array('location' =&gt; '', 'loaded' =&gt; true);
+        $this-&gt;wsdl-&gt;bindings[$serviceName.'Binding'] = array(
+        	'name'=&gt;$serviceName.'Binding',
+            'style'=&gt;$style,
+            'transport'=&gt;$transport,
+            'portType'=&gt;$serviceName.'PortType');
+        $this-&gt;wsdl-&gt;ports[$serviceName.'Port'] = array(
+        	'binding'=&gt;$serviceName.'Binding',
+            'location'=&gt;$endpoint,
+            'bindingType'=&gt;'<A HREF="http://schemas.xmlsoap.org/wsdl/soap/">http://schemas.xmlsoap.org/wsdl/soap/</A>');
+    }
+}
+
+
+
+?&gt;&lt;?php
+
+
+
+/**
+* parses a WSDL file, allows access to it's data, other utility methods
+* 
+* @author   Dietrich Ayala &lt;<A HREF="https://lists.berlios.de/mailman/listinfo/viperals-svncheckins">dietrich at ganx4.com</A>&gt;
+* @version  $Id: nusoap.php,v 1.94 2005/08/04 01:27:42 snichol Exp $
+* @access public 
+*/
+class wsdl extends nusoap_base {
+	// URL or filename of the root of this WSDL
+    var $wsdl; 
+    // define internal arrays of bindings, ports, operations, messages, etc.
+    var $schemas = array();
+    var $currentSchema;
+    var $message = array();
+    var $complexTypes = array();
+    var $messages = array();
+    var $currentMessage;
+    var $currentOperation;
+    var $portTypes = array();
+    var $currentPortType;
+    var $bindings = array();
+    var $currentBinding;
+    var $ports = array();
+    var $currentPort;
+    var $opData = array();
+    var $status = '';
+    var $documentation = false;
+    var $endpoint = ''; 
+    // array of wsdl docs to import
+    var $import = array(); 
+    // parser vars
+    var $parser;
+    var $position = 0;
+    var $depth = 0;
+    var $depth_array = array();
+	// for getting wsdl
+	var $proxyhost = '';
+    var $proxyport = '';
+	var $proxyusername = '';
+	var $proxypassword = '';
+	var $timeout = 0;
+	var $response_timeout = 30;
+
+    /**
+     * constructor
+     * 
+     * @param string $wsdl WSDL document URL
+	 * @param string $proxyhost
+	 * @param string $proxyport
+	 * @param string $proxyusername
+	 * @param string $proxypassword
+	 * @param integer $timeout set the connection timeout
+	 * @param integer $response_timeout set the response timeout
+     * @access public 
+     */
+    function wsdl($wsdl = '',$proxyhost=false,$proxyport=false,$proxyusername=false,$proxypassword=false,$timeout=0,$response_timeout=30){
+		parent::nusoap_base();
+        $this-&gt;wsdl = $wsdl;
+        $this-&gt;proxyhost = $proxyhost;
+        $this-&gt;proxyport = $proxyport;
+		$this-&gt;proxyusername = $proxyusername;
+		$this-&gt;proxypassword = $proxypassword;
+		$this-&gt;timeout = $timeout;
+		$this-&gt;response_timeout = $response_timeout;
+        
+        // parse wsdl file
+        if ($wsdl != &quot;&quot;) {
+            $this-&gt;debug('initial wsdl URL: ' . $wsdl);
+            $this-&gt;parseWSDL($wsdl);
+        }
+        // imports
+        // TODO: handle imports more properly, grabbing them in-line and nesting them
+        	$imported_urls = array();
+        	$imported = 1;
+        	while ($imported &gt; 0) {
+        		$imported = 0;
+        		// Schema imports
+        		foreach ($this-&gt;schemas as $ns =&gt; $list) {
+        			foreach ($list as $xs) {
+						$wsdlparts = parse_url($this-&gt;wsdl);	// this is bogusly simple!
+			            foreach ($xs-&gt;imports as $ns2 =&gt; $list2) {
+			                for ($ii = 0; $ii &lt; count($list2); $ii++) {
+			                	if (! $list2[$ii]['loaded']) {
+			                		$this-&gt;schemas[$ns]-&gt;imports[$ns2][$ii]['loaded'] = true;
+			                		$url = $list2[$ii]['location'];
+									if ($url != '') {
+										$urlparts = parse_url($url);
+										if (!isset($urlparts['host'])) {
+											$url = $wsdlparts['scheme'] . '://' . $wsdlparts['host'] . (isset($wsdlparts['port']) ? ':' .$wsdlparts['port'] : '') .
+													substr($wsdlparts['path'],0,strrpos($wsdlparts['path'],'/') + 1) .$urlparts['path'];
+										}
+										if (! in_array($url, $imported_urls)) {
+						                	$this-&gt;parseWSDL($url);
+					                		$imported++;
+					                		$imported_urls[] = $url;
+					                	}
+									} else {
+										$this-&gt;debug(&quot;Unexpected scenario: empty URL for unloaded import&quot;);
+									}
+								}
+							}
+			            } 
+        			}
+        		}
+        		// WSDL imports
+				$wsdlparts = parse_url($this-&gt;wsdl);	// this is bogusly simple!
+	            foreach ($this-&gt;import as $ns =&gt; $list) {
+	                for ($ii = 0; $ii &lt; count($list); $ii++) {
+	                	if (! $list[$ii]['loaded']) {
+	                		$this-&gt;import[$ns][$ii]['loaded'] = true;
+	                		$url = $list[$ii]['location'];
+							if ($url != '') {
+								$urlparts = parse_url($url);
+								if (!isset($urlparts['host'])) {
+									$url = $wsdlparts['scheme'] . '://' . $wsdlparts['host'] . (isset($wsdlparts['port']) ? ':' . $wsdlparts['port'] : '') .
+											substr($wsdlparts['path'],0,strrpos($wsdlparts['path'],'/') + 1) .$urlparts['path'];
+								}
+								if (! in_array($url, $imported_urls)) {
+				                	$this-&gt;parseWSDL($url);
+			                		$imported++;
+			                		$imported_urls[] = $url;
+			                	}
+							} else {
+								$this-&gt;debug(&quot;Unexpected scenario: empty URL for unloaded import&quot;);
+							}
+						}
+					}
+	            } 
+			}
+        // add new data to operation data
+        foreach($this-&gt;bindings as $binding =&gt; $bindingData) {
+            if (isset($bindingData['operations']) &amp;&amp; is_array($bindingData['operations'])) {
+                foreach($bindingData['operations'] as $operation =&gt; $data) {
+                    $this-&gt;debug('post-parse data gathering for ' . $operation);
+                    $this-&gt;bindings[$binding]['operations'][$operation]['input'] = 
+						isset($this-&gt;bindings[$binding]['operations'][$operation]['input']) ? 
+						array_merge($this-&gt;bindings[$binding]['operations'][$operation]['input'], $this-&gt;portTypes[ $bindingData['portType'] ][$operation]['input']) :
+						$this-&gt;portTypes[ $bindingData['portType'] ][$operation]['input'];
+                    $this-&gt;bindings[$binding]['operations'][$operation]['output'] = 
+						isset($this-&gt;bindings[$binding]['operations'][$operation]['output']) ?
+						array_merge($this-&gt;bindings[$binding]['operations'][$operation]['output'], $this-&gt;portTypes[ $bindingData['portType'] ][$operation]['output']) :
+						$this-&gt;portTypes[ $bindingData['portType'] ][$operation]['output'];
+                    if(isset($this-&gt;messages[ $this-&gt;bindings[$binding]['operations'][$operation]['input']['message'] ])){
+						$this-&gt;bindings[$binding]['operations'][$operation]['input']['parts'] = $this-&gt;messages[ $this-&gt;bindings[$binding]['operations'][$operation]['input']['message'] ];
+					}
+					if(isset($this-&gt;messages[ $this-&gt;bindings[$binding]['operations'][$operation]['output']['message'] ])){
+                   		$this-&gt;bindings[$binding]['operations'][$operation]['output']['parts'] = $this-&gt;messages[ $this-&gt;bindings[$binding]['operations'][$operation]['output']['message'] ];
+                    }
+					if (isset($bindingData['style'])) {
+                        $this-&gt;bindings[$binding]['operations'][$operation]['style'] = $bindingData['style'];
+                    }
+                    $this-&gt;bindings[$binding]['operations'][$operation]['transport'] = isset($bindingData['transport']) ? $bindingData['transport'] : '';
+                    $this-&gt;bindings[$binding]['operations'][$operation]['documentation'] = isset($this-&gt;portTypes[ $bindingData['portType'] ][$operation]['documentation']) ? $this-&gt;portTypes[ $bindingData['portType'] ][$operation]['documentation'] : '';
+                    $this-&gt;bindings[$binding]['operations'][$operation]['endpoint'] = isset($bindingData['endpoint']) ? $bindingData['endpoint'] : '';
+                } 
+            } 
+        }
+    }
+
+    /**
+     * parses the wsdl document
+     * 
+     * @param string $wsdl path or URL
+     * @access private 
+     */
+    function parseWSDL($wsdl = '')
+    {
+        if ($wsdl == '') {
+            $this-&gt;debug('no wsdl passed to parseWSDL()!!');
+            $this-&gt;setError('no wsdl passed to parseWSDL()!!');
+            return false;
+        }
+        
+        // parse $wsdl for url format
+        $wsdl_props = parse_url($wsdl);
+
+        if (isset($wsdl_props['scheme']) &amp;&amp; ($wsdl_props['scheme'] == 'http' || $wsdl_props['scheme'] == 'https')) {
+            $this-&gt;debug('getting WSDL http(s) URL ' . $wsdl);
+        	// get wsdl
+	        $tr = new soap_transport_http($wsdl);
+			$tr-&gt;request_method = 'GET';
+			$tr-&gt;useSOAPAction = false;
+			if($this-&gt;proxyhost &amp;&amp; $this-&gt;proxyport){
+				$tr-&gt;setProxy($this-&gt;proxyhost,$this-&gt;proxyport,$this-&gt;proxyusername,$this-&gt;proxypassword);
+			}
+			$tr-&gt;setEncoding('gzip, deflate');
+			$wsdl_string = $tr-&gt;send('', $this-&gt;timeout, $this-&gt;response_timeout);
+			//$this-&gt;debug(&quot;WSDL request\n&quot; . $tr-&gt;outgoing_payload);
+			//$this-&gt;debug(&quot;WSDL response\n&quot; . $tr-&gt;incoming_payload);
+			$this-&gt;appendDebug($tr-&gt;getDebug());
+			// catch errors
+			if($err = $tr-&gt;getError() ){
+				$errstr = 'HTTP ERROR: '.$err;
+				$this-&gt;debug($errstr);
+	            $this-&gt;setError($errstr);
+				unset($tr);
+	            return false;
+			}
+			unset($tr);
+			$this-&gt;debug(&quot;got WSDL URL&quot;);
+        } else {
+            // $wsdl is not http(s), so treat it as a file URL or plain file path
+        	if (isset($wsdl_props['scheme']) &amp;&amp; ($wsdl_props['scheme'] == 'file') &amp;&amp; isset($wsdl_props['path'])) {
+        		$path = isset($wsdl_props['host']) ? ($wsdl_props['host'] . ':' . $wsdl_props['path']) : $wsdl_props['path'];
+        	} else {
+        		$path = $wsdl;
+        	}
+            $this-&gt;debug('getting WSDL file ' . $path);
+            if ($fp = @fopen($path, 'r')) {
+                $wsdl_string = '';
+                while ($data = fread($fp, 32768)) {
+                    $wsdl_string .= $data;
+                } 
+                fclose($fp);
+            } else {
+            	$errstr = &quot;Bad path to WSDL file $path&quot;;
+            	$this-&gt;debug($errstr);
+                $this-&gt;setError($errstr);
+                return false;
+            } 
+        }
+        $this-&gt;debug('Parse WSDL');
+        // end new code added
+        // Create an XML parser.
+        $this-&gt;parser = xml_parser_create(); 
+        // Set the options for parsing the XML data.
+        // xml_parser_set_option($parser, XML_OPTION_SKIP_WHITE, 1);
+        xml_parser_set_option($this-&gt;parser, XML_OPTION_CASE_FOLDING, 0); 
+        // Set the object for the parser.
+        xml_set_object($this-&gt;parser, $this); 
+        // Set the element handlers for the parser.
+        xml_set_element_handler($this-&gt;parser, 'start_element', 'end_element');
+        xml_set_character_data_handler($this-&gt;parser, 'character_data');
+        // Parse the XML file.
+        if (!xml_parse($this-&gt;parser, $wsdl_string, true)) {
+            // Display an error message.
+            $errstr = sprintf(
+				'XML error parsing WSDL from %s on line %d: %s',
+				$wsdl,
+                xml_get_current_line_number($this-&gt;parser),
+                xml_error_string(xml_get_error_code($this-&gt;parser))
+                );
+            $this-&gt;debug($errstr);
+			$this-&gt;debug(&quot;XML payload:\n&quot; . $wsdl_string);
+            $this-&gt;setError($errstr);
+            return false;
+        } 
+		// free the parser
+        xml_parser_free($this-&gt;parser);
+        $this-&gt;debug('Parsing WSDL done');
+		// catch wsdl parse errors
+		if($this-&gt;getError()){
+			return false;
+		}
+        return true;
+    } 
+
+    /**
+     * start-element handler
+     * 
+     * @param string $parser XML parser object
+     * @param string $name element name
+     * @param string $attrs associative array of attributes
+     * @access private 
+     */
+    function start_element($parser, $name, $attrs)
+    {
+        if ($this-&gt;status == 'schema') {
+            $this-&gt;currentSchema-&gt;schemaStartElement($parser, $name, $attrs);
+            $this-&gt;appendDebug($this-&gt;currentSchema-&gt;getDebug());
+            $this-&gt;currentSchema-&gt;clearDebug();
+        } elseif (ereg('schema$', $name)) {
+        	$this-&gt;debug('Parsing WSDL schema');
+            // $this-&gt;debug(&quot;startElement for $name ($attrs[name]). status = $this-&gt;status (&quot;.$this-&gt;getLocalPart($name).&quot;)&quot;);
+            $this-&gt;status = 'schema';
+            $this-&gt;currentSchema = new xmlschema('', '', $this-&gt;namespaces);
+            $this-&gt;currentSchema-&gt;schemaStartElement($parser, $name, $attrs);
+            $this-&gt;appendDebug($this-&gt;currentSchema-&gt;getDebug());
+            $this-&gt;currentSchema-&gt;clearDebug();
+        } else {
+            // position in the total number of elements, starting from 0
+            $pos = $this-&gt;position++;
+            $depth = $this-&gt;depth++; 
+            // set self as current value for this depth
+            $this-&gt;depth_array[$depth] = $pos;
+            $this-&gt;message[$pos] = array('cdata' =&gt; ''); 
+            // process attributes
+            if (count($attrs) &gt; 0) {
+				// register namespace declarations
+                foreach($attrs as $k =&gt; $v) {
+                    if (ereg(&quot;^xmlns&quot;, $k)) {
+                        if ($ns_prefix = substr(strrchr($k, ':'), 1)) {
+                            $this-&gt;namespaces[$ns_prefix] = $v;
+                        } else {
+                            $this-&gt;namespaces['ns' . (count($this-&gt;namespaces) + 1)] = $v;
+                        } 
+                        if ($v == '<A HREF="http://www.w3.org/2001/XMLSchema">http://www.w3.org/2001/XMLSchema</A>' || $v == '<A HREF="http://www.w3.org/1999/XMLSchema">http://www.w3.org/1999/XMLSchema</A>' || $v == '<A HREF="http://www.w3.org/2000/10/XMLSchema">http://www.w3.org/2000/10/XMLSchema</A>') {
+                            $this-&gt;XMLSchemaVersion = $v;
+                            $this-&gt;namespaces['xsi'] = $v . '-instance';
+                        } 
+                    }
+                }
+                // expand each attribute prefix to its namespace
+                foreach($attrs as $k =&gt; $v) {
+                    $k = strpos($k, ':') ? $this-&gt;expandQname($k) : $k;
+                    if ($k != 'location' &amp;&amp; $k != 'soapAction' &amp;&amp; $k != 'namespace') {
+                        $v = strpos($v, ':') ? $this-&gt;expandQname($v) : $v;
+                    } 
+                    $eAttrs[$k] = $v;
+                } 
+                $attrs = $eAttrs;
+            } else {
+                $attrs = array();
+            } 
+            // get element prefix, namespace and name
+            if (ereg(':', $name)) {
+                // get ns prefix
+                $prefix = substr($name, 0, strpos($name, ':')); 
+                // get ns
+                $namespace = isset($this-&gt;namespaces[$prefix]) ? $this-&gt;namespaces[$prefix] : ''; 
+                // get unqualified name
+                $name = substr(strstr($name, ':'), 1);
+            } 
+			// process attributes, expanding any prefixes to namespaces
+            // find status, register data
+            switch ($this-&gt;status) {
+                case 'message':
+                    if ($name == 'part') {
+			            if (isset($attrs['type'])) {
+		                    $this-&gt;debug(&quot;msg &quot; . $this-&gt;currentMessage . &quot;: found part $attrs[name]: &quot; . implode(',', $attrs));
+		                    $this-&gt;messages[$this-&gt;currentMessage][$attrs['name']] = $attrs['type'];
+            			} 
+			            if (isset($attrs['element'])) {
+		                    $this-&gt;debug(&quot;msg &quot; . $this-&gt;currentMessage . &quot;: found part $attrs[name]: &quot; . implode(',', $attrs));
+			                $this-&gt;messages[$this-&gt;currentMessage][$attrs['name']] = $attrs['element'];
+			            } 
+        			} 
+        			break;
+			    case 'portType':
+			        switch ($name) {
+			            case 'operation':
+			                $this-&gt;currentPortOperation = $attrs['name'];
+			                $this-&gt;debug(&quot;portType $this-&gt;currentPortType operation: $this-&gt;currentPortOperation&quot;);
+			                if (isset($attrs['parameterOrder'])) {
+			                	$this-&gt;portTypes[$this-&gt;currentPortType][$attrs['name']]['parameterOrder'] = $attrs['parameterOrder'];
+			        		} 
+			        		break;
+					    case 'documentation':
+					        $this-&gt;documentation = true;
+					        break; 
+					    // merge input/output data
+					    default:
+					        $m = isset($attrs['message']) ? $this-&gt;getLocalPart($attrs['message']) : '';
+					        $this-&gt;portTypes[$this-&gt;currentPortType][$this-&gt;currentPortOperation][$name]['message'] = $m;
+					        break;
+					} 
+			    	break;
+				case 'binding':
+				    switch ($name) {
+				        case 'binding': 
+				            // get ns prefix
+				            if (isset($attrs['style'])) {
+				            $this-&gt;bindings[$this-&gt;currentBinding]['prefix'] = $prefix;
+					    	} 
+					    	$this-&gt;bindings[$this-&gt;currentBinding] = array_merge($this-&gt;bindings[$this-&gt;currentBinding], $attrs);
+					    	break;
+						case 'header':
+						    $this-&gt;bindings[$this-&gt;currentBinding]['operations'][$this-&gt;currentOperation][$this-&gt;opStatus]['headers'][] = $attrs;
+						    break;
+						case 'operation':
+						    if (isset($attrs['soapAction'])) {
+						        $this-&gt;bindings[$this-&gt;currentBinding]['operations'][$this-&gt;currentOperation]['soapAction'] = $attrs['soapAction'];
+						    } 
+						    if (isset($attrs['style'])) {
+						        $this-&gt;bindings[$this-&gt;currentBinding]['operations'][$this-&gt;currentOperation]['style'] = $attrs['style'];
+						    } 
+						    if (isset($attrs['name'])) {
+						        $this-&gt;currentOperation = $attrs['name'];
+						        $this-&gt;debug(&quot;current binding operation: $this-&gt;currentOperation&quot;);
+						        $this-&gt;bindings[$this-&gt;currentBinding]['operations'][$this-&gt;currentOperation]['name'] = $attrs['name'];
+						        $this-&gt;bindings[$this-&gt;currentBinding]['operations'][$this-&gt;currentOperation]['binding'] = $this-&gt;currentBinding;
+						        $this-&gt;bindings[$this-&gt;currentBinding]['operations'][$this-&gt;currentOperation]['endpoint'] = isset($this-&gt;bindings[$this-&gt;currentBinding]['endpoint']) ? $this-&gt;bindings[$this-&gt;currentBinding]['endpoint'] : '';
+						    } 
+						    break;
+						case 'input':
+						    $this-&gt;opStatus = 'input';
+						    break;
+						case 'output':
+						    $this-&gt;opStatus = 'output';
+						    break;
+						case 'body':
+						    if (isset($this-&gt;bindings[$this-&gt;currentBinding]['operations'][$this-&gt;currentOperation][$this-&gt;opStatus])) {
+						        $this-&gt;bindings[$this-&gt;currentBinding]['operations'][$this-&gt;currentOperation][$this-&gt;opStatus] = array_merge($this-&gt;bindings[$this-&gt;currentBinding]['operations'][$this-&gt;currentOperation][$this-&gt;opStatus], $attrs);
+						    } else {
+						        $this-&gt;bindings[$this-&gt;currentBinding]['operations'][$this-&gt;currentOperation][$this-&gt;opStatus] = $attrs;
+						    } 
+						    break;
+					} 
+					break;
+				case 'service':
+					switch ($name) {
+					    case 'port':
+					        $this-&gt;currentPort = $attrs['name'];
+					        $this-&gt;debug('current port: ' . $this-&gt;currentPort);
+					        $this-&gt;ports[$this-&gt;currentPort]['binding'] = $this-&gt;getLocalPart($attrs['binding']);
+					
+					        break;
+					    case 'address':
+					        $this-&gt;ports[$this-&gt;currentPort]['location'] = $attrs['location'];
+					        $this-&gt;ports[$this-&gt;currentPort]['bindingType'] = $namespace;
+					        $this-&gt;bindings[ $this-&gt;ports[$this-&gt;currentPort]['binding'] ]['bindingType'] = $namespace;
+					        $this-&gt;bindings[ $this-&gt;ports[$this-&gt;currentPort]['binding'] ]['endpoint'] = $attrs['location'];
+					        break;
+					} 
+					break;
+			} 
+		// set status
+		switch ($name) {
+			case 'import':
+			    if (isset($attrs['location'])) {
+                    $this-&gt;import[$attrs['namespace']][] = array('location' =&gt; $attrs['location'], 'loaded' =&gt; false);
+                    $this-&gt;debug('parsing import ' . $attrs['namespace']. ' - ' . $attrs['location'] . ' (' . count($this-&gt;import[$attrs['namespace']]).')');
+				} else {
+                    $this-&gt;import[$attrs['namespace']][] = array('location' =&gt; '', 'loaded' =&gt; true);
+					if (! $this-&gt;getPrefixFromNamespace($attrs['namespace'])) {
+						$this-&gt;namespaces['ns'.(count($this-&gt;namespaces)+1)] = $attrs['namespace'];
+					}
+                    $this-&gt;debug('parsing import ' . $attrs['namespace']. ' - [no location] (' . count($this-&gt;import[$attrs['namespace']]).')');
+				}
+				break;
+			//wait for schema
+			//case 'types':
+			//	$this-&gt;status = 'schema';
+			//	break;
+			case 'message':
+				$this-&gt;status = 'message';
+				$this-&gt;messages[$attrs['name']] = array();
+				$this-&gt;currentMessage = $attrs['name'];
+				break;
+			case 'portType':
+				$this-&gt;status = 'portType';
+				$this-&gt;portTypes[$attrs['name']] = array();
+				$this-&gt;currentPortType = $attrs['name'];
+				break;
+			case &quot;binding&quot;:
+				if (isset($attrs['name'])) {
+				// get binding name
+					if (strpos($attrs['name'], ':')) {
+			    		$this-&gt;currentBinding = $this-&gt;getLocalPart($attrs['name']);
+					} else {
+			    		$this-&gt;currentBinding = $attrs['name'];
+					} 
+					$this-&gt;status = 'binding';
+					$this-&gt;bindings[$this-&gt;currentBinding]['portType'] = $this-&gt;getLocalPart($attrs['type']);
+					$this-&gt;debug(&quot;current binding: $this-&gt;currentBinding of portType: &quot; . $attrs['type']);
+				} 
+				break;
+			case 'service':
+				$this-&gt;serviceName = $attrs['name'];
+				$this-&gt;status = 'service';
+				$this-&gt;debug('current service: ' . $this-&gt;serviceName);
+				break;
+			case 'definitions':
+				foreach ($attrs as $name =&gt; $value) {
+					$this-&gt;wsdl_info[$name] = $value;
+				} 
+				break;
+			} 
+		} 
+	} 
+
+	/**
+	* end-element handler
+	* 
+	* @param string $parser XML parser object
+	* @param string $name element name
+	* @access private 
+	*/
+	function end_element($parser, $name){ 
+		// unset schema status
+		if (/*ereg('types$', $name) ||*/ ereg('schema$', $name)) {
+			$this-&gt;status = &quot;&quot;;
+            $this-&gt;appendDebug($this-&gt;currentSchema-&gt;getDebug());
+            $this-&gt;currentSchema-&gt;clearDebug();
+			$this-&gt;schemas[$this-&gt;currentSchema-&gt;schemaTargetNamespace][] = $this-&gt;currentSchema;
+        	$this-&gt;debug('Parsing WSDL schema done');
+		} 
+		if ($this-&gt;status == 'schema') {
+			$this-&gt;currentSchema-&gt;schemaEndElement($parser, $name);
+		} else {
+			// bring depth down a notch
+			$this-&gt;depth--;
+		} 
+		// end documentation
+		if ($this-&gt;documentation) {
+			//TODO: track the node to which documentation should be assigned; it can be a part, message, etc.
+			//$this-&gt;portTypes[$this-&gt;currentPortType][$this-&gt;currentPortOperation]['documentation'] = $this-&gt;documentation;
+			$this-&gt;documentation = false;
+		} 
+	} 
+
+	/**
+	 * element content handler
+	 * 
+	 * @param string $parser XML parser object
+	 * @param string $data element content
+	 * @access private 
+	 */
+	function character_data($parser, $data)
+	{
+		$pos = isset($this-&gt;depth_array[$this-&gt;depth]) ? $this-&gt;depth_array[$this-&gt;depth] : 0;
+		if (isset($this-&gt;message[$pos]['cdata'])) {
+			$this-&gt;message[$pos]['cdata'] .= $data;
+		} 
+		if ($this-&gt;documentation) {
+			$this-&gt;documentation .= $data;
+		} 
+	} 
+	
+	function getBindingData($binding)
+	{
+		if (is_array($this-&gt;bindings[$binding])) {
+			return $this-&gt;bindings[$binding];
+		} 
+	}
+	
+	/**
+	 * returns an assoc array of operation names =&gt; operation data
+	 * 
+	 * @param string $bindingType eg: soap, smtp, dime (only soap is currently supported)
+	 * @return array 
+	 * @access public 
+	 */
+	function getOperations($bindingType = 'soap')
+	{
+		$ops = array();
+		if ($bindingType == 'soap') {
+			$bindingType = '<A HREF="http://schemas.xmlsoap.org/wsdl/soap/">http://schemas.xmlsoap.org/wsdl/soap/</A>';
+		}
+		// loop thru ports
+		foreach($this-&gt;ports as $port =&gt; $portData) {
+			// binding type of port matches parameter
+			if ($portData['bindingType'] == $bindingType) {
+				//$this-&gt;debug(&quot;getOperations for port $port&quot;);
+				//$this-&gt;debug(&quot;port data: &quot; . $this-&gt;varDump($portData));
+				//$this-&gt;debug(&quot;bindings: &quot; . $this-&gt;varDump($this-&gt;bindings[ $portData['binding'] ]));
+				// merge bindings
+				if (isset($this-&gt;bindings[ $portData['binding'] ]['operations'])) {
+					$ops = array_merge ($ops, $this-&gt;bindings[ $portData['binding'] ]['operations']);
+				}
+			}
+		} 
+		return $ops;
+	} 
+	
+	/**
+	 * returns an associative array of data necessary for calling an operation
+	 * 
+	 * @param string $operation , name of operation
+	 * @param string $bindingType , type of binding eg: soap
+	 * @return array 
+	 * @access public 
+	 */
+	function getOperationData($operation, $bindingType = 'soap')
+	{
+		if ($bindingType == 'soap') {
+			$bindingType = '<A HREF="http://schemas.xmlsoap.org/wsdl/soap/">http://schemas.xmlsoap.org/wsdl/soap/</A>';
+		}
+		// loop thru ports
+		foreach($this-&gt;ports as $port =&gt; $portData) {
+			// binding type of port matches parameter
+			if ($portData['bindingType'] == $bindingType) {
+				// get binding
+				//foreach($this-&gt;bindings[ $portData['binding'] ]['operations'] as $bOperation =&gt; $opData) {
+				foreach(array_keys($this-&gt;bindings[ $portData['binding'] ]['operations']) as $bOperation) {
+					// note that we could/should also check the namespace here
+					if ($operation == $bOperation) {
+						$opData = $this-&gt;bindings[ $portData['binding'] ]['operations'][$operation];
+					    return $opData;
+					} 
+				} 
+			}
+		} 
+	}
+	
+	/**
+	 * returns an associative array of data necessary for calling an operation
+	 * 
+	 * @param string $soapAction soapAction for operation
+	 * @param string $bindingType type of binding eg: soap
+	 * @return array 
+	 * @access public 
+	 */
+	function getOperationDataForSoapAction($soapAction, $bindingType = 'soap') {
+		if ($bindingType == 'soap') {
+			$bindingType = '<A HREF="http://schemas.xmlsoap.org/wsdl/soap/">http://schemas.xmlsoap.org/wsdl/soap/</A>';
+		}
+		// loop thru ports
+		foreach($this-&gt;ports as $port =&gt; $portData) {
+			// binding type of port matches parameter
+			if ($portData['bindingType'] == $bindingType) {
+				// loop through operations for the binding
+				foreach ($this-&gt;bindings[ $portData['binding'] ]['operations'] as $bOperation =&gt; $opData) {
+					if ($opData['soapAction'] == $soapAction) {
+					    return $opData;
+					} 
+				} 
+			}
+		} 
+	}
+	
+	/**
+    * returns an array of information about a given type
+    * returns false if no type exists by the given name
+    *
+	*	 typeDef = array(
+	*	 'elements' =&gt; array(), // refs to elements array
+	*	'restrictionBase' =&gt; '',
+	*	'phpType' =&gt; '',
+	*	'order' =&gt; '(sequence|all)',
+	*	'attrs' =&gt; array() // refs to attributes array
+	*	)
+    *
+    * @param $type string the type
+    * @param $ns string namespace (not prefix) of the type
+    * @return mixed
+    * @access public
+    * @see xmlschema
+    */
+	function getTypeDef($type, $ns) {
+		$this-&gt;debug(&quot;in getTypeDef: type=$type, ns=$ns&quot;);
+		if ((! $ns) &amp;&amp; isset($this-&gt;namespaces['tns'])) {
+			$ns = $this-&gt;namespaces['tns'];
+			$this-&gt;debug(&quot;in getTypeDef: type namespace forced to $ns&quot;);
+		}
+		if (isset($this-&gt;schemas[$ns])) {
+			$this-&gt;debug(&quot;in getTypeDef: have schema for namespace $ns&quot;);
+			for ($i = 0; $i &lt; count($this-&gt;schemas[$ns]); $i++) {
+				$xs = &amp;$this-&gt;schemas[$ns][$i];
+				$t = $xs-&gt;getTypeDef($type);
+				$this-&gt;appendDebug($xs-&gt;getDebug());
+				$xs-&gt;clearDebug();
+				if ($t) {
+					if (!isset($t['phpType'])) {
+						// get info for type to tack onto the element
+						$uqType = substr($t['type'], strrpos($t['type'], ':') + 1);
+						$ns = substr($t['type'], 0, strrpos($t['type'], ':'));
+						$etype = $this-&gt;getTypeDef($uqType, $ns);
+						if ($etype) {
+							$this-&gt;debug(&quot;found type for [element] $type:&quot;);
+							$this-&gt;debug($this-&gt;varDump($etype));
+							if (isset($etype['phpType'])) {
+								$t['phpType'] = $etype['phpType'];
+							}
+							if (isset($etype['elements'])) {
+								$t['elements'] = $etype['elements'];
+							}
+							if (isset($etype['attrs'])) {
+								$t['attrs'] = $etype['attrs'];
+							}
+						}
+					}
+					return $t;
+				}
+			}
+		} else {
+			$this-&gt;debug(&quot;in getTypeDef: do not have schema for namespace $ns&quot;);
+		}
+		return false;
+	}
+
+    /**
+    * prints html description of services
+    *
+    * @access private
+    */
+    function webDescription(){
+    	global $HTTP_SERVER_VARS;
+
+		if (isset($_SERVER)) {
+			$PHP_SELF = $_SERVER['PHP_SELF'];
+		} elseif (isset($HTTP_SERVER_VARS)) {
+			$PHP_SELF = $HTTP_SERVER_VARS['PHP_SELF'];
+		} else {
+			$this-&gt;setError(&quot;Neither _SERVER nor HTTP_SERVER_VARS is available&quot;);
+		}
+
+		$b = '
+		&lt;html&gt;&lt;head&gt;&lt;title&gt;NuSOAP: '.$this-&gt;serviceName.'&lt;/title&gt;
+		&lt;style type=&quot;text/css&quot;&gt;
+		    body    { font-family: arial; color: #000000; background-color: #ffffff; margin: 0px 0px 0px 0px; }
+		    p       { font-family: arial; color: #000000; margin-top: 0px; margin-bottom: 12px; }
+		    pre { background-color: silver; padding: 5px; font-family: Courier New; font-size: x-small; color: #000000;}
+		    ul      { margin-top: 10px; margin-left: 20px; }
+		    li      { list-style-type: none; margin-top: 10px; color: #000000; }
+		    .content{
+			margin-left: 0px; padding-bottom: 2em; }
+		    .nav {
+			padding-top: 10px; padding-bottom: 10px; padding-left: 15px; font-size: .70em;
+			margin-top: 10px; margin-left: 0px; color: #000000;
+			background-color: #ccccff; width: 20%; margin-left: 20px; margin-top: 20px; }
+		    .title {
+			font-family: arial; font-size: 26px; color: #ffffff;
+			background-color: #999999; width: 105%; margin-left: 0px;
+			padding-top: 10px; padding-bottom: 10px; padding-left: 15px;}
+		    .hidden {
+			position: absolute; visibility: hidden; z-index: 200; left: 250px; top: 100px;
+			font-family: arial; overflow: hidden; width: 600;
+			padding: 20px; font-size: 10px; background-color: #999999;
+			layer-background-color:#FFFFFF; }
+		    a,a:active  { color: charcoal; font-weight: bold; }
+		    a:visited   { color: #666666; font-weight: bold; }
+		    a:hover     { color: cc3300; font-weight: bold; }
+		&lt;/style&gt;
+		&lt;script language=&quot;JavaScript&quot; type=&quot;text/javascript&quot;&gt;
+		&lt;!--
+		// POP-UP CAPTIONS...
+		function lib_bwcheck(){ //Browsercheck (needed)
+		    this.ver=navigator.appVersion
+		    this.agent=navigator.userAgent
+		    this.dom=document.getElementById?1:0
+		    this.opera5=this.agent.indexOf(&quot;Opera 5&quot;)&gt;-1
+		    this.ie5=(this.ver.indexOf(&quot;MSIE 5&quot;)&gt;-1 &amp;&amp; this.dom &amp;&amp; !this.opera5)?1:0;
+		    this.ie6=(this.ver.indexOf(&quot;MSIE 6&quot;)&gt;-1 &amp;&amp; this.dom &amp;&amp; !this.opera5)?1:0;
+		    this.ie4=(document.all &amp;&amp; !this.dom &amp;&amp; !this.opera5)?1:0;
+		    this.ie=this.ie4||this.ie5||this.ie6
+		    this.mac=this.agent.indexOf(&quot;Mac&quot;)&gt;-1
+		    this.ns6=(this.dom &amp;&amp; parseInt(this.ver) &gt;= 5) ?1:0;
+		    this.ns4=(document.layers &amp;&amp; !this.dom)?1:0;
+		    this.bw=(this.ie6 || this.ie5 || this.ie4 || this.ns4 || this.ns6 || this.opera5)
+		    return this
+		}
+		var bw = new lib_bwcheck()
+		//Makes crossbrowser object.
+		function makeObj(obj){
+		    this.evnt=bw.dom? document.getElementById(obj):bw.ie4?document.all[obj]:bw.ns4?document.layers[obj]:0;
+		    if(!this.evnt) return false
+		    this.css=bw.dom||bw.ie4?this.evnt.style:bw.ns4?this.evnt:0;
+		    this.wref=bw.dom||bw.ie4?this.evnt:bw.ns4?this.css.document:0;
+		    this.writeIt=b_writeIt;
+		    return this
+		}
+		// A unit of measure that will be added when setting the position of a layer.
+		//var px = bw.ns4||window.opera?&quot;&quot;:&quot;px&quot;;
+		function b_writeIt(text){
+		    if (bw.ns4){this.wref.write(text);this.wref.close()}
+		    else this.wref.innerHTML = text
+		}
+		//Shows the messages
+		var oDesc;
+		function popup(divid){
+		    if(oDesc = new makeObj(divid)){
+			oDesc.css.visibility = &quot;visible&quot;
+		    }
+		}
+		function popout(){ // Hides message
+		    if(oDesc) oDesc.css.visibility = &quot;hidden&quot;
+		}
+		//--&gt;
+		&lt;/script&gt;
+		&lt;/head&gt;
+		&lt;body&gt;
+		&lt;div class=content&gt;
+			&lt;br&gt;&lt;br&gt;
+			&lt;div class=title&gt;'.$this-&gt;serviceName.'&lt;/div&gt;
+			&lt;div class=nav&gt;
+				&lt;p&gt;View the &lt;a href=&quot;'.$PHP_SELF.'?wsdl&quot;&gt;WSDL&lt;/a&gt; for the service.
+				Click on an operation name to view it&apos;s details.&lt;/p&gt;
+				&lt;ul&gt;';
+				foreach($this-&gt;getOperations() as $op =&gt; $data){
+				    $b .= &quot;&lt;li&gt;&lt;a href='#' onclick=\&quot;popout();popup('$op')\&quot;&gt;$op&lt;/a&gt;&lt;/li&gt;&quot;;
+				    // create hidden div
+				    $b .= &quot;&lt;div id='$op' class='hidden'&gt;
+				    &lt;a href='#' onclick='popout()'&gt;&lt;font color='#ffffff'&gt;Close&lt;/font&gt;&lt;/a&gt;&lt;br&gt;&lt;br&gt;&quot;;
+				    foreach($data as $donnie =&gt; $marie){ // loop through opdata
+						if($donnie == 'input' || $donnie == 'output'){ // show input/output data
+						    $b .= &quot;&lt;font color='white'&gt;&quot;.ucfirst($donnie).':&lt;/font&gt;&lt;br&gt;';
+						    foreach($marie as $captain =&gt; $tenille){ // loop through data
+								if($captain == 'parts'){ // loop thru parts
+								    $b .= &quot;&nbsp;&nbsp;$captain:&lt;br&gt;&quot;;
+					                //if(is_array($tenille)){
+								    	foreach($tenille as $joanie =&gt; $chachi){
+											$b .= &quot;&nbsp;&nbsp;&nbsp;&nbsp;$joanie: $chachi&lt;br&gt;&quot;;
+								    	}
+					        		//}
+								} else {
+								    $b .= &quot;&nbsp;&nbsp;$captain: $tenille&lt;br&gt;&quot;;
+								}
+						    }
+						} else {
+						    $b .= &quot;&lt;font color='white'&gt;&quot;.ucfirst($donnie).&quot;:&lt;/font&gt; $marie&lt;br&gt;&quot;;
+						}
+				    }
+					$b .= '&lt;/div&gt;';
+				}
+				$b .= '
+				&lt;ul&gt;
+			&lt;/div&gt;
+		&lt;/div&gt;&lt;/body&gt;&lt;/html&gt;';
+		return $b;
+    }
+
+	/**
+	* serialize the parsed wsdl
+	*
+	* @param mixed $debug whether to put debug=1 in endpoint URL
+	* @return string serialization of WSDL
+	* @access public 
+	*/
+	function serialize($debug = 0)
+	{
+		$xml = '&lt;?xml version=&quot;1.0&quot; encoding=&quot;ISO-8859-1&quot;?&gt;';
+		$xml .= &quot;\n&lt;definitions&quot;;
+		foreach($this-&gt;namespaces as $k =&gt; $v) {
+			$xml .= &quot; xmlns:$k=\&quot;$v\&quot;&quot;;
+		} 
+		// 10.9.02 - add poulter fix for wsdl and tns declarations
+		if (isset($this-&gt;namespaces['wsdl'])) {
+			$xml .= &quot; xmlns=\&quot;&quot; . $this-&gt;namespaces['wsdl'] . &quot;\&quot;&quot;;
+		} 
+		if (isset($this-&gt;namespaces['tns'])) {
+			$xml .= &quot; targetNamespace=\&quot;&quot; . $this-&gt;namespaces['tns'] . &quot;\&quot;&quot;;
+		} 
+		$xml .= '&gt;'; 
+		// imports
+		if (sizeof($this-&gt;import) &gt; 0) {
+			foreach($this-&gt;import as $ns =&gt; $list) {
+				foreach ($list as $ii) {
+					if ($ii['location'] != '') {
+						$xml .= '&lt;import location=&quot;' . $ii['location'] . '&quot; namespace=&quot;' . $ns . '&quot; /&gt;';
+					} else {
+						$xml .= '&lt;import namespace=&quot;' . $ns . '&quot; /&gt;';
+					}
+				}
+			} 
+		} 
+		// types
+		if (count($this-&gt;schemas)&gt;=1) {
+			$xml .= &quot;\n&lt;types&gt;&quot;;
+			foreach ($this-&gt;schemas as $ns =&gt; $list) {
+				foreach ($list as $xs) {
+					$xml .= $xs-&gt;serializeSchema();
+				}
+			}
+			$xml .= '&lt;/types&gt;';
+		} 
+		// messages
+		if (count($this-&gt;messages) &gt;= 1) {
+			foreach($this-&gt;messages as $msgName =&gt; $msgParts) {
+				$xml .= &quot;\n&lt;message name=\&quot;&quot; . $msgName . '&quot;&gt;';
+				if(is_array($msgParts)){
+					foreach($msgParts as $partName =&gt; $partType) {
+						// print 'serializing '.$partType.', sv: '.$this-&gt;XMLSchemaVersion.'&lt;br&gt;';
+						if (strpos($partType, ':')) {
+						    $typePrefix = $this-&gt;getPrefixFromNamespace($this-&gt;getPrefix($partType));
+						} elseif (isset($this-&gt;typemap[$this-&gt;namespaces['xsd']][$partType])) {
+						    // print 'checking typemap: '.$this-&gt;XMLSchemaVersion.'&lt;br&gt;';
+						    $typePrefix = 'xsd';
+						} else {
+						    foreach($this-&gt;typemap as $ns =&gt; $types) {
+						        if (isset($types[$partType])) {
+						            $typePrefix = $this-&gt;getPrefixFromNamespace($ns);
+						        } 
+						    } 
+						    if (!isset($typePrefix)) {
+						        die(&quot;$partType has no namespace!&quot;);
+						    } 
+						}
+						$ns = $this-&gt;getNamespaceFromPrefix($typePrefix);
+						$typeDef = $this-&gt;getTypeDef($this-&gt;getLocalPart($partType), $ns);
+						if ($typeDef['typeClass'] == 'element') {
+							$elementortype = 'element';
+						} else {
+							$elementortype = 'type';
+						}
+						$xml .= '&lt;part name=&quot;' . $partName . '&quot; ' . $elementortype . '=&quot;' . $typePrefix . ':' . $this-&gt;getLocalPart($partType) . '&quot; /&gt;';
+					}
+				}
+				$xml .= '&lt;/message&gt;';
+			} 
+		} 
+		// bindings &amp; porttypes
+		if (count($this-&gt;bindings) &gt;= 1) {
+			$binding_xml = '';
+			$portType_xml = '';
+			foreach($this-&gt;bindings as $bindingName =&gt; $attrs) {
+				$binding_xml .= &quot;\n&lt;binding name=\&quot;&quot; . $bindingName . '&quot; type=&quot;tns:' . $attrs['portType'] . '&quot;&gt;';
+				$binding_xml .= '&lt;soap:binding style=&quot;' . $attrs['style'] . '&quot; transport=&quot;' . $attrs['transport'] . '&quot;/&gt;';
+				$portType_xml .= &quot;\n&lt;portType name=\&quot;&quot; . $attrs['portType'] . '&quot;&gt;';
+				foreach($attrs['operations'] as $opName =&gt; $opParts) {
+					$binding_xml .= '&lt;operation name=&quot;' . $opName . '&quot;&gt;';
+					$binding_xml .= '&lt;soap:operation soapAction=&quot;' . $opParts['soapAction'] . '&quot; style=&quot;'. $opParts['style'] . '&quot;/&gt;';
+					if (isset($opParts['input']['encodingStyle']) &amp;&amp; $opParts['input']['encodingStyle'] != '') {
+						$enc_style = ' encodingStyle=&quot;' . $opParts['input']['encodingStyle'] . '&quot;';
+					} else {
+						$enc_style = '';
+					}
+					$binding_xml .= '&lt;input&gt;&lt;soap:body use=&quot;' . $opParts['input']['use'] . '&quot; namespace=&quot;' . $opParts['input']['namespace'] . '&quot;' . $enc_style . '/&gt;&lt;/input&gt;';
+					if (isset($opParts['output']['encodingStyle']) &amp;&amp; $opParts['output']['encodingStyle'] != '') {
+						$enc_style = ' encodingStyle=&quot;' . $opParts['output']['encodingStyle'] . '&quot;';
+					} else {
+						$enc_style = '';
+					}
+					$binding_xml .= '&lt;output&gt;&lt;soap:body use=&quot;' . $opParts['output']['use'] . '&quot; namespace=&quot;' . $opParts['output']['namespace'] . '&quot;' . $enc_style . '/&gt;&lt;/output&gt;';
+					$binding_xml .= '&lt;/operation&gt;';
+					$portType_xml .= '&lt;operation name=&quot;' . $opParts['name'] . '&quot;';
+					if (isset($opParts['parameterOrder'])) {
+					    $portType_xml .= ' parameterOrder=&quot;' . $opParts['parameterOrder'] . '&quot;';
+					} 
+					$portType_xml .= '&gt;';
+					if(isset($opParts['documentation']) &amp;&amp; $opParts['documentation'] != '') {
+						$portType_xml .= '&lt;documentation&gt;' . htmlspecialchars($opParts['documentation']) . '&lt;/documentation&gt;';
+					}
+					$portType_xml .= '&lt;input message=&quot;tns:' . $opParts['input']['message'] . '&quot;/&gt;';
+					$portType_xml .= '&lt;output message=&quot;tns:' . $opParts['output']['message'] . '&quot;/&gt;';
+					$portType_xml .= '&lt;/operation&gt;';
+				} 
+				$portType_xml .= '&lt;/portType&gt;';
+				$binding_xml .= '&lt;/binding&gt;';
+			} 
+			$xml .= $portType_xml . $binding_xml;
+		} 
+		// services
+		$xml .= &quot;\n&lt;service name=\&quot;&quot; . $this-&gt;serviceName . '&quot;&gt;';
+		if (count($this-&gt;ports) &gt;= 1) {
+			foreach($this-&gt;ports as $pName =&gt; $attrs) {
+				$xml .= '&lt;port name=&quot;' . $pName . '&quot; binding=&quot;tns:' . $attrs['binding'] . '&quot;&gt;';
+				$xml .= '&lt;soap:address location=&quot;' . $attrs['location'] . ($debug ? '?debug=1' : '') . '&quot;/&gt;';
+				$xml .= '&lt;/port&gt;';
+			} 
+		} 
+		$xml .= '&lt;/service&gt;';
+		return $xml . &quot;\n&lt;/definitions&gt;&quot;;
+	} 
+	
+	/**
+	 * serialize PHP values according to a WSDL message definition
+	 *
+	 * TODO
+	 * - multi-ref serialization
+	 * - validate PHP values against type definitions, return errors if invalid
+	 * 
+	 * @param string $operation operation name
+	 * @param string $direction (input|output)
+	 * @param mixed $parameters parameter value(s)
+	 * @return mixed parameters serialized as XML or false on error (e.g. operation not found)
+	 * @access public
+	 */
+	function serializeRPCParameters($operation, $direction, $parameters)
+	{
+		$this-&gt;debug(&quot;in serializeRPCParameters: operation=$operation, direction=$direction, XMLSchemaVersion=$this-&gt;XMLSchemaVersion&quot;); 
+		$this-&gt;appendDebug('parameters=' . $this-&gt;varDump($parameters));
+		
+		if ($direction != 'input' &amp;&amp; $direction != 'output') {
+			$this-&gt;debug('The value of the \$direction argument needs to be either &quot;input&quot; or &quot;output&quot;');
+			$this-&gt;setError('The value of the \$direction argument needs to be either &quot;input&quot; or &quot;output&quot;');
+			return false;
+		} 
+		if (!$opData = $this-&gt;getOperationData($operation)) {
+			$this-&gt;debug('Unable to retrieve WSDL data for operation: ' . $operation);
+			$this-&gt;setError('Unable to retrieve WSDL data for operation: ' . $operation);
+			return false;
+		}
+		$this-&gt;debug('opData:');
+		$this-&gt;appendDebug($this-&gt;varDump($opData));
+
+		// Get encoding style for output and set to current
+		$encodingStyle = '<A HREF="http://schemas.xmlsoap.org/soap/encoding/">http://schemas.xmlsoap.org/soap/encoding/</A>';
+		if(($direction == 'input') &amp;&amp; isset($opData['output']['encodingStyle']) &amp;&amp; ($opData['output']['encodingStyle'] != $encodingStyle)) {
+			$encodingStyle = $opData['output']['encodingStyle'];
+			$enc_style = $encodingStyle;
+		}
+
+		// set input params
+		$xml = '';
+		if (isset($opData[$direction]['parts']) &amp;&amp; sizeof($opData[$direction]['parts']) &gt; 0) {
+			
+			$use = $opData[$direction]['use'];
+			$this-&gt;debug('have ' . count($opData[$direction]['parts']) . ' part(s) to serialize');
+			if (is_array($parameters)) {
+				$parametersArrayType = $this-&gt;isArraySimpleOrStruct($parameters);
+				$this-&gt;debug('have ' . count($parameters) . ' parameter(s) provided as ' . $parametersArrayType . ' to serialize');
+				foreach($opData[$direction]['parts'] as $name =&gt; $type) {
+					$this-&gt;debug('serializing part &quot;'.$name.'&quot; of type &quot;'.$type.'&quot;');
+					// Track encoding style
+					if (isset($opData[$direction]['encodingStyle']) &amp;&amp; $encodingStyle != $opData[$direction]['encodingStyle']) {
+						$encodingStyle = $opData[$direction]['encodingStyle'];			
+						$enc_style = $encodingStyle;
+					} else {
+						$enc_style = false;
+					}
+					// NOTE: add error handling here
+					// if serializeType returns false, then catch global error and fault
+					if ($parametersArrayType == 'arraySimple') {
+						$p = array_shift($parameters);
+						$this-&gt;debug('calling serializeType w/indexed param');
+						$xml .= $this-&gt;serializeType($name, $type, $p, $use, $enc_style);
+					} elseif (isset($parameters[$name])) {
+						$this-&gt;debug('calling serializeType w/named param');
+						$xml .= $this-&gt;serializeType($name, $type, $parameters[$name], $use, $enc_style);
+					} else {
+						// TODO: only send nillable
+						$this-&gt;debug('calling serializeType w/null param');
+						$xml .= $this-&gt;serializeType($name, $type, null, $use, $enc_style);
+					}
+				}
+			} else {
+				$this-&gt;debug('no parameters passed.');
+			}
+		}
+		$this-&gt;debug(&quot;serializeRPCParameters returning: $xml&quot;);
+		return $xml;
+	} 
+	
+	/**
+	 * serialize a PHP value according to a WSDL message definition
+	 * 
+	 * TODO
+	 * - multi-ref serialization
+	 * - validate PHP values against type definitions, return errors if invalid
+	 * 
+	 * @param string $ type name
+	 * @param mixed $ param value
+	 * @return mixed new param or false if initial value didn't validate
+	 * @access public
+	 * @deprecated
+	 */
+	function serializeParameters($operation, $direction, $parameters)
+	{
+		$this-&gt;debug(&quot;in serializeParameters: operation=$operation, direction=$direction, XMLSchemaVersion=$this-&gt;XMLSchemaVersion&quot;); 
+		$this-&gt;appendDebug('parameters=' . $this-&gt;varDump($parameters));
+		
+		if ($direction != 'input' &amp;&amp; $direction != 'output') {
+			$this-&gt;debug('The value of the \$direction argument needs to be either &quot;input&quot; or &quot;output&quot;');
+			$this-&gt;setError('The value of the \$direction argument needs to be either &quot;input&quot; or &quot;output&quot;');
+			return false;
+		} 
+		if (!$opData = $this-&gt;getOperationData($operation)) {
+			$this-&gt;debug('Unable to retrieve WSDL data for operation: ' . $operation);
+			$this-&gt;setError('Unable to retrieve WSDL data for operation: ' . $operation);
+			return false;
+		}
+		$this-&gt;debug('opData:');
+		$this-&gt;appendDebug($this-&gt;varDump($opData));
+		
+		// Get encoding style for output and set to current
+		$encodingStyle = '<A HREF="http://schemas.xmlsoap.org/soap/encoding/">http://schemas.xmlsoap.org/soap/encoding/</A>';
+		if(($direction == 'input') &amp;&amp; isset($opData['output']['encodingStyle']) &amp;&amp; ($opData['output']['encodingStyle'] != $encodingStyle)) {
+			$encodingStyle = $opData['output']['encodingStyle'];
+			$enc_style = $encodingStyle;
+		}
+		
+		// set input params
+		$xml = '';
+		if (isset($opData[$direction]['parts']) &amp;&amp; sizeof($opData[$direction]['parts']) &gt; 0) {
+			
+			$use = $opData[$direction]['use'];
+			$this-&gt;debug(&quot;use=$use&quot;);
+			$this-&gt;debug('got ' . count($opData[$direction]['parts']) . ' part(s)');
+			if (is_array($parameters)) {
+				$parametersArrayType = $this-&gt;isArraySimpleOrStruct($parameters);
+				$this-&gt;debug('have ' . $parametersArrayType . ' parameters');
+				foreach($opData[$direction]['parts'] as $name =&gt; $type) {
+					$this-&gt;debug('serializing part &quot;'.$name.'&quot; of type &quot;'.$type.'&quot;');
+					// Track encoding style
+					if(isset($opData[$direction]['encodingStyle']) &amp;&amp; $encodingStyle != $opData[$direction]['encodingStyle']) {
+						$encodingStyle = $opData[$direction]['encodingStyle'];			
+						$enc_style = $encodingStyle;
+					} else {
+						$enc_style = false;
+					}
+					// NOTE: add error handling here
+					// if serializeType returns false, then catch global error and fault
+					if ($parametersArrayType == 'arraySimple') {
+						$p = array_shift($parameters);
+						$this-&gt;debug('calling serializeType w/indexed param');
+						$xml .= $this-&gt;serializeType($name, $type, $p, $use, $enc_style);
+					} elseif (isset($parameters[$name])) {
+						$this-&gt;debug('calling serializeType w/named param');
+						$xml .= $this-&gt;serializeType($name, $type, $parameters[$name], $use, $enc_style);
+					} else {
+						// TODO: only send nillable
+						$this-&gt;debug('calling serializeType w/null param');
+						$xml .= $this-&gt;serializeType($name, $type, null, $use, $enc_style);
+					}
+				}
+			} else {
+				$this-&gt;debug('no parameters passed.');
+			}
+		}
+		$this-&gt;debug(&quot;serializeParameters returning: $xml&quot;);
+		return $xml;
+	} 
+	
+	/**
+	 * serializes a PHP value according a given type definition
+	 * 
+	 * @param string $name name of value (part or element)
+	 * @param string $type XML schema type of value (type or element)
+	 * @param mixed $value a native PHP value (parameter value)
+	 * @param string $use use for part (encoded|literal)
+	 * @param string $encodingStyle SOAP encoding style for the value (if different than the enclosing style)
+	 * @param boolean $unqualified a kludge for what should be XML namespace form handling
+	 * @return string value serialized as an XML string
+	 * @access private
+	 */
+	function serializeType($name, $type, $value, $use='encoded', $encodingStyle=false, $unqualified=false)
+	{
+		$this-&gt;debug(&quot;in serializeType: name=$name, type=$type, use=$use, encodingStyle=$encodingStyle, unqualified=&quot; . ($unqualified ? &quot;unqualified&quot; : &quot;qualified&quot;));
+		$this-&gt;appendDebug(&quot;value=&quot; . $this-&gt;varDump($value));
+		if($use == 'encoded' &amp;&amp; $encodingStyle) {
+			$encodingStyle = ' SOAP-ENV:encodingStyle=&quot;' . $encodingStyle . '&quot;';
+		}
+
+		// if a soapval has been supplied, let its type override the WSDL
+    	if (is_object($value) &amp;&amp; get_class($value) == 'soapval') {
+    		if ($value-&gt;type_ns) {
+    			$type = $value-&gt;type_ns . ':' . $value-&gt;type;
+		    	$forceType = true;
+		    	$this-&gt;debug(&quot;in serializeType: soapval overrides type to $type&quot;);
+    		} elseif ($value-&gt;type) {
+	    		$type = $value-&gt;type;
+		    	$forceType = true;
+		    	$this-&gt;debug(&quot;in serializeType: soapval overrides type to $type&quot;);
+	    	} else {
+	    		$forceType = false;
+		    	$this-&gt;debug(&quot;in serializeType: soapval does not override type&quot;);
+	    	}
+	    	$attrs = $value-&gt;attributes;
+	    	$value = $value-&gt;value;
+	    	$this-&gt;debug(&quot;in serializeType: soapval overrides value to $value&quot;);
+	    	if ($attrs) {
+	    		if (!is_array($value)) {
+	    			$value['!'] = $value;
+	    		}
+	    		foreach ($attrs as $n =&gt; $v) {
+	    			$value['!' . $n] = $v;
+	    		}
+		    	$this-&gt;debug(&quot;in serializeType: soapval provides attributes&quot;);
+		    }
+        } else {
+        	$forceType = false;
+        }
+
+		$xml = '';
+		if (strpos($type, ':')) {
+			$uqType = substr($type, strrpos($type, ':') + 1);
+			$ns = substr($type, 0, strrpos($type, ':'));
+			$this-&gt;debug(&quot;in serializeType: got a prefixed type: $uqType, $ns&quot;);
+			if ($this-&gt;getNamespaceFromPrefix($ns)) {
+				$ns = $this-&gt;getNamespaceFromPrefix($ns);
+				$this-&gt;debug(&quot;in serializeType: expanded prefixed type: $uqType, $ns&quot;);
+			}
+
+			if($ns == $this-&gt;XMLSchemaVersion || $ns == '<A HREF="http://schemas.xmlsoap.org/soap/encoding/">http://schemas.xmlsoap.org/soap/encoding/</A>'){
+				$this-&gt;debug('in serializeType: type namespace indicates XML Schema or SOAP Encoding type');
+				if ($unqualified  &amp;&amp; $use == 'literal') {
+					$elementNS = &quot; xmlns=\&quot;\&quot;&quot;;
+				} else {
+					$elementNS = '';
+				}
+				if (is_null($value)) {
+					if ($use == 'literal') {
+						// TODO: depends on minOccurs
+						$xml = &quot;&lt;$name$elementNS/&gt;&quot;;
+					} else {
+						// TODO: depends on nillable, which should be checked before calling this method
+						$xml = &quot;&lt;$name$elementNS xsi:nil=\&quot;true\&quot; xsi:type=\&quot;&quot; . $this-&gt;getPrefixFromNamespace($ns) . &quot;:$uqType\&quot;/&gt;&quot;;
+					}
+					$this-&gt;debug(&quot;in serializeType: returning: $xml&quot;);
+					return $xml;
+				}
+		    	if ($uqType == 'boolean') {
+		    		if ((is_string($value) &amp;&amp; $value == 'false') || (! $value)) {
+						$value = 'false';
+					} else {
+						$value = 'true';
+					}
+				} 
+				if ($uqType == 'string' &amp;&amp; gettype($value) == 'string') {
+					$value = $this-&gt;expandEntities($value);
+				}
+				if (($uqType == 'long' || $uqType == 'unsignedLong') &amp;&amp; gettype($value) == 'double') {
+					$value = sprintf(&quot;%.0lf&quot;, $value);
+				}
+				// it's a scalar
+				// TODO: what about null/nil values?
+				// check type isn't a custom type extending xmlschema namespace
+				if (!$this-&gt;getTypeDef($uqType, $ns)) {
+					if ($use == 'literal') {
+						if ($forceType) {
+							$xml = &quot;&lt;$name$elementNS xsi:type=\&quot;&quot; . $this-&gt;getPrefixFromNamespace($ns) . &quot;:$uqType\&quot;&gt;$value&lt;/$name&gt;&quot;;
+						} else {
+							$xml = &quot;&lt;$name$elementNS&gt;$value&lt;/$name&gt;&quot;;
+						}
+					} else {
+						$xml = &quot;&lt;$name$elementNS xsi:type=\&quot;&quot; . $this-&gt;getPrefixFromNamespace($ns) . &quot;:$uqType\&quot;$encodingStyle&gt;$value&lt;/$name&gt;&quot;;
+					}
+					$this-&gt;debug(&quot;in serializeType: returning: $xml&quot;);
+					return $xml;
+				}
+				$this-&gt;debug('custom type extends XML Schema or SOAP Encoding namespace (yuck)');
+			} else if ($ns == '<A HREF="http://xml.apache.org/xml-soap">http://xml.apache.org/xml-soap</A>') {
+				$this-&gt;debug('in serializeType: appears to be Apache SOAP type');
+				if ($uqType == 'Map') {
+					$tt_prefix = $this-&gt;getPrefixFromNamespace('<A HREF="http://xml.apache.org/xml-soap">http://xml.apache.org/xml-soap</A>');
+					if (! $tt_prefix) {
+						$this-&gt;debug('in serializeType: Add namespace for Apache SOAP type');
+						$tt_prefix = 'ns' . rand(1000, 9999);
+						$this-&gt;namespaces[$tt_prefix] = '<A HREF="http://xml.apache.org/xml-soap">http://xml.apache.org/xml-soap</A>';
+						// force this to be added to usedNamespaces
+						$tt_prefix = $this-&gt;getPrefixFromNamespace('<A HREF="http://xml.apache.org/xml-soap">http://xml.apache.org/xml-soap</A>');
+					}
+					$contents = '';
+					foreach($value as $k =&gt; $v) {
+						$this-&gt;debug(&quot;serializing map element: key $k, value $v&quot;);
+						$contents .= '&lt;item&gt;';
+						$contents .= $this-&gt;serialize_val($k,'key',false,false,false,false,$use);
+						$contents .= $this-&gt;serialize_val($v,'value',false,false,false,false,$use);
+						$contents .= '&lt;/item&gt;';
+					}
+					if ($use == 'literal') {
+						if ($forceType) {
+							$xml = &quot;&lt;$name xsi:type=\&quot;&quot; . $tt_prefix . &quot;:$uqType\&quot;&gt;$contents&lt;/$name&gt;&quot;;
+						} else {
+							$xml = &quot;&lt;$name&gt;$contents&lt;/$name&gt;&quot;;
+						}
+					} else {
+						$xml = &quot;&lt;$name xsi:type=\&quot;&quot; . $tt_prefix . &quot;:$uqType\&quot;$encodingStyle&gt;$contents&lt;/$name&gt;&quot;;
+					}
+					$this-&gt;debug(&quot;in serializeType: returning: $xml&quot;);
+					return $xml;
+				}
+				$this-&gt;debug('in serializeType: Apache SOAP type, but only support Map');
+			}
+		} else {
+			// TODO: should the type be compared to types in XSD, and the namespace
+			// set to XSD if the type matches?
+			$this-&gt;debug(&quot;in serializeType: No namespace for type $type&quot;);
+			$ns = '';
+			$uqType = $type;
+		}
+		if(!$typeDef = $this-&gt;getTypeDef($uqType, $ns)){
+			$this-&gt;setError(&quot;$type ($uqType) is not a supported type.&quot;);
+			$this-&gt;debug(&quot;in serializeType: $type ($uqType) is not a supported type.&quot;);
+			return false;
+		} else {
+			$this-&gt;debug(&quot;in serializeType: found typeDef&quot;);
+			$this-&gt;appendDebug('typeDef=' . $this-&gt;varDump($typeDef));
+		}
+		$phpType = $typeDef['phpType'];
+		$this-&gt;debug(&quot;in serializeType: uqType: $uqType, ns: $ns, phptype: $phpType, arrayType: &quot; . (isset($typeDef['arrayType']) ? $typeDef['arrayType'] : '') ); 
+		// if php type == struct, map value to the &lt;all&gt; element names
+		if ($phpType == 'struct') {
+			if (isset($typeDef['typeClass']) &amp;&amp; $typeDef['typeClass'] == 'element') {
+				$elementName = $uqType;
+				if (isset($typeDef['form']) &amp;&amp; ($typeDef['form'] == 'qualified')) {
+					$elementNS = &quot; xmlns=\&quot;$ns\&quot;&quot;;
+				} else {
+					$elementNS = &quot; xmlns=\&quot;\&quot;&quot;;
+				}
+			} else {
+				$elementName = $name;
+				if ($unqualified) {
+					$elementNS = &quot; xmlns=\&quot;\&quot;&quot;;
+				} else {
+					$elementNS = '';
+				}
+			}
+			if (is_null($value)) {
+				if ($use == 'literal') {
+					// TODO: depends on minOccurs
+					$xml = &quot;&lt;$elementName$elementNS/&gt;&quot;;
+				} else {
+					$xml = &quot;&lt;$elementName$elementNS xsi:nil=\&quot;true\&quot; xsi:type=\&quot;&quot; . $this-&gt;getPrefixFromNamespace($ns) . &quot;:$uqType\&quot;/&gt;&quot;;
+				}
+				$this-&gt;debug(&quot;in serializeType: returning: $xml&quot;);
+				return $xml;
+			}
+			if (is_object($value)) {
+				$value = get_object_vars($value);
+			}
+			if (is_array($value)) {
+				$elementAttrs = $this-&gt;serializeComplexTypeAttributes($typeDef, $value, $ns, $uqType);
+				if ($use == 'literal') {
+					if ($forceType) {
+						$xml = &quot;&lt;$elementName$elementNS$elementAttrs xsi:type=\&quot;&quot; . $this-&gt;getPrefixFromNamespace($ns) . &quot;:$uqType\&quot;&gt;&quot;;
+					} else {
+						$xml = &quot;&lt;$elementName$elementNS$elementAttrs&gt;&quot;;
+					}
+				} else {
+					$xml = &quot;&lt;$elementName$elementNS$elementAttrs xsi:type=\&quot;&quot; . $this-&gt;getPrefixFromNamespace($ns) . &quot;:$uqType\&quot;$encodingStyle&gt;&quot;;
+				}
+	
+				$xml .= $this-&gt;serializeComplexTypeElements($typeDef, $value, $ns, $uqType, $use, $encodingStyle);
+				$xml .= &quot;&lt;/$elementName&gt;&quot;;
+			} else {
+				$this-&gt;debug(&quot;in serializeType: phpType is struct, but value is not an array&quot;);
+				$this-&gt;setError(&quot;phpType is struct, but value is not an array: see debug output for details&quot;);
+				$xml = '';
+			}
+		} elseif ($phpType == 'array') {
+			if (isset($typeDef['form']) &amp;&amp; ($typeDef['form'] == 'qualified')) {
+				$elementNS = &quot; xmlns=\&quot;$ns\&quot;&quot;;
+			} else {
+				if ($unqualified) {
+					$elementNS = &quot; xmlns=\&quot;\&quot;&quot;;
+				} else {
+					$elementNS = '';
+				}
+			}
+			if (is_null($value)) {
+				if ($use == 'literal') {
+					// TODO: depends on minOccurs
+					$xml = &quot;&lt;$name$elementNS/&gt;&quot;;
+				} else {
+					$xml = &quot;&lt;$name$elementNS xsi:nil=\&quot;true\&quot; xsi:type=\&quot;&quot; .
+						$this-&gt;getPrefixFromNamespace('<A HREF="http://schemas.xmlsoap.org/soap/encoding/">http://schemas.xmlsoap.org/soap/encoding/</A>') .
+						&quot;:Array\&quot; &quot; .
+						$this-&gt;getPrefixFromNamespace('<A HREF="http://schemas.xmlsoap.org/soap/encoding/">http://schemas.xmlsoap.org/soap/encoding/</A>') .
+						':arrayType=&quot;' .
+						$this-&gt;getPrefixFromNamespace($this-&gt;getPrefix($typeDef['arrayType'])) .
+						':' .
+						$this-&gt;getLocalPart($typeDef['arrayType']).&quot;[0]\&quot;/&gt;&quot;;
+				}
+				$this-&gt;debug(&quot;in serializeType: returning: $xml&quot;);
+				return $xml;
+			}
+			if (isset($typeDef['multidimensional'])) {
+				$nv = array();
+				foreach($value as $v) {
+					$cols = ',' . sizeof($v);
+					$nv = array_merge($nv, $v);
+				} 
+				$value = $nv;
+			} else {
+				$cols = '';
+			} 
+			if (is_array($value) &amp;&amp; sizeof($value) &gt;= 1) {
+				$rows = sizeof($value);
+				$contents = '';
+				foreach($value as $k =&gt; $v) {
+					$this-&gt;debug(&quot;serializing array element: $k, $v of type: $typeDef[arrayType]&quot;);
+					//if (strpos($typeDef['arrayType'], ':') ) {
+					if (!in_array($typeDef['arrayType'],$this-&gt;typemap['<A HREF="http://www.w3.org/2001/XMLSchema">http://www.w3.org/2001/XMLSchema</A>'])) {
+					    $contents .= $this-&gt;serializeType('item', $typeDef['arrayType'], $v, $use);
+					} else {
+					    $contents .= $this-&gt;serialize_val($v, 'item', $typeDef['arrayType'], null, $this-&gt;XMLSchemaVersion, false, $use);
+					} 
+				}
+			} else {
+				$rows = 0;
+				$contents = null;
+			}
+			// TODO: for now, an empty value will be serialized as a zero element
+			// array.  Revisit this when coding the handling of null/nil values.
+			if ($use == 'literal') {
+				$xml = &quot;&lt;$name$elementNS&gt;&quot;
+					.$contents
+					.&quot;&lt;/$name&gt;&quot;;
+			} else {
+				$xml = &quot;&lt;$name$elementNS xsi:type=\&quot;&quot;.$this-&gt;getPrefixFromNamespace('<A HREF="http://schemas.xmlsoap.org/soap/encoding/">http://schemas.xmlsoap.org/soap/encoding/</A>').':Array&quot; '.
+					$this-&gt;getPrefixFromNamespace('<A HREF="http://schemas.xmlsoap.org/soap/encoding/">http://schemas.xmlsoap.org/soap/encoding/</A>')
+					.':arrayType=&quot;'
+					.$this-&gt;getPrefixFromNamespace($this-&gt;getPrefix($typeDef['arrayType']))
+					.&quot;:&quot;.$this-&gt;getLocalPart($typeDef['arrayType']).&quot;[$rows$cols]\&quot;&gt;&quot;
+					.$contents
+					.&quot;&lt;/$name&gt;&quot;;
+			}
+		} elseif ($phpType == 'scalar') {
+			if (isset($typeDef['form']) &amp;&amp; ($typeDef['form'] == 'qualified')) {
+				$elementNS = &quot; xmlns=\&quot;$ns\&quot;&quot;;
+			} else {
+				if ($unqualified) {
+					$elementNS = &quot; xmlns=\&quot;\&quot;&quot;;
+				} else {
+					$elementNS = '';
+				}
+			}
+			if ($use == 'literal') {
+				if ($forceType) {
+					$xml = &quot;&lt;$name$elementNS xsi:type=\&quot;&quot; . $this-&gt;getPrefixFromNamespace($ns) . &quot;:$uqType\&quot;&gt;$value&lt;/$name&gt;&quot;;
+				} else {
+					$xml = &quot;&lt;$name$elementNS&gt;$value&lt;/$name&gt;&quot;;
+				}
+			} else {
+				$xml = &quot;&lt;$name$elementNS xsi:type=\&quot;&quot; . $this-&gt;getPrefixFromNamespace($ns) . &quot;:$uqType\&quot;$encodingStyle&gt;$value&lt;/$name&gt;&quot;;
+			}
+		}
+		$this-&gt;debug(&quot;in serializeType: returning: $xml&quot;);
+		return $xml;
+	}
+	
+	/**
+	 * serializes the attributes for a complexType
+	 *
+	 * @param array $typeDef our internal representation of an XML schema type (or element)
+	 * @param mixed $value a native PHP value (parameter value)
+	 * @param string $ns the namespace of the type
+	 * @param string $uqType the local part of the type
+	 * @return string value serialized as an XML string
+	 * @access private
+	 */
+	function serializeComplexTypeAttributes($typeDef, $value, $ns, $uqType) {
+		$xml = '';
+		if (isset($typeDef['attrs']) &amp;&amp; is_array($typeDef['attrs'])) {
+			$this-&gt;debug(&quot;serialize attributes for XML Schema type $ns:$uqType&quot;);
+			if (is_array($value)) {
+				$xvalue = $value;
+			} elseif (is_object($value)) {
+				$xvalue = get_object_vars($value);
+			} else {
+				$this-&gt;debug(&quot;value is neither an array nor an object for XML Schema type $ns:$uqType&quot;);
+				$xvalue = array();
+			}
+			foreach ($typeDef['attrs'] as $aName =&gt; $attrs) {
+				if (isset($xvalue['!' . $aName])) {
+					$xname = '!' . $aName;
+					$this-&gt;debug(&quot;value provided for attribute $aName with key $xname&quot;);
+				} elseif (isset($xvalue[$aName])) {
+					$xname = $aName;
+					$this-&gt;debug(&quot;value provided for attribute $aName with key $xname&quot;);
+				} elseif (isset($attrs['default'])) {
+					$xname = '!' . $aName;
+					$xvalue[$xname] = $attrs['default'];
+					$this-&gt;debug('use default value of ' . $xvalue[$aName] . ' for attribute ' . $aName);
+				} else {
+					$xname = '';
+					$this-&gt;debug(&quot;no value provided for attribute $aName&quot;);
+				}
+				if ($xname) {
+					$xml .=  &quot; $aName=\&quot;&quot; . $this-&gt;expandEntities($xvalue[$xname]) . &quot;\&quot;&quot;;
+				}
+			} 
+		} else {
+			$this-&gt;debug(&quot;no attributes to serialize for XML Schema type $ns:$uqType&quot;);
+		}
+		if (isset($typeDef['extensionBase'])) {
+			$ns = $this-&gt;getPrefix($typeDef['extensionBase']);
+			$uqType = $this-&gt;getLocalPart($typeDef['extensionBase']);
+			if ($this-&gt;getNamespaceFromPrefix($ns)) {
+				$ns = $this-&gt;getNamespaceFromPrefix($ns);
+			}
+			if ($typeDef = $this-&gt;getTypeDef($uqType, $ns)) {
+				$this-&gt;debug(&quot;serialize attributes for extension base $ns:$uqType&quot;);
+				$xml .= $this-&gt;serializeComplexTypeAttributes($typeDef, $value, $ns, $uqType);
+			} else {
+				$this-&gt;debug(&quot;extension base $ns:$uqType is not a supported type&quot;);
+			}
+		}
+		return $xml;
+	}
+
+	/**
+	 * serializes the elements for a complexType
+	 *
+	 * @param array $typeDef our internal representation of an XML schema type (or element)
+	 * @param mixed $value a native PHP value (parameter value)
+	 * @param string $ns the namespace of the type
+	 * @param string $uqType the local part of the type
+	 * @param string $use use for part (encoded|literal)
+	 * @param string $encodingStyle SOAP encoding style for the value (if different than the enclosing style)
+	 * @return string value serialized as an XML string
+	 * @access private
+	 */
+	function serializeComplexTypeElements($typeDef, $value, $ns, $uqType, $use='encoded', $encodingStyle=false) {
+		$xml = '';
+		if (isset($typeDef['elements']) &amp;&amp; is_array($typeDef['elements'])) {
+			$this-&gt;debug(&quot;in serializeComplexTypeElements, serialize elements for XML Schema type $ns:$uqType&quot;);
+			if (is_array($value)) {
+				$xvalue = $value;
+			} elseif (is_object($value)) {
+				$xvalue = get_object_vars($value);
+			} else {
+				$this-&gt;debug(&quot;value is neither an array nor an object for XML Schema type $ns:$uqType&quot;);
+				$xvalue = array();
+			}
+			// toggle whether all elements are present - ideally should validate against schema
+			if (count($typeDef['elements']) != count($xvalue)){
+				$optionals = true;
+			}
+			foreach ($typeDef['elements'] as $eName =&gt; $attrs) {
+				if (!isset($xvalue[$eName])) {
+					if (isset($attrs['default'])) {
+						$xvalue[$eName] = $attrs['default'];
+						$this-&gt;debug('use default value of ' . $xvalue[$eName] . ' for element ' . $eName);
+					}
+				}
+				// if user took advantage of a minOccurs=0, then only serialize named parameters
+				if (isset($optionals)
+				    &amp;&amp; (!isset($xvalue[$eName])) 
+					&amp;&amp; ( (!isset($attrs['nillable'])) || $attrs['nillable'] != 'true')
+					){
+					if (isset($attrs['minOccurs']) &amp;&amp; $attrs['minOccurs'] &lt;&gt; '0') {
+						$this-&gt;debug(&quot;apparent error: no value provided for element $eName with minOccurs=&quot; . $attrs['minOccurs']);
+					}
+					// do nothing
+					$this-&gt;debug(&quot;no value provided for complexType element $eName and element is not nillable, so serialize nothing&quot;);
+				} else {
+					// get value
+					if (isset($xvalue[$eName])) {
+					    $v = $xvalue[$eName];
+					} else {
+					    $v = null;
+					}
+					if (isset($attrs['form'])) {
+						$unqualified = ($attrs['form'] == 'unqualified');
+					} else {
+						$unqualified = false;
+					}
+					if (isset($attrs['maxOccurs']) &amp;&amp; ($attrs['maxOccurs'] == 'unbounded' || $attrs['maxOccurs'] &gt; 1) &amp;&amp; isset($v) &amp;&amp; is_array($v) &amp;&amp; $this-&gt;isArraySimpleOrStruct($v) == 'arraySimple') {
+						$vv = $v;
+						foreach ($vv as $k =&gt; $v) {
+							if (isset($attrs['type']) || isset($attrs['ref'])) {
+								// serialize schema-defined type
+							    $xml .= $this-&gt;serializeType($eName, isset($attrs['type']) ? $attrs['type'] : $attrs['ref'], $v, $use, $encodingStyle, $unqualified);
+							} else {
+								// serialize generic type (can this ever really happen?)
+							    $this-&gt;debug(&quot;calling serialize_val() for $v, $eName, false, false, false, false, $use&quot;);
+							    $xml .= $this-&gt;serialize_val($v, $eName, false, false, false, false, $use);
+							}
+						}
+					} else {
+						if (isset($attrs['type']) || isset($attrs['ref'])) {
+							// serialize schema-defined type
+						    $xml .= $this-&gt;serializeType($eName, isset($attrs['type']) ? $attrs['type'] : $attrs['ref'], $v, $use, $encodingStyle, $unqualified);
+						} else {
+							// serialize generic type (can this ever really happen?)
+						    $this-&gt;debug(&quot;calling serialize_val() for $v, $eName, false, false, false, false, $use&quot;);
+						    $xml .= $this-&gt;serialize_val($v, $eName, false, false, false, false, $use);
+						}
+					}
+				}
+			} 
+		} else {
+			$this-&gt;debug(&quot;no elements to serialize for XML Schema type $ns:$uqType&quot;);
+		}
+		if (isset($typeDef['extensionBase'])) {
+			$ns = $this-&gt;getPrefix($typeDef['extensionBase']);
+			$uqType = $this-&gt;getLocalPart($typeDef['extensionBase']);
+			if ($this-&gt;getNamespaceFromPrefix($ns)) {
+				$ns = $this-&gt;getNamespaceFromPrefix($ns);
+			}
+			if ($typeDef = $this-&gt;getTypeDef($uqType, $ns)) {
+				$this-&gt;debug(&quot;serialize elements for extension base $ns:$uqType&quot;);
+				$xml .= $this-&gt;serializeComplexTypeElements($typeDef, $value, $ns, $uqType, $use, $encodingStyle);
+			} else {
+				$this-&gt;debug(&quot;extension base $ns:$uqType is not a supported type&quot;);
+			}
+		}
+		return $xml;
+	}
+
+	/**
+	* adds an XML Schema complex type to the WSDL types
+	*
+	* @param string	name
+	* @param string typeClass (complexType|simpleType|attribute)
+	* @param string phpType: currently supported are array and struct (php assoc array)
+	* @param string compositor (all|sequence|choice)
+	* @param string restrictionBase namespace:name (<A HREF="http://schemas.xmlsoap.org/soap/encoding/:Array">http://schemas.xmlsoap.org/soap/encoding/:Array</A>)
+	* @param array elements = array ( name =&gt; array(name=&gt;'',type=&gt;'') )
+	* @param array attrs = 	array(array('ref'=&gt;'SOAP-ENC:arrayType','wsdl:arrayType'=&gt;'xsd:string[]'))
+	* @param string arrayType: namespace:name (xsd:string)
+	* @see xmlschema
+	* @access public
+	*/
+	function addComplexType($name,$typeClass='complexType',$phpType='array',$compositor='',$restrictionBase='',$elements=array(),$attrs=array(),$arrayType='') {
+		if (count($elements) &gt; 0) {
+	    	foreach($elements as $n =&gt; $e){
+	            // expand each element
+	            foreach ($e as $k =&gt; $v) {
+		            $k = strpos($k,':') ? $this-&gt;expandQname($k) : $k;
+		            $v = strpos($v,':') ? $this-&gt;expandQname($v) : $v;
+		            $ee[$k] = $v;
+		    	}
+	    		$eElements[$n] = $ee;
+	    	}
+	    	$elements = $eElements;
+		}
+		
+		if (count($attrs) &gt; 0) {
+	    	foreach($attrs as $n =&gt; $a){
+	            // expand each attribute
+	            foreach ($a as $k =&gt; $v) {
+		            $k = strpos($k,':') ? $this-&gt;expandQname($k) : $k;
+		            $v = strpos($v,':') ? $this-&gt;expandQname($v) : $v;
+		            $aa[$k] = $v;
+		    	}
+	    		$eAttrs[$n] = $aa;
+	    	}
+	    	$attrs = $eAttrs;
+		}
+
+		$restrictionBase = strpos($restrictionBase,':') ? $this-&gt;expandQname($restrictionBase) : $restrictionBase;
+		$arrayType = strpos($arrayType,':') ? $this-&gt;expandQname($arrayType) : $arrayType;
+
+		$typens = isset($this-&gt;namespaces['types']) ? $this-&gt;namespaces['types'] : $this-&gt;namespaces['tns'];
+		$this-&gt;schemas[$typens][0]-&gt;addComplexType($name,$typeClass,$phpType,$compositor,$restrictionBase,$elements,$attrs,$arrayType);
+	}
+
+	/**
+	* adds an XML Schema simple type to the WSDL types
+	*
+	* @param string $name
+	* @param string $restrictionBase namespace:name (<A HREF="http://schemas.xmlsoap.org/soap/encoding/:Array">http://schemas.xmlsoap.org/soap/encoding/:Array</A>)
+	* @param string $typeClass (should always be simpleType)
+	* @param string $phpType (should always be scalar)
+	* @param array $enumeration array of values
+	* @see xmlschema
+	* @access public
+	*/
+	function addSimpleType($name, $restrictionBase='', $typeClass='simpleType', $phpType='scalar', $enumeration=array()) {
+		$restrictionBase = strpos($restrictionBase,':') ? $this-&gt;expandQname($restrictionBase) : $restrictionBase;
+
+		$typens = isset($this-&gt;namespaces['types']) ? $this-&gt;namespaces['types'] : $this-&gt;namespaces['tns'];
+		$this-&gt;schemas[$typens][0]-&gt;addSimpleType($name, $restrictionBase, $typeClass, $phpType, $enumeration);
+	}
+
+	/**
+	* adds an element to the WSDL types
+	*
+	* @param array $attrs attributes that must include name and type
+	* @see xmlschema
+	* @access public
+	*/
+	function addElement($attrs) {
+		$typens = isset($this-&gt;namespaces['types']) ? $this-&gt;namespaces['types'] : $this-&gt;namespaces['tns'];
+		$this-&gt;schemas[$typens][0]-&gt;addElement($attrs);
+	}
+
+	/**
+	* register an operation with the server
+	* 
+	* @param string $name operation (method) name
+	* @param array $in assoc array of input values: key = param name, value = param type
+	* @param array $out assoc array of output values: key = param name, value = param type
+	* @param string $namespace optional The namespace for the operation
+	* @param string $soapaction optional The soapaction for the operation
+	* @param string $style (rpc|document) optional The style for the operation Note: when 'document' is specified, parameter and return wrappers are created for you automatically
+	* @param string $use (encoded|literal) optional The use for the parameters (cannot mix right now)
+	* @param string $documentation optional The description to include in the WSDL
+	* @param string $encodingStyle optional (usually '<A HREF="http://schemas.xmlsoap.org/soap/encoding/">http://schemas.xmlsoap.org/soap/encoding/</A>' for encoded)
+	* @access public 
+	*/
+	function addOperation($name, $in = false, $out = false, $namespace = false, $soapaction = false, $style = 'rpc', $use = 'encoded', $documentation = '', $encodingStyle = ''){
+		if ($use == 'encoded' &amp;&amp; $encodingStyle == '') {
+			$encodingStyle = '<A HREF="http://schemas.xmlsoap.org/soap/encoding/">http://schemas.xmlsoap.org/soap/encoding/</A>';
+		}
+
+		if ($style == 'document') {
+			$elements = array();
+			foreach ($in as $n =&gt; $t) {
+				$elements[$n] = array('name' =&gt; $n, 'type' =&gt; $t);
+			}
+			$this-&gt;addComplexType($name . 'RequestType', 'complexType', 'struct', 'all', '', $elements);
+			$this-&gt;addElement(array('name' =&gt; $name, 'type' =&gt; $name . 'RequestType'));
+			$in = array('parameters' =&gt; 'tns:' . $name);
+
+			$elements = array();
+			foreach ($out as $n =&gt; $t) {
+				$elements[$n] = array('name' =&gt; $n, 'type' =&gt; $t);
+			}
+			$this-&gt;addComplexType($name . 'ResponseType', 'complexType', 'struct', 'all', '', $elements);
+			$this-&gt;addElement(array('name' =&gt; $name . 'Response', 'type' =&gt; $name . 'ResponseType'));
+			$out = array('parameters' =&gt; 'tns:' . $name . 'Response');
+		}
+
+		// get binding
+		$this-&gt;bindings[ $this-&gt;serviceName . 'Binding' ]['operations'][$name] =
+		array(
+		'name' =&gt; $name,
+		'binding' =&gt; $this-&gt;serviceName . 'Binding',
+		'endpoint' =&gt; $this-&gt;endpoint,
+		'soapAction' =&gt; $soapaction,
+		'style' =&gt; $style,
+		'input' =&gt; array(
+			'use' =&gt; $use,
+			'namespace' =&gt; $namespace,
+			'encodingStyle' =&gt; $encodingStyle,
+			'message' =&gt; $name . 'Request',
+			'parts' =&gt; $in),
+		'output' =&gt; array(
+			'use' =&gt; $use,
+			'namespace' =&gt; $namespace,
+			'encodingStyle' =&gt; $encodingStyle,
+			'message' =&gt; $name . 'Response',
+			'parts' =&gt; $out),
+		'namespace' =&gt; $namespace,
+		'transport' =&gt; '<A HREF="http://schemas.xmlsoap.org/soap/http">http://schemas.xmlsoap.org/soap/http</A>',
+		'documentation' =&gt; $documentation); 
+		// add portTypes
+		// add messages
+		if($in)
+		{
+			foreach($in as $pName =&gt; $pType)
+			{
+				if(strpos($pType,':')) {
+					$pType = $this-&gt;getNamespaceFromPrefix($this-&gt;getPrefix($pType)).&quot;:&quot;.$this-&gt;getLocalPart($pType);
+				}
+				$this-&gt;messages[$name.'Request'][$pName] = $pType;
+			}
+		} else {
+            $this-&gt;messages[$name.'Request']= '0';
+        }
+		if($out)
+		{
+			foreach($out as $pName =&gt; $pType)
+			{
+				if(strpos($pType,':')) {
+					$pType = $this-&gt;getNamespaceFromPrefix($this-&gt;getPrefix($pType)).&quot;:&quot;.$this-&gt;getLocalPart($pType);
+				}
+				$this-&gt;messages[$name.'Response'][$pName] = $pType;
+			}
+		} else {
+            $this-&gt;messages[$name.'Response']= '0';
+        }
+		return true;
+	} 
+}
+?&gt;&lt;?php
+
+
+
+/**
+*
+* soap_parser class parses SOAP XML messages into native PHP values
+*
+* @author   Dietrich Ayala &lt;<A HREF="https://lists.berlios.de/mailman/listinfo/viperals-svncheckins">dietrich at ganx4.com</A>&gt;
+* @version  $Id: nusoap.php,v 1.94 2005/08/04 01:27:42 snichol Exp $
+* @access   public
+*/
+class soap_parser extends nusoap_base {
+
+	var $xml = '';
+	var $xml_encoding = '';
+	var $method = '';
+	var $root_struct = '';
+	var $root_struct_name = '';
+	var $root_struct_namespace = '';
+	var $root_header = '';
+    var $document = '';			// incoming SOAP body (text)
+	// determines where in the message we are (envelope,header,body,method)
+	var $status = '';
+	var $position = 0;
+	var $depth = 0;
+	var $default_namespace = '';
+	var $namespaces = array();
+	var $message = array();
+    var $parent = '';
+	var $fault = false;
+	var $fault_code = '';
+	var $fault_str = '';
+	var $fault_detail = '';
+	var $depth_array = array();
+	var $debug_flag = true;
+	var $soapresponse = NULL;
+	var $responseHeaders = '';	// incoming SOAP headers (text)
+	var $body_position = 0;
+	// for multiref parsing:
+	// array of id =&gt; pos
+	var $ids = array();
+	// array of id =&gt; hrefs =&gt; pos
+	var $multirefs = array();
+	// toggle for auto-decoding element content
+	var $decode_utf8 = true;
+
+	/**
+	* constructor that actually does the parsing
+	*
+	* @param    string $xml SOAP message
+	* @param    string $encoding character encoding scheme of message
+	* @param    string $method method for which XML is parsed (unused?)
+	* @param    string $decode_utf8 whether to decode UTF-8 to ISO-8859-1
+	* @access   public
+	*/
+	function soap_parser($xml,$encoding='UTF-8',$method='',$decode_utf8=true){
+		parent::nusoap_base();
+		$this-&gt;xml = $xml;
+		$this-&gt;xml_encoding = $encoding;
+		$this-&gt;method = $method;
+		$this-&gt;decode_utf8 = $decode_utf8;
+
+		// Check whether content has been read.
+		if(!empty($xml)){
+			// Check XML encoding
+			$pos_xml = strpos($xml, '&lt;?xml');
+			if ($pos_xml !== FALSE) {
+				$xml_decl = substr($xml, $pos_xml, strpos($xml, '?&gt;', $pos_xml + 2) - $pos_xml + 1);
+				if (preg_match(&quot;/encoding=[\&quot;']([^\&quot;']*)[\&quot;']/&quot;, $xml_decl, $res)) {
+					$xml_encoding = $res[1];
+					if (strtoupper($xml_encoding) != $encoding) {
+						$err = &quot;Charset from HTTP Content-Type '&quot; . $encoding . &quot;' does not match encoding from XML declaration '&quot; . $xml_encoding . &quot;'&quot;;
+						$this-&gt;debug($err);
+						if ($encoding != 'ISO-8859-1' || strtoupper($xml_encoding) != 'UTF-8') {
+							$this-&gt;setError($err);
+							return;
+						}
+						// when HTTP says ISO-8859-1 (the default) and XML says UTF-8 (the typical), assume the other endpoint is just sloppy and proceed
+					} else {
+						$this-&gt;debug('Charset from HTTP Content-Type matches encoding from XML declaration');
+					}
+				} else {
+					$this-&gt;debug('No encoding specified in XML declaration');
+				}
+			} else {
+				$this-&gt;debug('No XML declaration');
+			}
+			$this-&gt;debug('Entering soap_parser(), length='.strlen($xml).', encoding='.$encoding);
+			// Create an XML parser - why not xml_parser_create_ns?
+			$this-&gt;parser = xml_parser_create($this-&gt;xml_encoding);
+			// Set the options for parsing the XML data.
+			//xml_parser_set_option($parser, XML_OPTION_SKIP_WHITE, 1);
+			xml_parser_set_option($this-&gt;parser, XML_OPTION_CASE_FOLDING, 0);
+			xml_parser_set_option($this-&gt;parser, XML_OPTION_TARGET_ENCODING, $this-&gt;xml_encoding);
+			// Set the object for the parser.
+			xml_set_object($this-&gt;parser, $this);
+			// Set the element handlers for the parser.
+			xml_set_element_handler($this-&gt;parser, 'start_element','end_element');
+			xml_set_character_data_handler($this-&gt;parser,'character_data');
+
+			// Parse the XML file.
+			if(!xml_parse($this-&gt;parser,$xml,true)){
+			    // Display an error message.
+			    $err = sprintf('XML error parsing SOAP payload on line %d: %s',
+			    xml_get_current_line_number($this-&gt;parser),
+			    xml_error_string(xml_get_error_code($this-&gt;parser)));
+				$this-&gt;debug($err);
+				$this-&gt;debug(&quot;XML payload:\n&quot; . $xml);
+				$this-&gt;setError($err);
+			} else {
+				$this-&gt;debug('parsed successfully, found root struct: '.$this-&gt;root_struct.' of name '.$this-&gt;root_struct_name);
+				// get final value
+				$this-&gt;soapresponse = $this-&gt;message[$this-&gt;root_struct]['result'];
+				// get header value: no, because this is documented as XML string
+//				if($this-&gt;root_header != '' &amp;&amp; isset($this-&gt;message[$this-&gt;root_header]['result'])){
+//					$this-&gt;responseHeaders = $this-&gt;message[$this-&gt;root_header]['result'];
+//				}
+				// resolve hrefs/ids
+				if(sizeof($this-&gt;multirefs) &gt; 0){
+					foreach($this-&gt;multirefs as $id =&gt; $hrefs){
+						$this-&gt;debug('resolving multirefs for id: '.$id);
+						$idVal = $this-&gt;buildVal($this-&gt;ids[$id]);
+						if (is_array($idVal) &amp;&amp; isset($idVal['!id'])) {
+							unset($idVal['!id']);
+						}
+						foreach($hrefs as $refPos =&gt; $ref){
+							$this-&gt;debug('resolving href at pos '.$refPos);
+							$this-&gt;multirefs[$id][$refPos] = $idVal;
+						}
+					}
+				}
+			}
+			xml_parser_free($this-&gt;parser);
+		} else {
+			$this-&gt;debug('xml was empty, didn\'t parse!');
+			$this-&gt;setError('xml was empty, didn\'t parse!');
+		}
+	}
+
+	/**
+	* start-element handler
+	*
+	* @param    resource $parser XML parser object
+	* @param    string $name element name
+	* @param    array $attrs associative array of attributes
+	* @access   private
+	*/
+	function start_element($parser, $name, $attrs) {
+		// position in a total number of elements, starting from 0
+		// update class level pos
+		$pos = $this-&gt;position++;
+		// and set mine
+		$this-&gt;message[$pos] = array('pos' =&gt; $pos,'children'=&gt;'','cdata'=&gt;'');
+		// depth = how many levels removed from root?
+		// set mine as current global depth and increment global depth value
+		$this-&gt;message[$pos]['depth'] = $this-&gt;depth++;
+
+		// else add self as child to whoever the current parent is
+		if($pos != 0){
+			$this-&gt;message[$this-&gt;parent]['children'] .= '|'.$pos;
+		}
+		// set my parent
+		$this-&gt;message[$pos]['parent'] = $this-&gt;parent;
+		// set self as current parent
+		$this-&gt;parent = $pos;
+		// set self as current value for this depth
+		$this-&gt;depth_array[$this-&gt;depth] = $pos;
+		// get element prefix
+		if(strpos($name,':')){
+			// get ns prefix
+			$prefix = substr($name,0,strpos($name,':'));
+			// get unqualified name
+			$name = substr(strstr($name,':'),1);
+		}
+		// set status
+		if($name == 'Envelope'){
+			$this-&gt;status = 'envelope';
+		} elseif($name == 'Header'){
+			$this-&gt;root_header = $pos;
+			$this-&gt;status = 'header';
+		} elseif($name == 'Body'){
+			$this-&gt;status = 'body';
+			$this-&gt;body_position = $pos;
+		// set method
+		} elseif($this-&gt;status == 'body' &amp;&amp; $pos == ($this-&gt;body_position+1)){
+			$this-&gt;status = 'method';
+			$this-&gt;root_struct_name = $name;
+			$this-&gt;root_struct = $pos;
+			$this-&gt;message[$pos]['type'] = 'struct';
+			$this-&gt;debug(&quot;found root struct $this-&gt;root_struct_name, pos $this-&gt;root_struct&quot;);
+		}
+		// set my status
+		$this-&gt;message[$pos]['status'] = $this-&gt;status;
+		// set name
+		$this-&gt;message[$pos]['name'] = htmlspecialchars($name);
+		// set attrs
+		$this-&gt;message[$pos]['attrs'] = $attrs;
+
+		// loop through atts, logging ns and type declarations
+        $attstr = '';
+		foreach($attrs as $key =&gt; $value){
+        	$key_prefix = $this-&gt;getPrefix($key);
+			$key_localpart = $this-&gt;getLocalPart($key);
+			// if ns declarations, add to class level array of valid namespaces
+            if($key_prefix == 'xmlns'){
+				if(ereg('^<A HREF="http://www.w3.org/[0-9">http://www.w3.org/[0-9</A>]{4}/XMLSchema$',$value)){
+					$this-&gt;XMLSchemaVersion = $value;
+					$this-&gt;namespaces['xsd'] = $this-&gt;XMLSchemaVersion;
+					$this-&gt;namespaces['xsi'] = $this-&gt;XMLSchemaVersion.'-instance';
+				}
+                $this-&gt;namespaces[$key_localpart] = $value;
+				// set method namespace
+				if($name == $this-&gt;root_struct_name){
+					$this-&gt;methodNamespace = $value;
+				}
+			// if it's a type declaration, set type
+            } elseif($key_localpart == 'type'){
+            	$value_prefix = $this-&gt;getPrefix($value);
+                $value_localpart = $this-&gt;getLocalPart($value);
+				$this-&gt;message[$pos]['type'] = $value_localpart;
+				$this-&gt;message[$pos]['typePrefix'] = $value_prefix;
+                if(isset($this-&gt;namespaces[$value_prefix])){
+                	$this-&gt;message[$pos]['type_namespace'] = $this-&gt;namespaces[$value_prefix];
+                } else if(isset($attrs['xmlns:'.$value_prefix])) {
+					$this-&gt;message[$pos]['type_namespace'] = $attrs['xmlns:'.$value_prefix];
+                }
+				// should do something here with the namespace of specified type?
+			} elseif($key_localpart == 'arrayType'){
+				$this-&gt;message[$pos]['type'] = 'array';
+				/* do arrayType ereg here
+				[1]    arrayTypeValue    ::=    atype asize
+				[2]    atype    ::=    QName rank*
+				[3]    rank    ::=    '[' (',')* ']'
+				[4]    asize    ::=    '[' length~ ']'
+				[5]    length    ::=    nextDimension* Digit+
+				[6]    nextDimension    ::=    Digit+ ','
+				*/
+				$expr = '([A-Za-z0-9_]+):([A-Za-z]+[A-Za-z0-9_]+)\[([0-9]+),?([0-9]*)\]';
+				if(ereg($expr,$value,$regs)){
+					$this-&gt;message[$pos]['typePrefix'] = $regs[1];
+					$this-&gt;message[$pos]['arrayTypePrefix'] = $regs[1];
+	                if (isset($this-&gt;namespaces[$regs[1]])) {
+	                	$this-&gt;message[$pos]['arrayTypeNamespace'] = $this-&gt;namespaces[$regs[1]];
+	                } else if (isset($attrs['xmlns:'.$regs[1]])) {
+						$this-&gt;message[$pos]['arrayTypeNamespace'] = $attrs['xmlns:'.$regs[1]];
+	                }
+					$this-&gt;message[$pos]['arrayType'] = $regs[2];
+					$this-&gt;message[$pos]['arraySize'] = $regs[3];
+					$this-&gt;message[$pos]['arrayCols'] = $regs[4];
+				}
+			// specifies nil value (or not)
+			} elseif ($key_localpart == 'nil'){
+				$this-&gt;message[$pos]['nil'] = ($value == 'true' || $value == '1');
+			// some other attribute
+			} elseif ($key != 'href' &amp;&amp; $key != 'xmlns' &amp;&amp; $key_localpart != 'encodingStyle' &amp;&amp; $key_localpart != 'root') {
+				$this-&gt;message[$pos]['xattrs']['!' . $key] = $value;
+			}
+
+			if ($key == 'xmlns') {
+				$this-&gt;default_namespace = $value;
+			}
+			// log id
+			if($key == 'id'){
+				$this-&gt;ids[$value] = $pos;
+			}
+			// root
+			if($key_localpart == 'root' &amp;&amp; $value == 1){
+				$this-&gt;status = 'method';
+				$this-&gt;root_struct_name = $name;
+				$this-&gt;root_struct = $pos;
+				$this-&gt;debug(&quot;found root struct $this-&gt;root_struct_name, pos $pos&quot;);
+			}
+            // for doclit
+            $attstr .= &quot; $key=\&quot;$value\&quot;&quot;;
+		}
+        // get namespace - must be done after namespace atts are processed
+		if(isset($prefix)){
+			$this-&gt;message[$pos]['namespace'] = $this-&gt;namespaces[$prefix];
+			$this-&gt;default_namespace = $this-&gt;namespaces[$prefix];
+		} else {
+			$this-&gt;message[$pos]['namespace'] = $this-&gt;default_namespace;
+		}
+        if($this-&gt;status == 'header'){
+        	if ($this-&gt;root_header != $pos) {
+	        	$this-&gt;responseHeaders .= &quot;&lt;&quot; . (isset($prefix) ? $prefix . ':' : '') . &quot;$name$attstr&gt;&quot;;
+	        }
+        } elseif($this-&gt;root_struct_name != ''){
+        	$this-&gt;document .= &quot;&lt;&quot; . (isset($prefix) ? $prefix . ':' : '') . &quot;$name$attstr&gt;&quot;;
+        }
+	}
+
+	/**
+	* end-element handler
+	*
+	* @param    resource $parser XML parser object
+	* @param    string $name element name
+	* @access   private
+	*/
+	function end_element($parser, $name) {
+		// position of current element is equal to the last value left in depth_array for my depth
+		$pos = $this-&gt;depth_array[$this-&gt;depth--];
+
+        // get element prefix
+		if(strpos($name,':')){
+			// get ns prefix
+			$prefix = substr($name,0,strpos($name,':'));
+			// get unqualified name
+			$name = substr(strstr($name,':'),1);
+		}
+		
+		// build to native type
+		if(isset($this-&gt;body_position) &amp;&amp; $pos &gt; $this-&gt;body_position){
+			// deal w/ multirefs
+			if(isset($this-&gt;message[$pos]['attrs']['href'])){
+				// get id
+				$id = substr($this-&gt;message[$pos]['attrs']['href'],1);
+				// add placeholder to href array
+				$this-&gt;multirefs[$id][$pos] = 'placeholder';
+				// add set a reference to it as the result value
+				$this-&gt;message[$pos]['result'] =&amp; $this-&gt;multirefs[$id][$pos];
+            // build complexType values
+			} elseif($this-&gt;message[$pos]['children'] != ''){
+				// if result has already been generated (struct/array)
+				if(!isset($this-&gt;message[$pos]['result'])){
+					$this-&gt;message[$pos]['result'] = $this-&gt;buildVal($pos);
+				}
+			// build complexType values of attributes and possibly simpleContent
+			} elseif (isset($this-&gt;message[$pos]['xattrs'])) {
+				if (isset($this-&gt;message[$pos]['nil']) &amp;&amp; $this-&gt;message[$pos]['nil']) {
+					$this-&gt;message[$pos]['xattrs']['!'] = null;
+				} elseif (isset($this-&gt;message[$pos]['cdata']) &amp;&amp; trim($this-&gt;message[$pos]['cdata']) != '') {
+	            	if (isset($this-&gt;message[$pos]['type'])) {
+						$this-&gt;message[$pos]['xattrs']['!'] = $this-&gt;decodeSimple($this-&gt;message[$pos]['cdata'], $this-&gt;message[$pos]['type'], isset($this-&gt;message[$pos]['type_namespace']) ? $this-&gt;message[$pos]['type_namespace'] : '');
+					} else {
+						$parent = $this-&gt;message[$pos]['parent'];
+						if (isset($this-&gt;message[$parent]['type']) &amp;&amp; ($this-&gt;message[$parent]['type'] == 'array') &amp;&amp; isset($this-&gt;message[$parent]['arrayType'])) {
+							$this-&gt;message[$pos]['xattrs']['!'] = $this-&gt;decodeSimple($this-&gt;message[$pos]['cdata'], $this-&gt;message[$parent]['arrayType'], isset($this-&gt;message[$parent]['arrayTypeNamespace']) ? $this-&gt;message[$parent]['arrayTypeNamespace'] : '');
+						} else {
+							$this-&gt;message[$pos]['xattrs']['!'] = $this-&gt;message[$pos]['cdata'];
+						}
+					}
+				}
+				$this-&gt;message[$pos]['result'] = $this-&gt;message[$pos]['xattrs'];
+			// set value of simpleType (or nil complexType)
+			} else {
+            	//$this-&gt;debug('adding data for scalar value '.$this-&gt;message[$pos]['name'].' of value '.$this-&gt;message[$pos]['cdata']);
+				if (isset($this-&gt;message[$pos]['nil']) &amp;&amp; $this-&gt;message[$pos]['nil']) {
+					$this-&gt;message[$pos]['xattrs']['!'] = null;
+				} elseif (isset($this-&gt;message[$pos]['type'])) {
+					$this-&gt;message[$pos]['result'] = $this-&gt;decodeSimple($this-&gt;message[$pos]['cdata'], $this-&gt;message[$pos]['type'], isset($this-&gt;message[$pos]['type_namespace']) ? $this-&gt;message[$pos]['type_namespace'] : '');
+				} else {
+					$parent = $this-&gt;message[$pos]['parent'];
+					if (isset($this-&gt;message[$parent]['type']) &amp;&amp; ($this-&gt;message[$parent]['type'] == 'array') &amp;&amp; isset($this-&gt;message[$parent]['arrayType'])) {
+						$this-&gt;message[$pos]['result'] = $this-&gt;decodeSimple($this-&gt;message[$pos]['cdata'], $this-&gt;message[$parent]['arrayType'], isset($this-&gt;message[$parent]['arrayTypeNamespace']) ? $this-&gt;message[$parent]['arrayTypeNamespace'] : '');
+					} else {
+						$this-&gt;message[$pos]['result'] = $this-&gt;message[$pos]['cdata'];
+					}
+				}
+
+				/* add value to parent's result, if parent is struct/array
+				$parent = $this-&gt;message[$pos]['parent'];
+				if($this-&gt;message[$parent]['type'] != 'map'){
+					if(strtolower($this-&gt;message[$parent]['type']) == 'array'){
+						$this-&gt;message[$parent]['result'][] = $this-&gt;message[$pos]['result'];
+					} else {
+						$this-&gt;message[$parent]['result'][$this-&gt;message[$pos]['name']] = $this-&gt;message[$pos]['result'];
+					}
+				}
+				*/
+			}
+		}
+		
+        // for doclit
+        if($this-&gt;status == 'header'){
+        	if ($this-&gt;root_header != $pos) {
+	        	$this-&gt;responseHeaders .= &quot;&lt;/&quot; . (isset($prefix) ? $prefix . ':' : '') . &quot;$name&gt;&quot;;
+	        }
+        } elseif($pos &gt;= $this-&gt;root_struct){
+        	$this-&gt;document .= &quot;&lt;/&quot; . (isset($prefix) ? $prefix . ':' : '') . &quot;$name&gt;&quot;;
+        }
+		// switch status
+		if($pos == $this-&gt;root_struct){
+			$this-&gt;status = 'body';
+			$this-&gt;root_struct_namespace = $this-&gt;message[$pos]['namespace'];
+		} elseif($name == 'Body'){
+			$this-&gt;status = 'envelope';
+		 } elseif($name == 'Header'){
+			$this-&gt;status = 'envelope';
+		} elseif($name == 'Envelope'){
+			//
+		}
+		// set parent back to my parent
+		$this-&gt;parent = $this-&gt;message[$pos]['parent'];
+	}
+
+	/**
+	* element content handler
+	*
+	* @param    resource $parser XML parser object
+	* @param    string $data element content
+	* @access   private
+	*/
+	function character_data($parser, $data){
+		$pos = $this-&gt;depth_array[$this-&gt;depth];
+		if ($this-&gt;xml_encoding=='UTF-8'){
+			// TODO: add an option to disable this for folks who want
+			// raw UTF-8 that, e.g., might not map to iso-8859-1
+			// TODO: this can also be handled with xml_parser_set_option($this-&gt;parser, XML_OPTION_TARGET_ENCODING, &quot;ISO-8859-1&quot;);
+			if($this-&gt;decode_utf8){
+				$data = utf8_decode($data);
+			}
+		}
+        $this-&gt;message[$pos]['cdata'] .= $data;
+        // for doclit
+        if($this-&gt;status == 'header'){
+        	$this-&gt;responseHeaders .= $data;
+        } else {
+        	$this-&gt;document .= $data;
+        }
+	}
+
+	/**
+	* get the parsed message
+	*
+	* @return	mixed
+	* @access   public
+	*/
+	function get_response(){
+		return $this-&gt;soapresponse;
+	}
+
+	/**
+	* get the parsed headers
+	*
+	* @return	string XML or empty if no headers
+	* @access   public
+	*/
+	function getHeaders(){
+	    return $this-&gt;responseHeaders;
+	}
+
+	/**
+	* decodes simple types into PHP variables
+	*
+	* @param    string $value value to decode
+	* @param    string $type XML type to decode
+	* @param    string $typens XML type namespace to decode
+	* @return	mixed PHP value
+	* @access   private
+	*/
+	function decodeSimple($value, $type, $typens) {
+		// TODO: use the namespace!
+		if ((!isset($type)) || $type == 'string' || $type == 'long' || $type == 'unsignedLong') {
+			return (string) $value;
+		}
+		if ($type == 'int' || $type == 'integer' || $type == 'short' || $type == 'byte') {
+			return (int) $value;
+		}
+		if ($type == 'float' || $type == 'double' || $type == 'decimal') {
+			return (double) $value;
+		}
+		if ($type == 'boolean') {
+			if (strtolower($value) == 'false' || strtolower($value) == 'f') {
+				return false;
+			}
+			return (boolean) $value;
+		}
+		if ($type == 'base64' || $type == 'base64Binary') {
+			$this-&gt;debug('Decode base64 value');
+			return base64_decode($value);
+		}
+		// obscure numeric types
+		if ($type == 'nonPositiveInteger' || $type == 'negativeInteger'
+			|| $type == 'nonNegativeInteger' || $type == 'positiveInteger'
+			|| $type == 'unsignedInt'
+			|| $type == 'unsignedShort' || $type == 'unsignedByte') {
+			return (int) $value;
+		}
+		// bogus: parser treats array with no elements as a simple type
+		if ($type == 'array') {
+			return array();
+		}
+		// everything else
+		return (string) $value;
+	}
+
+	/**
+	* builds response structures for compound values (arrays/structs)
+	* and scalars
+	*
+	* @param    integer $pos position in node tree
+	* @return	mixed	PHP value
+	* @access   private
+	*/
+	function buildVal($pos){
+		if(!isset($this-&gt;message[$pos]['type'])){
+			$this-&gt;message[$pos]['type'] = '';
+		}
+		$this-&gt;debug('in buildVal() for '.$this-&gt;message[$pos]['name'].&quot;(pos $pos) of type &quot;.$this-&gt;message[$pos]['type']);
+		// if there are children...
+		if($this-&gt;message[$pos]['children'] != ''){
+			$this-&gt;debug('in buildVal, there are children');
+			$children = explode('|',$this-&gt;message[$pos]['children']);
+			array_shift($children); // knock off empty
+			// md array
+			if(isset($this-&gt;message[$pos]['arrayCols']) &amp;&amp; $this-&gt;message[$pos]['arrayCols'] != ''){
+            	$r=0; // rowcount
+            	$c=0; // colcount
+            	foreach($children as $child_pos){
+					$this-&gt;debug(&quot;in buildVal, got an MD array element: $r, $c&quot;);
+					$params[$r][] = $this-&gt;message[$child_pos]['result'];
+				    $c++;
+				    if($c == $this-&gt;message[$pos]['arrayCols']){
+				    	$c = 0;
+						$r++;
+				    }
+                }
+            // array
+			} elseif($this-&gt;message[$pos]['type'] == 'array' || $this-&gt;message[$pos]['type'] == 'Array'){
+                $this-&gt;debug('in buildVal, adding array '.$this-&gt;message[$pos]['name']);
+                foreach($children as $child_pos){
+                	$params[] = &amp;$this-&gt;message[$child_pos]['result'];
+                }
+            // apache Map type: java hashtable
+            } elseif($this-&gt;message[$pos]['type'] == 'Map' &amp;&amp; $this-&gt;message[$pos]['type_namespace'] == '<A HREF="http://xml.apache.org/xml-soap">http://xml.apache.org/xml-soap</A>'){
+                $this-&gt;debug('in buildVal, Java Map '.$this-&gt;message[$pos]['name']);
+                foreach($children as $child_pos){
+                	$kv = explode(&quot;|&quot;,$this-&gt;message[$child_pos]['children']);
+                   	$params[$this-&gt;message[$kv[1]]['result']] = &amp;$this-&gt;message[$kv[2]]['result'];
+                }
+            // generic compound type
+            //} elseif($this-&gt;message[$pos]['type'] == 'SOAPStruct' || $this-&gt;message[$pos]['type'] == 'struct') {
+		    } else {
+	    		// Apache Vector type: treat as an array
+                $this-&gt;debug('in buildVal, adding Java Vector '.$this-&gt;message[$pos]['name']);
+				if ($this-&gt;message[$pos]['type'] == 'Vector' &amp;&amp; $this-&gt;message[$pos]['type_namespace'] == '<A HREF="http://xml.apache.org/xml-soap">http://xml.apache.org/xml-soap</A>') {
+					$notstruct = 1;
+				} else {
+					$notstruct = 0;
+	            }
+            	//
+            	foreach($children as $child_pos){
+            		if($notstruct){
+            			$params[] = &amp;$this-&gt;message[$child_pos]['result'];
+            		} else {
+            			if (isset($params[$this-&gt;message[$child_pos]['name']])) {
+            				// de-serialize repeated element name into an array
+            				if ((!is_array($params[$this-&gt;message[$child_pos]['name']])) || (!isset($params[$this-&gt;message[$child_pos]['name']][0]))) {
+            					$params[$this-&gt;message[$child_pos]['name']] = array($params[$this-&gt;message[$child_pos]['name']]);
+            				}
+            				$params[$this-&gt;message[$child_pos]['name']][] = &amp;$this-&gt;message[$child_pos]['result'];
+            			} else {
+					    	$params[$this-&gt;message[$child_pos]['name']] = &amp;$this-&gt;message[$child_pos]['result'];
+					    }
+                	}
+                }
+			}
+			if (isset($this-&gt;message[$pos]['xattrs'])) {
+                $this-&gt;debug('in buildVal, handling attributes');
+				foreach ($this-&gt;message[$pos]['xattrs'] as $n =&gt; $v) {
+					$params[$n] = $v;
+				}
+			}
+			// handle simpleContent
+			if (isset($this-&gt;message[$pos]['cdata']) &amp;&amp; trim($this-&gt;message[$pos]['cdata']) != '') {
+                $this-&gt;debug('in buildVal, handling simpleContent');
+            	if (isset($this-&gt;message[$pos]['type'])) {
+					$params['!'] = $this-&gt;decodeSimple($this-&gt;message[$pos]['cdata'], $this-&gt;message[$pos]['type'], isset($this-&gt;message[$pos]['type_namespace']) ? $this-&gt;message[$pos]['type_namespace'] : '');
+				} else {
+					$parent = $this-&gt;message[$pos]['parent'];
+					if (isset($this-&gt;message[$parent]['type']) &amp;&amp; ($this-&gt;message[$parent]['type'] == 'array') &amp;&amp; isset($this-&gt;message[$parent]['arrayType'])) {
+						$params['!'] = $this-&gt;decodeSimple($this-&gt;message[$pos]['cdata'], $this-&gt;message[$parent]['arrayType'], isset($this-&gt;message[$parent]['arrayTypeNamespace']) ? $this-&gt;message[$parent]['arrayTypeNamespace'] : '');
+					} else {
+						$params['!'] = $this-&gt;message[$pos]['cdata'];
+					}
+				}
+			}
+			return is_array($params) ? $params : array();
+		} else {
+        	$this-&gt;debug('in buildVal, no children, building scalar');
+			$cdata = isset($this-&gt;message[$pos]['cdata']) ? $this-&gt;message[$pos]['cdata'] : '';
+        	if (isset($this-&gt;message[$pos]['type'])) {
+				return $this-&gt;decodeSimple($cdata, $this-&gt;message[$pos]['type'], isset($this-&gt;message[$pos]['type_namespace']) ? $this-&gt;message[$pos]['type_namespace'] : '');
+			}
+			$parent = $this-&gt;message[$pos]['parent'];
+			if (isset($this-&gt;message[$parent]['type']) &amp;&amp; ($this-&gt;message[$parent]['type'] == 'array') &amp;&amp; isset($this-&gt;message[$parent]['arrayType'])) {
+				return $this-&gt;decodeSimple($cdata, $this-&gt;message[$parent]['arrayType'], isset($this-&gt;message[$parent]['arrayTypeNamespace']) ? $this-&gt;message[$parent]['arrayTypeNamespace'] : '');
+			}
+           	return $this-&gt;message[$pos]['cdata'];
+		}
+	}
+}
+
+
+
+?&gt;&lt;?php
+
+
+
+/**
+*
+* soapclient higher level class for easy usage.
+*
+* usage:
+*
+* // instantiate client with server info
+* $soapclient = new soapclient( string path [ ,boolean wsdl] );
+*
+* // call method, get results
+* echo $soapclient-&gt;call( string methodname [ ,array parameters] );
+*
+* // bye bye client
+* unset($soapclient);
+*
+* @author   Dietrich Ayala &lt;<A HREF="https://lists.berlios.de/mailman/listinfo/viperals-svncheckins">dietrich at ganx4.com</A>&gt;
+* @version  $Id: nusoap.php,v 1.94 2005/08/04 01:27:42 snichol Exp $
+* @access   public
+*/
+class soapclient extends nusoap_base  {
+
+	var $username = '';
+	var $password = '';
+	var $authtype = '';
+	var $certRequest = array();
+	var $requestHeaders = false;	// SOAP headers in request (text)
+	var $responseHeaders = '';		// SOAP headers from response (incomplete namespace resolution) (text)
+	var $document = '';				// SOAP body response portion (incomplete namespace resolution) (text)
+	var $endpoint;
+	var $forceEndpoint = '';		// overrides WSDL endpoint
+    var $proxyhost = '';
+    var $proxyport = '';
+	var $proxyusername = '';
+	var $proxypassword = '';
+    var $xml_encoding = '';			// character set encoding of incoming (response) messages
+	var $http_encoding = false;
+	var $timeout = 0;				// HTTP connection timeout
+	var $response_timeout = 30;		// HTTP response timeout
+	var $endpointType = '';			// soap|wsdl, empty for WSDL initialization error
+	var $persistentConnection = false;
+	var $defaultRpcParams = false;	// This is no longer used
+	var $request = '';				// HTTP request
+	var $response = '';				// HTTP response
+	var $responseData = '';			// SOAP payload of response
+	var $cookies = array();			// Cookies from response or for request
+    var $decode_utf8 = true;		// toggles whether the parser decodes element content w/ utf8_decode()
+	var $operations = array();		// WSDL operations, empty for WSDL initialization error
+	
+	/*
+	 * fault related variables
+	 */
+	/**
+	 * @var      fault
+	 * @access   public
+	 */
+	var $fault;
+	/**
+	 * @var      faultcode
+	 * @access   public
+	 */
+	var $faultcode;
+	/**
+	 * @var      faultstring
+	 * @access   public
+	 */
+	var $faultstring;
+	/**
+	 * @var      faultdetail
+	 * @access   public
+	 */
+	var $faultdetail;
+
+	/**
+	* constructor
+	*
+	* @param    mixed $endpoint SOAP server or WSDL URL (string), or wsdl instance (object)
+	* @param    bool $wsdl optional, set to true if using WSDL
+	* @param	int $portName optional portName in WSDL document
+	* @param    string $proxyhost
+	* @param    string $proxyport
+	* @param	string $proxyusername
+	* @param	string $proxypassword
+	* @param	integer $timeout set the connection timeout
+	* @param	integer $response_timeout set the response timeout
+	* @access   public
+	*/
+	function soapclient($endpoint,$wsdl = false,$proxyhost = false,$proxyport = false,$proxyusername = false, $proxypassword = false, $timeout = 0, $response_timeout = 30){
+		parent::nusoap_base();
+		$this-&gt;endpoint = $endpoint;
+		$this-&gt;proxyhost = $proxyhost;
+		$this-&gt;proxyport = $proxyport;
+		$this-&gt;proxyusername = $proxyusername;
+		$this-&gt;proxypassword = $proxypassword;
+		$this-&gt;timeout = $timeout;
+		$this-&gt;response_timeout = $response_timeout;
+
+		// make values
+		if($wsdl){
+			if (is_object($endpoint) &amp;&amp; (get_class($endpoint) == 'wsdl')) {
+				$this-&gt;wsdl = $endpoint;
+				$this-&gt;endpoint = $this-&gt;wsdl-&gt;wsdl;
+				$this-&gt;wsdlFile = $this-&gt;endpoint;
+				$this-&gt;debug('existing wsdl instance created from ' . $this-&gt;endpoint);
+			} else {
+				$this-&gt;wsdlFile = $this-&gt;endpoint;
+				
+				// instantiate wsdl object and parse wsdl file
+				$this-&gt;debug('instantiating wsdl class with doc: '.$endpoint);
+				$this-&gt;wsdl =&amp; new wsdl($this-&gt;wsdlFile,$this-&gt;proxyhost,$this-&gt;proxyport,$this-&gt;proxyusername,$this-&gt;proxypassword,$this-&gt;timeout,$this-&gt;response_timeout);
+			}
+			$this-&gt;appendDebug($this-&gt;wsdl-&gt;getDebug());
+			$this-&gt;wsdl-&gt;clearDebug();
+			// catch errors
+			if($errstr = $this-&gt;wsdl-&gt;getError()){
+				$this-&gt;debug('got wsdl error: '.$errstr);
+				$this-&gt;setError('wsdl error: '.$errstr);
+			} elseif($this-&gt;operations = $this-&gt;wsdl-&gt;getOperations()){
+				$this-&gt;debug( 'got '.count($this-&gt;operations).' operations from wsdl '.$this-&gt;wsdlFile);
+				$this-&gt;endpointType = 'wsdl';
+			} else {
+				$this-&gt;debug( 'getOperations returned false');
+				$this-&gt;setError('no operations defined in the WSDL document!');
+			}
+		} else {
+			$this-&gt;debug(&quot;instantiate SOAP with endpoint at $endpoint&quot;);
+			$this-&gt;endpointType = 'soap';
+		}
+	}
+
+	/**
+	* calls method, returns PHP native type
+	*
+	* @param    string $method SOAP server URL or path
+	* @param    mixed $params An array, associative or simple, of the parameters
+	*			              for the method call, or a string that is the XML
+	*			              for the call.  For rpc style, this call will
+	*			              wrap the XML in a tag named after the method, as
+	*			              well as the SOAP Envelope and Body.  For document
+	*			              style, this will only wrap with the Envelope and Body.
+	*			              IMPORTANT: when using an array with document style,
+	*			              in which case there
+	*                         is really one parameter, the root of the fragment
+	*                         used in the call, which encloses what programmers
+	*                         normally think of parameters.  A parameter array
+	*                         *must* include the wrapper.
+	* @param	string $namespace optional method namespace (WSDL can override)
+	* @param	string $soapAction optional SOAPAction value (WSDL can override)
+	* @param	mixed $headers optional string of XML with SOAP header content, or array of soapval objects for SOAP headers
+	* @param	boolean $rpcParams optional (no longer used)
+	* @param	string	$style optional (rpc|document) the style to use when serializing parameters (WSDL can override)
+	* @param	string	$use optional (encoded|literal) the use when serializing parameters (WSDL can override)
+	* @return	mixed	response from SOAP call
+	* @access   public
+	*/
+	function call($operation,$params=array(),$namespace='<A HREF="http://tempuri.org">http://tempuri.org</A>',$soapAction='',$headers=false,$rpcParams=null,$style='rpc',$use='encoded'){
+		$this-&gt;operation = $operation;
+		$this-&gt;fault = false;
+		$this-&gt;setError('');
+		$this-&gt;request = '';
+		$this-&gt;response = '';
+		$this-&gt;responseData = '';
+		$this-&gt;faultstring = '';
+		$this-&gt;faultcode = '';
+		$this-&gt;opData = array();
+		
+		$this-&gt;debug(&quot;call: operation=$operation, namespace=$namespace, soapAction=$soapAction, rpcParams=$rpcParams, style=$style, use=$use, endpointType=$this-&gt;endpointType&quot;);
+		$this-&gt;appendDebug('params=' . $this-&gt;varDump($params));
+		$this-&gt;appendDebug('headers=' . $this-&gt;varDump($headers));
+		if ($headers) {
+			$this-&gt;requestHeaders = $headers;
+		}
+		// serialize parameters
+		if($this-&gt;endpointType == 'wsdl' &amp;&amp; $opData = $this-&gt;getOperationData($operation)){
+			// use WSDL for operation
+			$this-&gt;opData = $opData;
+			$this-&gt;debug(&quot;found operation&quot;);
+			$this-&gt;appendDebug('opData=' . $this-&gt;varDump($opData));
+			if (isset($opData['soapAction'])) {
+				$soapAction = $opData['soapAction'];
+			}
+			if (! $this-&gt;forceEndpoint) {
+				$this-&gt;endpoint = $opData['endpoint'];
+			} else {
+				$this-&gt;endpoint = $this-&gt;forceEndpoint;
+			}
+			$namespace = isset($opData['input']['namespace']) ? $opData['input']['namespace'] :	$namespace;
+			$style = $opData['style'];
+			$use = $opData['input']['use'];
+			// add ns to ns array
+			if($namespace != '' &amp;&amp; !isset($this-&gt;wsdl-&gt;namespaces[$namespace])){
+				$nsPrefix = 'ns' . rand(1000, 9999);
+				$this-&gt;wsdl-&gt;namespaces[$nsPrefix] = $namespace;
+			}
+            $nsPrefix = $this-&gt;wsdl-&gt;getPrefixFromNamespace($namespace);
+			// serialize payload
+			if (is_string($params)) {
+				$this-&gt;debug(&quot;serializing param string for WSDL operation $operation&quot;);
+				$payload = $params;
+			} elseif (is_array($params)) {
+				$this-&gt;debug(&quot;serializing param array for WSDL operation $operation&quot;);
+				$payload = $this-&gt;wsdl-&gt;serializeRPCParameters($operation,'input',$params);
+			} else {
+				$this-&gt;debug('params must be array or string');
+				$this-&gt;setError('params must be array or string');
+				return false;
+			}
+            $usedNamespaces = $this-&gt;wsdl-&gt;usedNamespaces;
+			if (isset($opData['input']['encodingStyle'])) {
+				$encodingStyle = $opData['input']['encodingStyle'];
+			} else {
+				$encodingStyle = '';
+			}
+			$this-&gt;appendDebug($this-&gt;wsdl-&gt;getDebug());
+			$this-&gt;wsdl-&gt;clearDebug();
+			if ($errstr = $this-&gt;wsdl-&gt;getError()) {
+				$this-&gt;debug('got wsdl error: '.$errstr);
+				$this-&gt;setError('wsdl error: '.$errstr);
+				return false;
+			}
+		} elseif($this-&gt;endpointType == 'wsdl') {
+			// operation not in WSDL
+			$this-&gt;appendDebug($this-&gt;wsdl-&gt;getDebug());
+			$this-&gt;wsdl-&gt;clearDebug();
+			$this-&gt;setError( 'operation '.$operation.' not present.');
+			$this-&gt;debug(&quot;operation '$operation' not present.&quot;);
+			return false;
+		} else {
+			// no WSDL
+			//$this-&gt;namespaces['ns1'] = $namespace;
+			$nsPrefix = 'ns' . rand(1000, 9999);
+			// serialize 
+			$payload = '';
+			if (is_string($params)) {
+				$this-&gt;debug(&quot;serializing param string for operation $operation&quot;);
+				$payload = $params;
+			} elseif (is_array($params)) {
+				$this-&gt;debug(&quot;serializing param array for operation $operation&quot;);
+				foreach($params as $k =&gt; $v){
+					$payload .= $this-&gt;serialize_val($v,$k,false,false,false,false,$use);
+				}
+			} else {
+				$this-&gt;debug('params must be array or string');
+				$this-&gt;setError('params must be array or string');
+				return false;
+			}
+			$usedNamespaces = array();
+			if ($use == 'encoded') {
+				$encodingStyle = '<A HREF="http://schemas.xmlsoap.org/soap/encoding/">http://schemas.xmlsoap.org/soap/encoding/</A>';
+			} else {
+				$encodingStyle = '';
+			}
+		}
+		// wrap RPC calls with method element
+		if ($style == 'rpc') {
+			if ($use == 'literal') {
+				$this-&gt;debug(&quot;wrapping RPC request with literal method element&quot;);
+				if ($namespace) {
+					$payload = &quot;&lt;$operation xmlns=\&quot;$namespace\&quot;&gt;&quot; . $payload . &quot;&lt;/$operation&gt;&quot;;
+				} else {
+					$payload = &quot;&lt;$operation&gt;&quot; . $payload . &quot;&lt;/$operation&gt;&quot;;
+				}
+			} else {
+				$this-&gt;debug(&quot;wrapping RPC request with encoded method element&quot;);
+				if ($namespace) {
+					$payload = &quot;&lt;$nsPrefix:$operation xmlns:$nsPrefix=\&quot;$namespace\&quot;&gt;&quot; .
+								$payload .
+								&quot;&lt;/$nsPrefix:$operation&gt;&quot;;
+				} else {
+					$payload = &quot;&lt;$operation&gt;&quot; .
+								$payload .
+								&quot;&lt;/$operation&gt;&quot;;
+				}
+			}
+		}
+		// serialize envelope
+		$soapmsg = $this-&gt;serializeEnvelope($payload,$this-&gt;requestHeaders,$usedNamespaces,$style,$use,$encodingStyle);
+		$this-&gt;debug(&quot;endpoint=$this-&gt;endpoint, soapAction=$soapAction, namespace=$namespace, style=$style, use=$use, encodingStyle=$encodingStyle&quot;);
+		$this-&gt;debug('SOAP message length=' . strlen($soapmsg) . ' contents (max 1000 bytes)=' . substr($soapmsg, 0, 1000));
+		// send
+		$return = $this-&gt;send($this-&gt;getHTTPBody($soapmsg),$soapAction,$this-&gt;timeout,$this-&gt;response_timeout);
+		if($errstr = $this-&gt;getError()){
+			$this-&gt;debug('Error: '.$errstr);
+			return false;
+		} else {
+			$this-&gt;return = $return;
+			$this-&gt;debug('sent message successfully and got a(n) '.gettype($return));
+           	$this-&gt;appendDebug('return=' . $this-&gt;varDump($return));
+			
+			// fault?
+			if(is_array($return) &amp;&amp; isset($return['faultcode'])){
+				$this-&gt;debug('got fault');
+				$this-&gt;setError($return['faultcode'].': '.$return['faultstring']);
+				$this-&gt;fault = true;
+				foreach($return as $k =&gt; $v){
+					$this-&gt;$k = $v;
+					$this-&gt;debug(&quot;$k = $v&lt;br&gt;&quot;);
+				}
+				return $return;
+			} elseif ($style == 'document') {
+				// NOTE: if the response is defined to have multiple parts (i.e. unwrapped),
+				// we are only going to return the first part here...sorry about that
+				return $return;
+			} else {
+				// array of return values
+				if(is_array($return)){
+					// multiple 'out' parameters, which we return wrapped up
+					// in the array
+					if(sizeof($return) &gt; 1){
+						return $return;
+					}
+					// single 'out' parameter (normally the return value)
+					$return = array_shift($return);
+					$this-&gt;debug('return shifted value: ');
+					$this-&gt;appendDebug($this-&gt;varDump($return));
+           			return $return;
+				// nothing returned (ie, echoVoid)
+				} else {
+					return &quot;&quot;;
+				}
+			}
+		}
+	}
+
+	/**
+	* get available data pertaining to an operation
+	*
+	* @param    string $operation operation name
+	* @return	array array of data pertaining to the operation
+	* @access   public
+	*/
+	function getOperationData($operation){
+		if(isset($this-&gt;operations[$operation])){
+			return $this-&gt;operations[$operation];
+		}
+		$this-&gt;debug(&quot;No data for operation: $operation&quot;);
+	}
+
+    /**
+    * send the SOAP message
+    *
+    * Note: if the operation has multiple return values
+    * the return value of this method will be an array
+    * of those values.
+    *
+	* @param    string $msg a SOAPx4 soapmsg object
+	* @param    string $soapaction SOAPAction value
+	* @param    integer $timeout set connection timeout in seconds
+	* @param	integer $response_timeout set response timeout in seconds
+	* @return	mixed native PHP types.
+	* @access   private
+	*/
+	function send($msg, $soapaction = '', $timeout=0, $response_timeout=30) {
+		$this-&gt;checkCookies();
+		// detect transport
+		switch(true){
+			// http(s)
+			case ereg('^http',$this-&gt;endpoint):
+				$this-&gt;debug('transporting via HTTP');
+				if($this-&gt;persistentConnection == true &amp;&amp; is_object($this-&gt;persistentConnection)){
+					$http =&amp; $this-&gt;persistentConnection;
+				} else {
+					$http = new soap_transport_http($this-&gt;endpoint);
+					if ($this-&gt;persistentConnection) {
+						$http-&gt;usePersistentConnection();
+					}
+				}
+				$http-&gt;setContentType($this-&gt;getHTTPContentType(), $this-&gt;getHTTPContentTypeCharset());
+				$http-&gt;setSOAPAction($soapaction);
+				if($this-&gt;proxyhost &amp;&amp; $this-&gt;proxyport){
+					$http-&gt;setProxy($this-&gt;proxyhost,$this-&gt;proxyport,$this-&gt;proxyusername,$this-&gt;proxypassword);
+				}
+                if($this-&gt;authtype != '') {
+					$http-&gt;setCredentials($this-&gt;username, $this-&gt;password, $this-&gt;authtype, array(), $this-&gt;certRequest);
+				}
+				if($this-&gt;http_encoding != ''){
+					$http-&gt;setEncoding($this-&gt;http_encoding);
+				}
+				$this-&gt;debug('sending message, length='.strlen($msg));
+				if(ereg('^http:',$this-&gt;endpoint)){
+				//if(strpos($this-&gt;endpoint,'http:')){
+					$this-&gt;responseData = $http-&gt;send($msg,$timeout,$response_timeout,$this-&gt;cookies);
+				} elseif(ereg('^https',$this-&gt;endpoint)){
+				//} elseif(strpos($this-&gt;endpoint,'https:')){
+					//if(phpversion() == '4.3.0-dev'){
+						//$response = $http-&gt;send($msg,$timeout,$response_timeout);
+                   		//$this-&gt;request = $http-&gt;outgoing_payload;
+						//$this-&gt;response = $http-&gt;incoming_payload;
+					//} else
+					$this-&gt;responseData = $http-&gt;sendHTTPS($msg,$timeout,$response_timeout,$this-&gt;cookies);
+				} else {
+					$this-&gt;setError('no http/s in endpoint url');
+				}
+				$this-&gt;request = $http-&gt;outgoing_payload;
+				$this-&gt;response = $http-&gt;incoming_payload;
+				$this-&gt;appendDebug($http-&gt;getDebug());
+				$this-&gt;UpdateCookies($http-&gt;incoming_cookies);
+
+				// save transport object if using persistent connections
+				if ($this-&gt;persistentConnection) {
+					$http-&gt;clearDebug();
+					if (!is_object($this-&gt;persistentConnection)) {
+						$this-&gt;persistentConnection = $http;
+					}
+				}
+				
+				if($err = $http-&gt;getError()){
+					$this-&gt;setError('HTTP Error: '.$err);
+					return false;
+				} elseif($this-&gt;getError()){
+					return false;
+				} else {
+					$this-&gt;debug('got response, length='. strlen($this-&gt;responseData).' type='.$http-&gt;incoming_headers['content-type']);
+					return $this-&gt;parseResponse($http-&gt;incoming_headers, $this-&gt;responseData);
+				}
+			break;
+			default:
+				$this-&gt;setError('no transport found, or selected transport is not yet supported!');
+			return false;
+			break;
+		}
+	}
+
+	/**
+	* processes SOAP message returned from server
+	*
+	* @param	array	$headers	The HTTP headers
+	* @param	string	$data		unprocessed response data from server
+	* @return	mixed	value of the message, decoded into a PHP type
+	* @access   private
+	*/
+    function parseResponse($headers, $data) {
+		$this-&gt;debug('Entering parseResponse() for data of length ' . strlen($data) . ' and type ' . $headers['content-type']);
+		if (!strstr($headers['content-type'], 'text/xml')) {
+			$this-&gt;setError('Response not of type text/xml');
+			return false;
+		}
+		if (strpos($headers['content-type'], '=')) {
+			$enc = str_replace('&quot;', '', substr(strstr($headers[&quot;content-type&quot;], '='), 1));
+			$this-&gt;debug('Got response encoding: ' . $enc);
+			if(eregi('^(ISO-8859-1|US-ASCII|UTF-8)$',$enc)){
+				$this-&gt;xml_encoding = strtoupper($enc);
+			} else {
+				$this-&gt;xml_encoding = 'US-ASCII';
+			}
+		} else {
+			// should be US-ASCII for HTTP 1.0 or ISO-8859-1 for HTTP 1.1
+			$this-&gt;xml_encoding = 'ISO-8859-1';
+		}
+		$this-&gt;debug('Use encoding: ' . $this-&gt;xml_encoding . ' when creating soap_parser');
+		$parser = new soap_parser($data,$this-&gt;xml_encoding,$this-&gt;operation,$this-&gt;decode_utf8);
+		// add parser debug data to our debug
+		$this-&gt;appendDebug($parser-&gt;getDebug());
+		// if parse errors
+		if($errstr = $parser-&gt;getError()){
+			$this-&gt;setError( $errstr);
+			// destroy the parser object
+			unset($parser);
+			return false;
+		} else {
+			// get SOAP headers
+			$this-&gt;responseHeaders = $parser-&gt;getHeaders();
+			// get decoded message
+			$return = $parser-&gt;get_response();
+            // add document for doclit support
+            $this-&gt;document = $parser-&gt;document;
+			// destroy the parser object
+			unset($parser);
+			// return decode message
+			return $return;
+		}
+	 }
+
+	/**
+	* sets the SOAP endpoint, which can override WSDL
+	*
+	* @param	$endpoint string The endpoint URL to use, or empty string or false to prevent override
+	* @access   public
+	*/
+	function setEndpoint($endpoint) {
+		$this-&gt;forceEndpoint = $endpoint;
+	}
+
+	/**
+	* set the SOAP headers
+	*
+	* @param	$headers mixed String of XML with SOAP header content, or array of soapval objects for SOAP headers
+	* @access   public
+	*/
+	function setHeaders($headers){
+		$this-&gt;requestHeaders = $headers;
+	}
+
+	/**
+	* get the SOAP response headers (namespace resolution incomplete)
+	*
+	* @return	string
+	* @access   public
+	*/
+	function getHeaders(){
+		return $this-&gt;responseHeaders;
+	}
+
+	/**
+	* set proxy info here
+	*
+	* @param    string $proxyhost
+	* @param    string $proxyport
+	* @param	string $proxyusername
+	* @param	string $proxypassword
+	* @access   public
+	*/
+	function setHTTPProxy($proxyhost, $proxyport, $proxyusername = '', $proxypassword = '') {
+		$this-&gt;proxyhost = $proxyhost;
+		$this-&gt;proxyport = $proxyport;
+		$this-&gt;proxyusername = $proxyusername;
+		$this-&gt;proxypassword = $proxypassword;
+	}
+
+	/**
+	* if authenticating, set user credentials here
+	*
+	* @param    string $username
+	* @param    string $password
+	* @param	string $authtype (basic|digest|certificate)
+	* @param	array $certRequest (keys must be cainfofile (optional), sslcertfile, sslkeyfile, passphrase, verifypeer (optional), verifyhost (optional): see corresponding options in cURL docs)
+	* @access   public
+	*/
+	function setCredentials($username, $password, $authtype = 'basic', $certRequest = array()) {
+		$this-&gt;username = $username;
+		$this-&gt;password = $password;
+		$this-&gt;authtype = $authtype;
+		$this-&gt;certRequest = $certRequest;
+	}
+	
+	/**
+	* use HTTP encoding
+	*
+	* @param    string $enc
+	* @access   public
+	*/
+	function setHTTPEncoding($enc='gzip, deflate'){
+		$this-&gt;http_encoding = $enc;
+	}
+	
+	/**
+	* use HTTP persistent connections if possible
+	*
+	* @access   public
+	*/
+	function useHTTPPersistentConnection(){
+		$this-&gt;persistentConnection = true;
+	}
+	
+	/**
+	* gets the default RPC parameter setting.
+	* If true, default is that call params are like RPC even for document style.
+	* Each call() can override this value.
+	*
+	* This is no longer used.
+	*
+	* @return boolean
+	* @access public
+	* @deprecated
+	*/
+	function getDefaultRpcParams() {
+		return $this-&gt;defaultRpcParams;
+	}
+
+	/**
+	* sets the default RPC parameter setting.
+	* If true, default is that call params are like RPC even for document style
+	* Each call() can override this value.
+	*
+	* This is no longer used.
+	*
+	* @param    boolean $rpcParams
+	* @access public
+	* @deprecated
+	*/
+	function setDefaultRpcParams($rpcParams) {
+		$this-&gt;defaultRpcParams = $rpcParams;
+	}
+	
+	/**
+	* dynamically creates an instance of a proxy class,
+	* allowing user to directly call methods from wsdl
+	*
+	* @return   object soap_proxy object
+	* @access   public
+	*/
+	function getProxy(){
+		$r = rand();
+		$evalStr = $this-&gt;_getProxyClassCode($r);
+		//$this-&gt;debug(&quot;proxy class: $evalStr&quot;;
+		// eval the class
+		eval($evalStr);
+		// instantiate proxy object
+		eval(&quot;\$proxy = new soap_proxy_$r('');&quot;);
+		// transfer current wsdl data to the proxy thereby avoiding parsing the wsdl twice
+		$proxy-&gt;endpointType = 'wsdl';
+		$proxy-&gt;wsdlFile = $this-&gt;wsdlFile;
+		$proxy-&gt;wsdl = $this-&gt;wsdl;
+		$proxy-&gt;operations = $this-&gt;operations;
+		$proxy-&gt;defaultRpcParams = $this-&gt;defaultRpcParams;
+		// transfer other state
+		$proxy-&gt;username = $this-&gt;username;
+		$proxy-&gt;password = $this-&gt;password;
+		$proxy-&gt;authtype = $this-&gt;authtype;
+		$proxy-&gt;proxyhost = $this-&gt;proxyhost;
+		$proxy-&gt;proxyport = $this-&gt;proxyport;
+		$proxy-&gt;proxyusername = $this-&gt;proxyusername;
+		$proxy-&gt;proxypassword = $this-&gt;proxypassword;
+		$proxy-&gt;timeout = $this-&gt;timeout;
+		$proxy-&gt;response_timeout = $this-&gt;response_timeout;
+		$proxy-&gt;http_encoding = $this-&gt;http_encoding;
+		$proxy-&gt;persistentConnection = $this-&gt;persistentConnection;
+		$proxy-&gt;requestHeaders = $this-&gt;requestHeaders;
+		$proxy-&gt;soap_defencoding = $this-&gt;soap_defencoding;
+		$proxy-&gt;endpoint = $this-&gt;endpoint;
+		$proxy-&gt;forceEndpoint = $this-&gt;forceEndpoint;
+		return $proxy;
+	}
+
+	/**
+	* dynamically creates proxy class code
+	*
+	* @return   string PHP/NuSOAP code for the proxy class
+	* @access   private
+	*/
+	function _getProxyClassCode($r) {
+		if ($this-&gt;endpointType != 'wsdl') {
+			$evalStr = 'A proxy can only be created for a WSDL client';
+			$this-&gt;setError($evalStr);
+			return $evalStr;
+		}
+		$evalStr = '';
+		foreach ($this-&gt;operations as $operation =&gt; $opData) {
+			if ($operation != '') {
+				// create param string and param comment string
+				if (sizeof($opData['input']['parts']) &gt; 0) {
+					$paramStr = '';
+					$paramArrayStr = '';
+					$paramCommentStr = '';
+					foreach ($opData['input']['parts'] as $name =&gt; $type) {
+						$paramStr .= &quot;\$$name, &quot;;
+						$paramArrayStr .= &quot;'$name' =&gt; \$$name, &quot;;
+						$paramCommentStr .= &quot;$type \$$name, &quot;;
+					}
+					$paramStr = substr($paramStr, 0, strlen($paramStr)-2);
+					$paramArrayStr = substr($paramArrayStr, 0, strlen($paramArrayStr)-2);
+					$paramCommentStr = substr($paramCommentStr, 0, strlen($paramCommentStr)-2);
+				} else {
+					$paramStr = '';
+					$paramCommentStr = 'void';
+				}
+				$opData['namespace'] = !isset($opData['namespace']) ? '<A HREF="http://testuri.com">http://testuri.com</A>' : $opData['namespace'];
+				$evalStr .= &quot;// $paramCommentStr
+	function &quot; . str_replace('.', '__', $operation) . &quot;($paramStr) {
+		\$params = array($paramArrayStr);
+		return \$this-&gt;call('$operation', \$params, '&quot;.$opData['namespace'].&quot;', '&quot;.(isset($opData['soapAction']) ? $opData['soapAction'] : '').&quot;');
+	}
+	&quot;;
+				unset($paramStr);
+				unset($paramCommentStr);
+			}
+		}
+		$evalStr = 'class soap_proxy_'.$r.' extends soapclient {
+	'.$evalStr.'
+}';
+		return $evalStr;
+	}
+
+	/**
+	* dynamically creates proxy class code
+	*
+	* @return   string PHP/NuSOAP code for the proxy class
+	* @access   public
+	*/
+	function getProxyClassCode() {
+		$r = rand();
+		return $this-&gt;_getProxyClassCode($r);
+	}
+
+	/**
+	* gets the HTTP body for the current request.
+	*
+	* @param string $soapmsg The SOAP payload
+	* @return string The HTTP body, which includes the SOAP payload
+	* @access private
+	*/
+	function getHTTPBody($soapmsg) {
+		return $soapmsg;
+	}
+	
+	/**
+	* gets the HTTP content type for the current request.
+	*
+	* Note: getHTTPBody must be called before this.
+	*
+	* @return string the HTTP content type for the current request.
+	* @access private
+	*/
+	function getHTTPContentType() {
+		return 'text/xml';
+	}
+	
+	/**
+	* gets the HTTP content type charset for the current request.
+	* returns false for non-text content types.
+	*
+	* Note: getHTTPBody must be called before this.
+	*
+	* @return string the HTTP content type charset for the current request.
+	* @access private
+	*/
+	function getHTTPContentTypeCharset() {
+		return $this-&gt;soap_defencoding;
+	}
+
+	/*
+	* whether or not parser should decode utf8 element content
+    *
+    * @return   always returns true
+    * @access   public
+    */
+    function decodeUTF8($bool){
+		$this-&gt;decode_utf8 = $bool;
+		return true;
+    }
+
+	/**
+	 * adds a new Cookie into $this-&gt;cookies array
+	 *
+	 * @param	string $name Cookie Name
+	 * @param	string $value Cookie Value
+	 * @return	if cookie-set was successful returns true, else false
+	 * @access	public
+	 */
+	function setCookie($name, $value) {
+		if (strlen($name) == 0) {
+			return false;
+		}
+		$this-&gt;cookies[] = array('name' =&gt; $name, 'value' =&gt; $value);
+		return true;
+	}
+
+	/**
+	 * gets all Cookies
+	 *
+	 * @return   array with all internal cookies
+	 * @access   public
+	 */
+	function getCookies() {
+		return $this-&gt;cookies;
+	}
+
+	/**
+	 * checks all Cookies and delete those which are expired
+	 *
+	 * @return   always return true
+	 * @access   private
+	 */
+	function checkCookies() {
+		if (sizeof($this-&gt;cookies) == 0) {
+			return true;
+		}
+		$this-&gt;debug('checkCookie: check ' . sizeof($this-&gt;cookies) . ' cookies');
+		$curr_cookies = $this-&gt;cookies;
+		$this-&gt;cookies = array();
+		foreach ($curr_cookies as $cookie) {
+			if (! is_array($cookie)) {
+				$this-&gt;debug('Remove cookie that is not an array');
+				continue;
+			}
+			if ((isset($cookie['expires'])) &amp;&amp; (! empty($cookie['expires']))) {
+				if (strtotime($cookie['expires']) &gt; time()) {
+					$this-&gt;cookies[] = $cookie;
+				} else {
+					$this-&gt;debug('Remove expired cookie ' . $cookie['name']);
+				}
+			} else {
+				$this-&gt;cookies[] = $cookie;
+			}
+		}
+		$this-&gt;debug('checkCookie: '.sizeof($this-&gt;cookies).' cookies left in array');
+		return true;
+	}
+
+	/**
+	 * updates the current cookies with a new set
+	 *
+	 * @param	array $cookies new cookies with which to update current ones
+	 * @return	always return true
+	 * @access	private
+	 */
+	function UpdateCookies($cookies) {
+		if (sizeof($this-&gt;cookies) == 0) {
+			// no existing cookies: take whatever is new
+			if (sizeof($cookies) &gt; 0) {
+				$this-&gt;debug('Setting new cookie(s)');
+				$this-&gt;cookies = $cookies;
+			}
+			return true;
+		}
+		if (sizeof($cookies) == 0) {
+			// no new cookies: keep what we've got
+			return true;
+		}
+		// merge
+		foreach ($cookies as $newCookie) {
+			if (!is_array($newCookie)) {
+				continue;
+			}
+			if ((!isset($newCookie['name'])) || (!isset($newCookie['value']))) {
+				continue;
+			}
+			$newName = $newCookie['name'];
+
+			$found = false;
+			for ($i = 0; $i &lt; count($this-&gt;cookies); $i++) {
+				$cookie = $this-&gt;cookies[$i];
+				if (!is_array($cookie)) {
+					continue;
+				}
+				if (!isset($cookie['name'])) {
+					continue;
+				}
+				if ($newName != $cookie['name']) {
+					continue;
+				}
+				$newDomain = isset($newCookie['domain']) ? $newCookie['domain'] : 'NODOMAIN';
+				$domain = isset($cookie['domain']) ? $cookie['domain'] : 'NODOMAIN';
+				if ($newDomain != $domain) {
+					continue;
+				}
+				$newPath = isset($newCookie['path']) ? $newCookie['path'] : 'NOPATH';
+				$path = isset($cookie['path']) ? $cookie['path'] : 'NOPATH';
+				if ($newPath != $path) {
+					continue;
+				}
+				$this-&gt;cookies[$i] = $newCookie;
+				$found = true;
+				$this-&gt;debug('Update cookie ' . $newName . '=' . $newCookie['value']);
+				break;
+			}
+			if (! $found) {
+				$this-&gt;debug('Add cookie ' . $newName . '=' . $newCookie['value']);
+				$this-&gt;cookies[] = $newCookie;
+			}
+		}
+		return true;
+	}
+}
+?&gt;

Added: cms/trunk/includes/nusoap/nusoapmime.php
===================================================================
--- cms/trunk/includes/nusoap/nusoapmime.php	2005-09-20 21:46:50 UTC (rev 136)
+++ cms/trunk/includes/nusoap/nusoapmime.php	2005-09-21 03:53:30 UTC (rev 137)
@@ -0,0 +1,478 @@
+&lt;?php
+/*
+$Id: nusoapmime.php,v 1.7 2005/07/27 19:24:42 snichol Exp $
+
+NuSOAP - Web Services Toolkit for PHP
+
+Copyright (c) 2002 NuSphere Corporation
+
+This library is free software; you can redistribute it and/or
+modify it under the terms of the GNU Lesser General Public
+License as published by the Free Software Foundation; either
+version 2.1 of the License, or (at your option) any later version.
+
+This library is distributed in the hope that it will be useful,
+but WITHOUT ANY WARRANTY; without even the implied warranty of
+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+Lesser General Public License for more details.
+
+You should have received a copy of the GNU Lesser General Public
+License along with this library; if not, write to the Free Software
+Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
+
+If you have any questions or comments, please email:
+
+Dietrich Ayala
<A HREF="https://lists.berlios.de/mailman/listinfo/viperals-svncheckins">+dietrich at ganx4.com</A>
+<A HREF="http://dietrich.ganx4.com/nusoap">http://dietrich.ganx4.com/nusoap</A>
+
+NuSphere Corporation
+<A HREF="http://www.nusphere.com">http://www.nusphere.com</A>
+
+*/
+
+/*require_once('nusoap.php');*/
+/* PEAR Mail_MIME library */
+require_once('Mail/mimeDecode.php');
+require_once('Mail/mimePart.php');
+
+/**
+* soapclientmime client supporting MIME attachments defined at
+* <A HREF="http://www.w3.org/TR/SOAP-attachments.">http://www.w3.org/TR/SOAP-attachments.</A>  It depends on the PEAR Mail_MIME library.
+*
+* @author   Scott Nichol &lt;<A HREF="https://lists.berlios.de/mailman/listinfo/viperals-svncheckins">snichol at sourceforge.net</A>&gt;
+* @author	Thanks to Guillaume and Henning Reich for posting great attachment code to the mail list
+* @version  $Id: nusoapmime.php,v 1.7 2005/07/27 19:24:42 snichol Exp $
+* @access   public
+*/
+class soapclientmime extends soapclient {
+	/**
+	 * @var array Each array element in the return is an associative array with keys
+	 * data, filename, contenttype, cid
+	 * @access private
+	 */
+	var $requestAttachments = array();
+	/**
+	 * @var array Each array element in the return is an associative array with keys
+	 * data, filename, contenttype, cid
+	 * @access private
+	 */
+	var $responseAttachments;
+	/**
+	 * @var string
+	 * @access private
+	 */
+	var $mimeContentType;
+	
+	/**
+	* adds a MIME attachment to the current request.
+	*
+	* If the $data parameter contains an empty string, this method will read
+	* the contents of the file named by the $filename parameter.
+	*
+	* If the $cid parameter is false, this method will generate the cid.
+	*
+	* @param string $data The data of the attachment
+	* @param string $filename The filename of the attachment (default is empty string)
+	* @param string $contenttype The MIME Content-Type of the attachment (default is application/octet-stream)
+	* @param string $cid The content-id (cid) of the attachment (default is false)
+	* @return string The content-id (cid) of the attachment
+	* @access public
+	*/
+	function addAttachment($data, $filename = '', $contenttype = 'application/octet-stream', $cid = false) {
+		if (! $cid) {
+			$cid = md5(uniqid(time()));
+		}
+
+		$info['data'] = $data;
+		$info['filename'] = $filename;
+		$info['contenttype'] = $contenttype;
+		$info['cid'] = $cid;
+		
+		$this-&gt;requestAttachments[] = $info;
+
+		return $cid;
+	}
+
+	/**
+	* clears the MIME attachments for the current request.
+	*
+	* @access public
+	*/
+	function clearAttachments() {
+		$this-&gt;requestAttachments = array();
+	}
+
+	/**
+	* gets the MIME attachments from the current response.
+	*
+	* Each array element in the return is an associative array with keys
+	* data, filename, contenttype, cid.  These keys correspond to the parameters
+	* for addAttachment.
+	*
+	* @return array The attachments.
+	* @access public
+	*/
+	function getAttachments() {
+		return $this-&gt;responseAttachments;
+	}
+
+	/**
+	* gets the HTTP body for the current request.
+	*
+	* @param string $soapmsg The SOAP payload
+	* @return string The HTTP body, which includes the SOAP payload
+	* @access private
+	*/
+	function getHTTPBody($soapmsg) {
+		if (count($this-&gt;requestAttachments) &gt; 0) {
+			$params['content_type'] = 'multipart/related; type=text/xml';
+			$mimeMessage =&amp; new Mail_mimePart('', $params);
+			unset($params);
+
+			$params['content_type'] = 'text/xml';
+			$params['encoding']     = '8bit';
+			$params['charset']      = $this-&gt;soap_defencoding;
+			$mimeMessage-&gt;addSubpart($soapmsg, $params);
+			
+			foreach ($this-&gt;requestAttachments as $att) {
+				unset($params);
+
+				$params['content_type'] = $att['contenttype'];
+				$params['encoding']     = 'base64';
+				$params['disposition']  = 'attachment';
+				$params['dfilename']    = $att['filename'];
+				$params['cid']          = $att['cid'];
+
+				if ($att['data'] == '' &amp;&amp; $att['filename'] &lt;&gt; '') {
+					if ($fd = fopen($att['filename'], 'rb')) {
+						$data = fread($fd, filesize($att['filename']));
+						fclose($fd);
+					} else {
+						$data = '';
+					}
+					$mimeMessage-&gt;addSubpart($data, $params);
+				} else {
+					$mimeMessage-&gt;addSubpart($att['data'], $params);
+				}
+			}
+
+			$output = $mimeMessage-&gt;encode();
+			$mimeHeaders = $output['headers'];
+	
+			foreach ($mimeHeaders as $k =&gt; $v) {
+				$this-&gt;debug(&quot;MIME header $k: $v&quot;);
+				if (strtolower($k) == 'content-type') {
+					// PHP header() seems to strip leading whitespace starting
+					// the second line, so force everything to one line
+					$this-&gt;mimeContentType = str_replace(&quot;\r\n&quot;, &quot; &quot;, $v);
+				}
+			}
+	
+			return $output['body'];
+		}
+
+		return parent::getHTTPBody($soapmsg);
+	}
+	
+	/**
+	* gets the HTTP content type for the current request.
+	*
+	* Note: getHTTPBody must be called before this.
+	*
+	* @return string the HTTP content type for the current request.
+	* @access private
+	*/
+	function getHTTPContentType() {
+		if (count($this-&gt;requestAttachments) &gt; 0) {
+			return $this-&gt;mimeContentType;
+		}
+		return parent::getHTTPContentType();
+	}
+	
+	/**
+	* gets the HTTP content type charset for the current request.
+	* returns false for non-text content types.
+	*
+	* Note: getHTTPBody must be called before this.
+	*
+	* @return string the HTTP content type charset for the current request.
+	* @access private
+	*/
+	function getHTTPContentTypeCharset() {
+		if (count($this-&gt;requestAttachments) &gt; 0) {
+			return false;
+		}
+		return parent::getHTTPContentTypeCharset();
+	}
+
+	/**
+	* processes SOAP message returned from server
+	*
+	* @param	array	$headers	The HTTP headers
+	* @param	string	$data		unprocessed response data from server
+	* @return	mixed	value of the message, decoded into a PHP type
+	* @access   private
+	*/
+    function parseResponse($headers, $data) {
+		$this-&gt;debug('Entering parseResponse() for payload of length ' . strlen($data) . ' and type of ' . $headers['content-type']);
+		$this-&gt;responseAttachments = array();
+		if (strstr($headers['content-type'], 'multipart/related')) {
+			$this-&gt;debug('Decode multipart/related');
+			$input = '';
+			foreach ($headers as $k =&gt; $v) {
+				$input .= &quot;$k: $v\r\n&quot;;
+			}
+			$params['input'] = $input . &quot;\r\n&quot; . $data;
+			$params['include_bodies'] = true;
+			$params['decode_bodies'] = true;
+			$params['decode_headers'] = true;
+			
+			$structure = Mail_mimeDecode::decode($params);
+
+			foreach ($structure-&gt;parts as $part) {
+				if (!isset($part-&gt;disposition)) {
+					$this-&gt;debug('Have root part of type ' . $part-&gt;headers['content-type']);
+					$return = parent::parseResponse($part-&gt;headers, $part-&gt;body);
+				} else {
+					$this-&gt;debug('Have an attachment of type ' . $part-&gt;headers['content-type']);
+					$info['data'] = $part-&gt;body;
+					$info['filename'] = isset($part-&gt;d_parameters['filename']) ? $part-&gt;d_parameters['filename'] : '';
+					$info['contenttype'] = $part-&gt;headers['content-type'];
+					$info['cid'] = $part-&gt;headers['content-id'];
+					$this-&gt;responseAttachments[] = $info;
+				}
+			}
+		
+			if (isset($return)) {
+				return $return;
+			}
+			
+			$this-&gt;setError('No root part found in multipart/related content');
+			return;
+		}
+		$this-&gt;debug('Not multipart/related');
+		return parent::parseResponse($headers, $data);
+	}
+}
+
+/**
+* nusoapservermime server supporting MIME attachments defined at
+* <A HREF="http://www.w3.org/TR/SOAP-attachments.">http://www.w3.org/TR/SOAP-attachments.</A>  It depends on the PEAR Mail_MIME library.
+*
+* @author   Scott Nichol &lt;<A HREF="https://lists.berlios.de/mailman/listinfo/viperals-svncheckins">snichol at sourceforge.net</A>&gt;
+* @author	Thanks to Guillaume and Henning Reich for posting great attachment code to the mail list
+* @version  $Id: nusoapmime.php,v 1.7 2005/07/27 19:24:42 snichol Exp $
+* @access   public
+*/
+class nusoapservermime extends soap_server {
+	/**
+	 * @var array Each array element in the return is an associative array with keys
+	 * data, filename, contenttype, cid
+	 * @access private
+	 */
+	var $requestAttachments = array();
+	/**
+	 * @var array Each array element in the return is an associative array with keys
+	 * data, filename, contenttype, cid
+	 * @access private
+	 */
+	var $responseAttachments;
+	/**
+	 * @var string
+	 * @access private
+	 */
+	var $mimeContentType;
+	
+	/**
+	* adds a MIME attachment to the current response.
+	*
+	* If the $data parameter contains an empty string, this method will read
+	* the contents of the file named by the $filename parameter.
+	*
+	* If the $cid parameter is false, this method will generate the cid.
+	*
+	* @param string $data The data of the attachment
+	* @param string $filename The filename of the attachment (default is empty string)
+	* @param string $contenttype The MIME Content-Type of the attachment (default is application/octet-stream)
+	* @param string $cid The content-id (cid) of the attachment (default is false)
+	* @return string The content-id (cid) of the attachment
+	* @access public
+	*/
+	function addAttachment($data, $filename = '', $contenttype = 'application/octet-stream', $cid = false) {
+		if (! $cid) {
+			$cid = md5(uniqid(time()));
+		}
+
+		$info['data'] = $data;
+		$info['filename'] = $filename;
+		$info['contenttype'] = $contenttype;
+		$info['cid'] = $cid;
+		
+		$this-&gt;responseAttachments[] = $info;
+
+		return $cid;
+	}
+
+	/**
+	* clears the MIME attachments for the current response.
+	*
+	* @access public
+	*/
+	function clearAttachments() {
+		$this-&gt;responseAttachments = array();
+	}
+
+	/**
+	* gets the MIME attachments from the current request.
+	*
+	* Each array element in the return is an associative array with keys
+	* data, filename, contenttype, cid.  These keys correspond to the parameters
+	* for addAttachment.
+	*
+	* @return array The attachments.
+	* @access public
+	*/
+	function getAttachments() {
+		return $this-&gt;requestAttachments;
+	}
+
+	/**
+	* gets the HTTP body for the current response.
+	*
+	* @param string $soapmsg The SOAP payload
+	* @return string The HTTP body, which includes the SOAP payload
+	* @access private
+	*/
+	function getHTTPBody($soapmsg) {
+		if (count($this-&gt;responseAttachments) &gt; 0) {
+			$params['content_type'] = 'multipart/related; type=text/xml';
+			$mimeMessage =&amp; new Mail_mimePart('', $params);
+			unset($params);
+
+			$params['content_type'] = 'text/xml';
+			$params['encoding']     = '8bit';
+			$params['charset']      = $this-&gt;soap_defencoding;
+			$mimeMessage-&gt;addSubpart($soapmsg, $params);
+			
+			foreach ($this-&gt;responseAttachments as $att) {
+				unset($params);
+
+				$params['content_type'] = $att['contenttype'];
+				$params['encoding']     = 'base64';
+				$params['disposition']  = 'attachment';
+				$params['dfilename']    = $att['filename'];
+				$params['cid']          = $att['cid'];
+
+				if ($att['data'] == '' &amp;&amp; $att['filename'] &lt;&gt; '') {
+					if ($fd = fopen($att['filename'], 'rb')) {
+						$data = fread($fd, filesize($att['filename']));
+						fclose($fd);
+					} else {
+						$data = '';
+					}
+					$mimeMessage-&gt;addSubpart($data, $params);
+				} else {
+					$mimeMessage-&gt;addSubpart($att['data'], $params);
+				}
+			}
+
+			$output = $mimeMessage-&gt;encode();
+			$mimeHeaders = $output['headers'];
+	
+			foreach ($mimeHeaders as $k =&gt; $v) {
+				$this-&gt;debug(&quot;MIME header $k: $v&quot;);
+				if (strtolower($k) == 'content-type') {
+					// PHP header() seems to strip leading whitespace starting
+					// the second line, so force everything to one line
+					$this-&gt;mimeContentType = str_replace(&quot;\r\n&quot;, &quot; &quot;, $v);
+				}
+			}
+	
+			return $output['body'];
+		}
+
+		return parent::getHTTPBody($soapmsg);
+	}
+	
+	/**
+	* gets the HTTP content type for the current response.
+	*
+	* Note: getHTTPBody must be called before this.
+	*
+	* @return string the HTTP content type for the current response.
+	* @access private
+	*/
+	function getHTTPContentType() {
+		if (count($this-&gt;responseAttachments) &gt; 0) {
+			return $this-&gt;mimeContentType;
+		}
+		return parent::getHTTPContentType();
+	}
+	
+	/**
+	* gets the HTTP content type charset for the current response.
+	* returns false for non-text content types.
+	*
+	* Note: getHTTPBody must be called before this.
+	*
+	* @return string the HTTP content type charset for the current response.
+	* @access private
+	*/
+	function getHTTPContentTypeCharset() {
+		if (count($this-&gt;responseAttachments) &gt; 0) {
+			return false;
+		}
+		return parent::getHTTPContentTypeCharset();
+	}
+
+	/**
+	* processes SOAP message received from client
+	*
+	* @param	array	$headers	The HTTP headers
+	* @param	string	$data		unprocessed request data from client
+	* @return	mixed	value of the message, decoded into a PHP type
+	* @access   private
+	*/
+    function parseRequest($headers, $data) {
+		$this-&gt;debug('Entering parseRequest() for payload of length ' . strlen($data) . ' and type of ' . $headers['content-type']);
+		$this-&gt;requestAttachments = array();
+		if (strstr($headers['content-type'], 'multipart/related')) {
+			$this-&gt;debug('Decode multipart/related');
+			$input = '';
+			foreach ($headers as $k =&gt; $v) {
+				$input .= &quot;$k: $v\r\n&quot;;
+			}
+			$params['input'] = $input . &quot;\r\n&quot; . $data;
+			$params['include_bodies'] = true;
+			$params['decode_bodies'] = true;
+			$params['decode_headers'] = true;
+			
+			$structure = Mail_mimeDecode::decode($params);
+
+			foreach ($structure-&gt;parts as $part) {
+				if (!isset($part-&gt;disposition)) {
+					$this-&gt;debug('Have root part of type ' . $part-&gt;headers['content-type']);
+					$return = parent::parseRequest($part-&gt;headers, $part-&gt;body);
+				} else {
+					$this-&gt;debug('Have an attachment of type ' . $part-&gt;headers['content-type']);
+					$info['data'] = $part-&gt;body;
+					$info['filename'] = isset($part-&gt;d_parameters['filename']) ? $part-&gt;d_parameters['filename'] : '';
+					$info['contenttype'] = $part-&gt;headers['content-type'];
+					$info['cid'] = $part-&gt;headers['content-id'];
+					$this-&gt;requestAttachments[] = $info;
+				}
+			}
+		
+			if (isset($return)) {
+				return $return;
+			}
+			
+			$this-&gt;setError('No root part found in multipart/related content');
+			return;
+		}
+		$this-&gt;debug('Not multipart/related');
+		return parent::parseRequest($headers, $data);
+	}
+}
+?&gt;

Added: cms/trunk/includes/templates/error_document.html
===================================================================
--- cms/trunk/includes/templates/error_document.html	2005-09-20 21:46:50 UTC (rev 136)
+++ cms/trunk/includes/templates/error_document.html	2005-09-21 03:53:30 UTC (rev 137)
@@ -0,0 +1,20 @@
+&lt;!DOCTYPE html PUBLIC &quot;-//W3C//DTD XHTML 1.0 Transitional//EN&quot; &quot;<A HREF="http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd</A>&quot;&gt;
+&lt;html xmlns=&quot;<A HREF="http://www.w3.org/1999/xhtml">http://www.w3.org/1999/xhtml</A>&quot; xml:lang=&quot;en&quot; lang=&quot;en&quot;&gt;
+
+&lt;head&gt;
+&lt;meta http-equiv=&quot;Content-Type&quot; content=&quot;text/html; charset=utf-8&quot; /&gt;
+&lt;title&gt;Error&lt;/title&gt;
+&lt;/head&gt;
+
+&lt;body style=&quot;background: url(images/bg.gif);&quot;&gt;
+	&lt;table style=&quot;position: absolute; left: 25%; top: 25%;&quot;&gt;
+		&lt;tr&gt;
+			&lt;td valign=&quot;top&quot;&gt;
+				{ $MESSAGE_TEXT }
+				&lt;br /&gt;&lt;a href=&quot;{ $SITE_LINK }&quot;&gt;Click here to homepage&lt;/a&gt;&lt;br /&gt;[ &lt;a href=&quot;javascript:history.go(-1)&quot;&gt;Go Back&lt;/a&gt; ]&lt;/div&gt;
+			&lt;/td&gt;
+		&lt;/tr&gt;
+	&lt;/table&gt;
+&lt;/body&gt;
+
+&lt;/html&gt;
\ No newline at end of file

Modified: cms/trunk/includes/templates/modules/Forums/search_body.html
===================================================================
--- cms/trunk/includes/templates/modules/Forums/search_body.html	2005-09-20 21:46:50 UTC (rev 136)
+++ cms/trunk/includes/templates/modules/Forums/search_body.html	2005-09-21 03:53:30 UTC (rev 137)
@@ -2,47 +2,49 @@
 
 &lt;!-- INCLUDE modules/Forums/overall_header.html --&gt;
 
-&lt;form method=&quot;post&quot; action=&quot;{ $S_SEARCH_ACTION }&quot;&gt;&lt;table class=&quot;tablebg&quot; width=&quot;100%&quot; cellspacing=&quot;1&quot;&gt;
-	&lt;tr&gt; 
-		&lt;th colspan=&quot;4&quot;&gt;{ $L_SEARCH_QUERY }&lt;/th&gt;
-	&lt;/tr&gt;
-	&lt;tr&gt; 
-		&lt;td class=&quot;row1&quot; colspan=&quot;2&quot; width=&quot;50%&quot;&gt;&lt;b class=&quot;genmed&quot;&gt;{ $L_SEARCH_KEYWORDS }: &lt;/b&gt;&lt;br /&gt;&lt;span class=&quot;gensmall&quot;&gt;{ $L_SEARCH_KEYWORDS_EXPLAIN }&lt;/span&gt;&lt;/td&gt;
-		&lt;td class=&quot;row2&quot; colspan=&quot;2&quot; valign=&quot;top&quot;&gt;&lt;input type=&quot;text&quot; style=&quot;width: 300px&quot; class=&quot;post&quot; name=&quot;search_keywords&quot; size=&quot;30&quot; /&gt;&lt;br /&gt;&lt;input type=&quot;radio&quot; name=&quot;search_terms&quot; value=&quot;all&quot; checked=&quot;checked&quot; /&gt; &lt;span class=&quot;genmed&quot;&gt;{ $L_SEARCH_ALL_TERMS }&lt;/span&gt;&lt;br /&gt;&lt;input type=&quot;radio&quot; name=&quot;search_terms&quot; value=&quot;any&quot; /&gt; &lt;span class=&quot;genmed&quot;&gt;{ $L_SEARCH_ANY_TERMS }&lt;/span&gt;&lt;/td&gt;
-	&lt;/tr&gt;
-	&lt;tr&gt; 
-		&lt;td class=&quot;row1&quot; colspan=&quot;2&quot;&gt;&lt;b class=&quot;genmed&quot;&gt;{ $L_SEARCH_AUTHOR }:&lt;/b&gt;&lt;br /&gt;&lt;span class=&quot;gensmall&quot;&gt;{ $L_SEARCH_AUTHOR_EXPLAIN }&lt;/span&gt;&lt;/td&gt;
-		&lt;td class=&quot;row2&quot; colspan=&quot;2&quot; valign=&quot;middle&quot;&gt;&lt;input type=&quot;text&quot; style=&quot;width: 300px&quot; class=&quot;post&quot; name=&quot;search_author&quot; size=&quot;30&quot; /&gt;&lt;/td&gt;
-	&lt;/tr&gt;
-	&lt;tr&gt; 
-		&lt;td class=&quot;row1&quot; colspan=&quot;2&quot;&gt;&lt;b class=&quot;genmed&quot;&gt;{ $L_SEARCH_FORUMS }: &lt;/b&gt;&lt;br /&gt;&lt;span class=&quot;gensmall&quot;&gt;{ $L_SEARCH_FORUMS_EXPLAIN }&lt;/span&gt;&lt;/td&gt;
-		&lt;td class=&quot;row2&quot; colspan=&quot;2&quot;&gt;&lt;select name=&quot;search_forum[]&quot; multiple=&quot;multiple&quot; style=&quot;min-width: 200px&quot; size=&quot;5&quot;&gt;{ $S_FORUM_OPTIONS }&lt;/select&gt;&lt;/td&gt;
-	&lt;/tr&gt;
-	&lt;tr&gt; 
-		&lt;th colspan=&quot;4&quot;&gt;{ $L_SEARCH_OPTIONS }&lt;/th&gt;
-	&lt;/tr&gt;
-	&lt;tr&gt; 
-		&lt;td class=&quot;row1&quot; width=&quot;25%&quot; nowrap=&quot;nowrap&quot;&gt;&lt;b class=&quot;genmed&quot;&gt;{ $L_SEARCH_SUBFORUMS }: &lt;/b&gt;&lt;/td&gt;
-		&lt;td class=&quot;row2&quot; width=&quot;25%&quot; nowrap=&quot;nowrap&quot;&gt;&lt;input type=&quot;radio&quot; name=&quot;search_child&quot; value=&quot;1&quot; checked=&quot;checked&quot; /&gt; &lt;span class=&quot;genmed&quot;&gt;{ $L_YES }&lt;/span&gt;&nbsp;&nbsp;&lt;input type=&quot;radio&quot; name=&quot;search_child&quot; value=&quot;0&quot; /&gt; &lt;span class=&quot;genmed&quot;&gt;{ $L_NO }&lt;/span&gt;&lt;/td&gt;
-		&lt;td class=&quot;row1&quot; width=&quot;25%&quot; nowrap=&quot;nowrap&quot;&gt;&lt;b class=&quot;genmed&quot;&gt;{ $L_SEARCH_WITHIN }: &lt;/b&gt;&lt;/td&gt;
-		&lt;td class=&quot;row2&quot; width=&quot;25%&quot; nowrap=&quot;nowrap&quot;&gt;&lt;input type=&quot;radio&quot; name=&quot;search_fields&quot; value=&quot;all&quot; checked=&quot;checked&quot; /&gt; &lt;span class=&quot;genmed&quot;&gt;{ $L_SEARCH_TITLE_MSG }&lt;/span&gt;&lt;br /&gt;&lt;input type=&quot;radio&quot; name=&quot;search_fields&quot; value=&quot;msgonly&quot; /&gt; &lt;span class=&quot;genmed&quot;&gt;{ $L_SEARCH_MSG_ONLY }&lt;/span&gt; &lt;br /&gt;&lt;input type=&quot;radio&quot; name=&quot;search_fields&quot; value=&quot;titleonly&quot; /&gt; &lt;span class=&quot;genmed&quot;&gt;{ $L_SEARCH_TITLE_ONLY }&lt;/span&gt;&lt;/td&gt;
-	&lt;/tr&gt;
-	&lt;tr&gt;
-		&lt;td class=&quot;row1&quot;&gt;&lt;b class=&quot;genmed&quot;&gt;{ $L_RESULT_SORT }: &lt;/b&gt;&lt;/td&gt;
-		&lt;td class=&quot;row2&quot; nowrap=&quot;nowrap&quot;&gt;{ $S_SELECT_SORT_KEY }&lt;br /&gt;&lt;input type=&quot;radio&quot; name=&quot;sd&quot; value=&quot;a&quot; /&gt; &lt;span class=&quot;genmed&quot;&gt;{ $L_SORT_ASCENDING }&lt;/span&gt;&lt;br /&gt;&lt;input type=&quot;radio&quot; name=&quot;sd&quot; value=&quot;d&quot; checked=&quot;checked&quot; /&gt; &lt;span class=&quot;genmed&quot;&gt;{ $L_SORT_DESCENDING }&lt;/span&gt;&lt;/td&gt;
-		&lt;td class=&quot;row1&quot; nowrap=&quot;nowrap&quot;&gt;&lt;b class=&quot;genmed&quot;&gt;{ $L_DISPLAY_RESULTS }: &lt;/b&gt;&lt;/td&gt;
-		&lt;td class=&quot;row2&quot; nowrap=&quot;nowrap&quot;&gt;&lt;input type=&quot;radio&quot; name=&quot;show_results&quot; value=&quot;posts&quot; /&gt; &lt;span class=&quot;genmed&quot;&gt;{ $L_POSTS }&lt;/span&gt;&nbsp;&nbsp;&lt;input type=&quot;radio&quot; name=&quot;show_results&quot; value=&quot;topics&quot; checked=&quot;checked&quot; /&gt; &lt;span class=&quot;genmed&quot;&gt;{ $L_TOPICS }&lt;/td&gt;
-	&lt;/tr&gt;
-	&lt;tr&gt; 
-		&lt;td class=&quot;row1&quot; width=&quot;25%&quot;&gt;&lt;b class=&quot;genmed&quot;&gt;{ $L_RESULT_DAYS }: &lt;/b&gt;&lt;/td&gt;
-		&lt;td class=&quot;row2&quot; width=&quot;25%&quot; nowrap=&quot;nowrap&quot;&gt;{ $S_SELECT_SORT_DAYS }&lt;/td&gt;
-		&lt;td class=&quot;row1&quot; nowrap=&quot;nowrap&quot;&gt;&lt;b class=&quot;genmed&quot;&gt;{ $L_RETURN_FIRST }: &lt;/b&gt;&lt;/td&gt;
-		&lt;td class=&quot;row2&quot; nowrap=&quot;nowrap&quot;&gt;&lt;select name=&quot;return_chars&quot;&gt;{ $S_CHARACTER_OPTIONS }&lt;/select&gt; &lt;span class=&quot;genmed&quot;&gt;{ $L_POST_CHARACTERS }&lt;/span&gt;&lt;/td&gt;
-	&lt;/tr&gt;
-	&lt;tr&gt; 
-		&lt;td class=&quot;cat&quot; colspan=&quot;4&quot; align=&quot;center&quot;&gt;&lt;input class=&quot;btnlite&quot; type=&quot;submit&quot; value=&quot;{ $L_SEARCH }&quot; /&gt;&nbsp;&nbsp;&lt;input class=&quot;btnlite&quot; type=&quot;reset&quot; value=&quot;{ $L_RESET }&quot; /&gt;&lt;/td&gt;
-	&lt;/tr&gt;
-&lt;/table&gt;&lt;/form&gt;
+&lt;form method=&quot;post&quot; action=&quot;{ $S_SEARCH_ACTION }&quot;&gt;
+	&lt;table class=&quot;tablebg&quot; width=&quot;100%&quot; cellspacing=&quot;1&quot;&gt;
+		&lt;tr&gt; 
+			&lt;th colspan=&quot;4&quot;&gt;{ $L_SEARCH_QUERY }&lt;/th&gt;
+		&lt;/tr&gt;
+		&lt;tr&gt; 
+			&lt;td class=&quot;row1&quot; colspan=&quot;2&quot; width=&quot;50%&quot;&gt;&lt;b class=&quot;genmed&quot;&gt;{ $L_SEARCH_KEYWORDS }: &lt;/b&gt;&lt;br /&gt;&lt;span class=&quot;gensmall&quot;&gt;{ $L_SEARCH_KEYWORDS_EXPLAIN }&lt;/span&gt;&lt;/td&gt;
+			&lt;td class=&quot;row2&quot; colspan=&quot;2&quot; valign=&quot;top&quot;&gt;&lt;input type=&quot;text&quot; style=&quot;width: 300px&quot; class=&quot;post&quot; name=&quot;search_keywords&quot; size=&quot;30&quot; /&gt;&lt;br /&gt;&lt;input type=&quot;radio&quot; name=&quot;search_terms&quot; value=&quot;all&quot; checked=&quot;checked&quot; /&gt; &lt;span class=&quot;genmed&quot;&gt;{ $L_SEARCH_ALL_TERMS }&lt;/span&gt;&lt;br /&gt;&lt;input type=&quot;radio&quot; name=&quot;search_terms&quot; value=&quot;any&quot; /&gt; &lt;span class=&quot;genmed&quot;&gt;{ $L_SEARCH_ANY_TERMS }&lt;/span&gt;&lt;/td&gt;
+		&lt;/tr&gt;
+		&lt;tr&gt; 
+			&lt;td class=&quot;row1&quot; colspan=&quot;2&quot;&gt;&lt;b class=&quot;genmed&quot;&gt;{ $L_SEARCH_AUTHOR }:&lt;/b&gt;&lt;br /&gt;&lt;span class=&quot;gensmall&quot;&gt;{ $L_SEARCH_AUTHOR_EXPLAIN }&lt;/span&gt;&lt;/td&gt;
+			&lt;td class=&quot;row2&quot; colspan=&quot;2&quot; valign=&quot;middle&quot;&gt;&lt;input type=&quot;text&quot; style=&quot;width: 300px&quot; class=&quot;post&quot; name=&quot;search_author&quot; size=&quot;30&quot; /&gt;&lt;/td&gt;
+		&lt;/tr&gt;
+		&lt;tr&gt; 
+			&lt;td class=&quot;row1&quot; colspan=&quot;2&quot;&gt;&lt;b class=&quot;genmed&quot;&gt;{ $L_SEARCH_FORUMS }: &lt;/b&gt;&lt;br /&gt;&lt;span class=&quot;gensmall&quot;&gt;{ $L_SEARCH_FORUMS_EXPLAIN }&lt;/span&gt;&lt;/td&gt;
+			&lt;td class=&quot;row2&quot; colspan=&quot;2&quot;&gt;&lt;select name=&quot;search_forum[]&quot; multiple=&quot;multiple&quot; style=&quot;min-width: 200px&quot; size=&quot;5&quot;&gt;{ $S_FORUM_OPTIONS }&lt;/select&gt;&lt;/td&gt;
+		&lt;/tr&gt;
+		&lt;tr&gt; 
+			&lt;th colspan=&quot;4&quot;&gt;{ $L_SEARCH_OPTIONS }&lt;/th&gt;
+		&lt;/tr&gt;
+		&lt;tr&gt; 
+			&lt;td class=&quot;row1&quot; width=&quot;25%&quot; nowrap=&quot;nowrap&quot;&gt;&lt;b class=&quot;genmed&quot;&gt;{ $L_SEARCH_SUBFORUMS }: &lt;/b&gt;&lt;/td&gt;
+			&lt;td class=&quot;row2&quot; width=&quot;25%&quot; nowrap=&quot;nowrap&quot;&gt;&lt;input type=&quot;radio&quot; name=&quot;search_child&quot; value=&quot;1&quot; checked=&quot;checked&quot; /&gt; &lt;span class=&quot;genmed&quot;&gt;{ $L_YES }&lt;/span&gt;&nbsp;&nbsp;&lt;input type=&quot;radio&quot; name=&quot;search_child&quot; value=&quot;0&quot; /&gt; &lt;span class=&quot;genmed&quot;&gt;{ $L_NO }&lt;/span&gt;&lt;/td&gt;
+			&lt;td class=&quot;row1&quot; width=&quot;25%&quot; nowrap=&quot;nowrap&quot;&gt;&lt;b class=&quot;genmed&quot;&gt;{ $L_SEARCH_WITHIN }: &lt;/b&gt;&lt;/td&gt;
+			&lt;td class=&quot;row2&quot; width=&quot;25%&quot; nowrap=&quot;nowrap&quot;&gt;&lt;input type=&quot;radio&quot; name=&quot;search_fields&quot; value=&quot;all&quot; checked=&quot;checked&quot; /&gt; &lt;span class=&quot;genmed&quot;&gt;{ $L_SEARCH_TITLE_MSG }&lt;/span&gt;&lt;br /&gt;&lt;input type=&quot;radio&quot; name=&quot;search_fields&quot; value=&quot;msgonly&quot; /&gt; &lt;span class=&quot;genmed&quot;&gt;{ $L_SEARCH_MSG_ONLY }&lt;/span&gt; &lt;br /&gt;&lt;input type=&quot;radio&quot; name=&quot;search_fields&quot; value=&quot;titleonly&quot; /&gt; &lt;span class=&quot;genmed&quot;&gt;{ $L_SEARCH_TITLE_ONLY }&lt;/span&gt;&lt;/td&gt;
+		&lt;/tr&gt;
+		&lt;tr&gt;
+			&lt;td class=&quot;row1&quot;&gt;&lt;b class=&quot;genmed&quot;&gt;{ $L_RESULT_SORT }: &lt;/b&gt;&lt;/td&gt;
+			&lt;td class=&quot;row2&quot; nowrap=&quot;nowrap&quot;&gt;{ $S_SELECT_SORT_KEY }&lt;br /&gt;&lt;input type=&quot;radio&quot; name=&quot;sd&quot; value=&quot;a&quot; /&gt; &lt;span class=&quot;genmed&quot;&gt;{ $L_SORT_ASCENDING }&lt;/span&gt;&lt;br /&gt;&lt;input type=&quot;radio&quot; name=&quot;sd&quot; value=&quot;d&quot; checked=&quot;checked&quot; /&gt; &lt;span class=&quot;genmed&quot;&gt;{ $L_SORT_DESCENDING }&lt;/span&gt;&lt;/td&gt;
+			&lt;td class=&quot;row1&quot; nowrap=&quot;nowrap&quot;&gt;&lt;b class=&quot;genmed&quot;&gt;{ $L_DISPLAY_RESULTS }: &lt;/b&gt;&lt;/td&gt;
+			&lt;td class=&quot;row2&quot; nowrap=&quot;nowrap&quot;&gt;&lt;input type=&quot;radio&quot; name=&quot;show_results&quot; value=&quot;posts&quot; /&gt; &lt;span class=&quot;genmed&quot;&gt;{ $L_POSTS }&lt;/span&gt;&nbsp;&nbsp;&lt;input type=&quot;radio&quot; name=&quot;show_results&quot; value=&quot;topics&quot; checked=&quot;checked&quot; /&gt; &lt;span class=&quot;genmed&quot;&gt;{ $L_TOPICS }&lt;/td&gt;
+		&lt;/tr&gt;
+		&lt;tr&gt; 
+			&lt;td class=&quot;row1&quot; width=&quot;25%&quot;&gt;&lt;b class=&quot;genmed&quot;&gt;{ $L_RESULT_DAYS }: &lt;/b&gt;&lt;/td&gt;
+			&lt;td class=&quot;row2&quot; width=&quot;25%&quot; nowrap=&quot;nowrap&quot;&gt;{ $S_SELECT_SORT_DAYS }&lt;/td&gt;
+			&lt;td class=&quot;row1&quot; nowrap=&quot;nowrap&quot;&gt;&lt;b class=&quot;genmed&quot;&gt;{ $L_RETURN_FIRST }: &lt;/b&gt;&lt;/td&gt;
+			&lt;td class=&quot;row2&quot; nowrap=&quot;nowrap&quot;&gt;&lt;select name=&quot;return_chars&quot;&gt;{ $S_CHARACTER_OPTIONS }&lt;/select&gt; &lt;span class=&quot;genmed&quot;&gt;{ $L_POST_CHARACTERS }&lt;/span&gt;&lt;/td&gt;
+		&lt;/tr&gt;
+		&lt;tr&gt; 
+			&lt;td class=&quot;cat&quot; colspan=&quot;4&quot; align=&quot;center&quot;&gt;&lt;input class=&quot;btnlite&quot; type=&quot;submit&quot; value=&quot;{ $L_SEARCH }&quot; /&gt;&nbsp;&nbsp;&lt;input class=&quot;btnlite&quot; type=&quot;reset&quot; value=&quot;{ $L_RESET }&quot; /&gt;&lt;/td&gt;
+		&lt;/tr&gt;
+	&lt;/table&gt;
+&lt;/form&gt;
 
 &lt;br clear=&quot;all&quot; /&gt;
 
@@ -51,15 +53,14 @@
 		&lt;th colspan=&quot;2&quot;&gt;{ $L_RECENT_SEARCHES }&lt;/th&gt;
 	&lt;/tr&gt;
 	&lt;!-- LOOP $recentsearch --&gt;
-
-	&lt;!-- IF { $recentsearch:#index } % 2 --&gt;
-	&lt;tr class=&quot;row2&quot;&gt;
-	&lt;!-- ELSE --&gt;
-	&lt;tr class=&quot;row1&quot;&gt;
-	&lt;!-- ENDIF --&gt;
-		&lt;td class=&quot;genmed&quot; style=&quot;padding: 4px;&quot; width=&quot;70%&quot;&gt;&lt;a href=&quot;{ $recentsearch:U_KEYWORDS }&quot;&gt;{ $recentsearch:KEYWORDS }&lt;/a&gt;&lt;/td&gt;
-		&lt;td class=&quot;genmed&quot; style=&quot;padding: 4px;&quot; width=&quot;30%&quot; align=&quot;center&quot;&gt;{ $recentsearch:TIME}&lt;/td&gt;
-	&lt;/tr&gt;
+		&lt;!-- IF { $recentsearch:#LOOP_INDEX } % 2 --&gt;
+		&lt;tr class=&quot;row2&quot;&gt;
+		&lt;!-- ELSE --&gt;
+		&lt;tr class=&quot;row1&quot;&gt;
+		&lt;!-- ENDIF --&gt;
+			&lt;td class=&quot;genmed&quot; style=&quot;padding: 4px;&quot; width=&quot;70%&quot;&gt;&lt;a href=&quot;{ $recentsearch:U_KEYWORDS }&quot;&gt;{ $recentsearch:KEYWORDS }&lt;/a&gt;&lt;/td&gt;
+			&lt;td class=&quot;genmed&quot; style=&quot;padding: 4px;&quot; width=&quot;30%&quot; align=&quot;center&quot;&gt;{ $recentsearch:TIME }&lt;/td&gt;
+		&lt;/tr&gt;
 	&lt;!-- LOOPELSE --&gt;
 	&lt;tr&gt;
 		&lt;td class=&quot;row1&quot; colspan=&quot;2&quot; align=&quot;center&quot;&gt;&lt;span class=&quot;genmed&quot;&gt;{ $L_NO_RECENT_SEARCHES }&lt;/span&gt;&lt;/td&gt;
@@ -79,9 +80,14 @@
 &lt;/table&gt;
 
 &lt;br clear=&quot;all&quot; /&gt;
+&lt;!-- IF { $S_DISPLAY_JUMPBOX } --&gt;
+&lt;div style=&quot;float:right&quot;&gt;
+&lt;!-- INCLUDE modules/Forums/jumpbox.html --&gt;
+&lt;/div&gt;
+&lt;!-- ENDIF --&gt;
+
+&lt;br clear=&quot;all&quot; /&gt;
 
-&lt;div style=&quot;float:right&quot;&gt;&lt;!-- IF { $S_DISPLAY_JUMPBOX } --&gt;&lt;!-- INCLUDE modules/Forums/jumpbox.html --&gt;&lt;!-- ENDIF --&gt;&lt;/div&gt;
-
 &lt;!-- INCLUDE modules/Forums/overall_footer.html --&gt;
 
 &lt;!-- DISPLAY_FOOTER --&gt;
\ No newline at end of file

Modified: cms/trunk/includes/templates/modules/Forums/search_results.html
===================================================================
--- cms/trunk/includes/templates/modules/Forums/search_results.html	2005-09-20 21:46:50 UTC (rev 136)
+++ cms/trunk/includes/templates/modules/Forums/search_results.html	2005-09-21 03:53:30 UTC (rev 137)
@@ -1,3 +1,5 @@
+&lt;!-- DISPLAY_HEADER --&gt;
+
 &lt;!-- INCLUDE modules/Forums/overall_header.html --&gt;
 
 &lt;form method=&quot;post&quot; action=&quot;{ $S_SEARCH_ACTION }&quot;&gt;
@@ -37,12 +39,12 @@
 		&lt;/td&gt;
 		&lt;td class=&quot;row1&quot;&gt;
 			&lt;!-- IF { $searchresults:S_TOPIC_UNAPPROVED } --&gt;
-				&lt;a href=&quot;{ $topicrow.U_MCP_QUEUE}&quot;&gt;{ $UNAPPROVED_IMG }&lt;/a&gt;&nbsp;
+				&lt;a href=&quot;{ $searchresults.U_MCP_QUEUE}&quot;&gt;{ $UNAPPROVED_IMG }&lt;/a&gt;&nbsp;
 			&lt;!-- ENDIF --&gt;
 			&lt;!-- IF { $searchresults:S_TOPIC_REPORTED } --&gt;
-				&lt;a href=&quot;{ $topicrow.U_MCP_REPORT}&quot;&gt;{ $REPORTED_IMG }&lt;/a&gt;&nbsp;
+				&lt;a href=&quot;{ $searchresults.U_MCP_REPORT}&quot;&gt;{ $REPORTED_IMG }&lt;/a&gt;&nbsp;
 			&lt;!-- ENDIF --&gt;
-			&lt;p class=&quot;topictitle&quot;&gt; { $topicrow:ATTACH_ICON_IMG } &lt;a href=&quot;{ $searchresults:U_VIEW_TOPIC }&quot;&gt;{ $searchresults:TOPIC_TITLE }&lt;/a&gt;&lt;/p&gt;
+			&lt;p class=&quot;topictitle&quot;&gt; { $searchresults:ATTACH_ICON_IMG } &lt;a href=&quot;{ $searchresults:U_VIEW_TOPIC }&quot;&gt;{ $searchresults:TOPIC_TITLE }&lt;/a&gt;&lt;/p&gt;
 			&lt;!-- IF { $searchresults:PAGINATION } --&gt;
 				&lt;p class=&quot;gensmall&quot;&gt; [ { $GOTO_PAGE_IMG }{ $L_GOTO_PAGE }: { $searchresults:PAGINATION } ] &lt;/p&gt;
 			&lt;!-- ENDIF --&gt;
@@ -87,7 +89,7 @@
 		&lt;td align=&quot;center&quot; valign=&quot;middle&quot;&gt;&lt;b class=&quot;postauthor&quot;&gt;{ $searchresults:POSTER_NAME }&lt;/b&gt;&lt;/td&gt;
 		&lt;td height=&quot;25&quot;&gt;&lt;table width=&quot;100%&quot; cellspacing=&quot;0&quot; cellpadding=&quot;0&quot; border=&quot;0&quot;&gt;
 			&lt;tr&gt;
-				&lt;td class=&quot;gensmall&quot;&gt;&lt;div style=&quot;float:left&quot;&gt;&nbsp;&lt;b&gt;{ $L_POST_SUBJECT }:&lt;/b&gt; &lt;a href=&quot;{ $searchresults:U_VIEW_POST }&quot;&gt;{ $searchresults:POST_SUBJECT }&lt;/a&gt;&lt;/div&gt;&lt;div style=&quot;float:right&quot;&gt;&lt;a href=&quot;{ $searchresults:U_VIEW_POST}&quot;&gt;{ $searchresults:MINI_POST_IMG }&lt;/a&gt;&lt;b&gt;{ $L_POSTED }:&lt;/b&gt; { $searchresults:POST_DATE }&nbsp;&lt;/div&gt;&lt;/td&gt;
+				&lt;td class=&quot;gensmall&quot;&gt;&lt;div style=&quot;float:left&quot;&gt;&nbsp;&lt;b&gt;{ $L_POST_SUBJECT }:&lt;/b&gt; &lt;a href=&quot;{ $searchresults:U_VIEW_POST }&quot;&gt;{ $searchresults:POST_SUBJECT }&lt;/a&gt;&lt;/div&gt;&lt;div style=&quot;float:right&quot;&gt;&lt;a href=&quot;{ $searchresults:U_VIEW_POST}&quot;&gt;&lt;/a&gt;&lt;b&gt;{ $L_POSTED }:&lt;/b&gt; { $searchresults:POST_DATE }&nbsp;&lt;/div&gt;&lt;/td&gt;
 			&lt;/tr&gt;
 		&lt;/table&gt;&lt;/td&gt;
 	&lt;/tr&gt;
@@ -116,7 +118,7 @@
 
 &lt;/form&gt;
 
-&lt;div class=&quot;nav&quot; style=&quot;float:left&quot;&gt;&lt;!-- IF { $PAGINATION } --&gt;{ $PAGE_NUMBER }&nbsp;[ { $TOTAL_MATCHES } ]&lt;!-- ENDIF --&gt;&nbsp;&lt;/div&gt;&lt;div class=&quot;nav&quot; style=&quot;float:right&quot;&gt;&lt;!-- IF { $PAGINATION } --&gt;&lt;b&gt;&lt;a href=&quot;javascript:jumpto();&quot;&gt;{ $L_GOTO_PAGE }&lt;/a&gt; &lt;!-- IF { $PREVIOUS_PAGE } --&gt;&lt;a href=&quot;{ $PREVIOUS_PAGE }&quot;&gt;{ $L_PREVIOUS }&lt;/a&gt;&nbsp;&nbsp;&lt;!-- ENDIF --&gt;{ $PAGINATION }&lt;!-- IF { $NEXT_PAGE } --&gt;&nbsp;&nbsp;&lt;a href=&quot;{ $NEXT_PAGE }&quot;&gt;{ $L_NEXT }&lt;/a&gt;&lt;!-- ENDIF --&gt;&lt;/b&gt;&lt;!-- ENDIF --&gt;&lt;/div&gt;
+&lt;div class=&quot;nav&quot; style=&quot;float:left&quot;&gt;&lt;!-- IF { $PAGINATION } --&gt;{ $PAGE_NUMBER }&nbsp;[ { $TOTAL_MATCHES } ]&lt;!-- ENDIF --&gt;&nbsp;&lt;/div&gt;&lt;div class=&quot;nav&quot; style=&quot;float:right&quot;&gt;&lt;!-- IF { $PAGINATION } --&gt;&lt;b&gt;&lt;a href=&quot;javascript:jumpto();&quot;&gt;{ $L_GOTO_PAGE }&lt;/a&gt;{ $PAGINATION }&lt;/b&gt;&lt;!-- ENDIF --&gt;&lt;/div&gt;
 
 &lt;br clear=&quot;all&quot; /&gt;&lt;br /&gt;
 
@@ -130,4 +132,6 @@
 
 &lt;div style=&quot;float:right&quot;&gt;&lt;!-- IF { $S_DISPLAY_JUMPBOX } --&gt;&lt;!-- INCLUDE modules/Forums/jumpbox.html --&gt;&lt;!-- ENDIF --&gt;&lt;/div&gt;
 
-&lt;!-- INCLUDE modules/Forums/overall_footer.html --&gt;
\ No newline at end of file
+&lt;!-- INCLUDE modules/Forums/overall_footer.html --&gt;
+
+&lt;!-- DISPLAY_FOOTER --&gt;
\ No newline at end of file

Added: cms/trunk/includes/templates/modules/google_search/index.html
===================================================================
--- cms/trunk/includes/templates/modules/google_search/index.html	2005-09-20 21:46:50 UTC (rev 136)
+++ cms/trunk/includes/templates/modules/google_search/index.html	2005-09-21 03:53:30 UTC (rev 137)
@@ -0,0 +1,58 @@
+&lt;!-- DISPLAY_HEADER --&gt;
+
+{ $A_TABLE_OPEN }
+
+&lt;form method=&quot;post&quot; action=&quot;&quot;&gt;
+	&lt;input name=&quot;q&quot; size=&quot;15&quot; maxlength=&quot;200&quot; value=&quot;&quot; type=&quot;text&quot; /&gt; &lt;input class=&quot;button&quot; name=&quot;submit&quot; value=&quot;Search&quot; type=&quot;submit&quot; /&gt;
+&lt;/form&gt;
+	
+&lt;table class=&quot;tablebg&quot; width=&quot;100%&quot; cellpadding=&quot;1&quot; cellspacing=&quot;1&quot;&gt;
+	&lt;tbody&gt;
+		&lt;!-- IF { $google_pagination } --&gt;
+		&lt;tr class=&quot;row2&quot;&gt;
+			&lt;td style=&quot;padding: 5px;&quot; valign=&quot;middle&quot; colspan=&quot;2&quot;&gt;
+				&lt;div style=&quot;padding-right: 5px; text-align: right;&quot;&gt;{ $google_pagination }&lt;/div&gt;
+			&lt;/td&gt;
+		&lt;/tr&gt;
+		&lt;!-- ENDIF --&gt;
+		&lt;tr&gt;
+			&lt;td class=&quot;spacer&quot; colspan=&quot;2&quot; height=&quot;7&quot;&gt;&lt;/td&gt;
+		&lt;/tr&gt;
+		&lt;!-- LOOP $google_result --&gt;
+		&lt;tr&gt;
+			&lt;td align=&quot;center&quot; class=&quot;row1&quot;&gt;
+				&lt;b&gt;{ $google_result:num }&lt;/b&gt;
+			&lt;/td&gt;
+			&lt;td class=&quot;row1&quot;&gt;
+				&lt;a href=&quot;{ $google_result:url } &quot;&gt;&lt;b&gt;{ $google_result:title }&lt;/b&gt;&lt;/a&gt;
+			&lt;/td&gt;
+		&lt;/tr&gt;
+		&lt;tr&gt;
+			&lt;td colspan=&quot;2&quot; class=&quot;row1&quot;&gt;
+				&lt;p&gt;{ $google_result:snippet }&lt;/p&gt;
+			&lt;/td&gt;
+		&lt;/tr&gt;
+		&lt;tr&gt;
+			&lt;td class=&quot;spacer&quot; colspan=&quot;2&quot; height=&quot;7&quot;&gt;&lt;/td&gt;
+		&lt;/tr&gt;
+		&lt;!-- LOOPELSE --&gt;
+		&lt;tr class=&quot;row2&quot;&gt;
+			&lt;td align=&quot;center&quot; colspan=&quot;2&quot;&gt;
+				{ $L_RESULTS_FOUND }
+			&lt;/td&gt;
+		&lt;/tr&gt;
+		&lt;!-- ENDLOOP --&gt;
+
+		&lt;!-- IF { $google_pagination } --&gt;
+		&lt;tr class=&quot;row2&quot;&gt;
+			&lt;td style=&quot;padding: 5px;&quot; valign=&quot;middle&quot; colspan=&quot;2&quot;&gt;
+				&lt;div style=&quot;padding-right: 5px; text-align: right;&quot;&gt;{ $google_pagination }&lt;/div&gt;
+			&lt;/td&gt;
+		&lt;/tr&gt;
+		&lt;!-- ENDIF --&gt;
+	&lt;/tbody&gt;
+&lt;/table&gt;
+
+{ $A_TABLE_CLOSE }
+
+&lt;!-- DISPLAY_FOOTER --&gt;
\ No newline at end of file

Modified: cms/trunk/install/build_data.php
===================================================================
--- cms/trunk/install/build_data.php	2005-09-20 21:46:50 UTC (rev 136)
+++ cms/trunk/install/build_data.php	2005-09-21 03:53:30 UTC (rev 137)
@@ -46,7 +46,7 @@
 
 $_CLASS['core_db']-&gt;query('INSERT INTO '.$table_prefix.&quot;config (config_section, config_name, config_value, config_cache) VALUES ('email', 'allow_html_email', '1', 1)&quot;);
 $_CLASS['core_db']-&gt;query('INSERT INTO '.$table_prefix.&quot;config (config_section, config_name, config_value, config_cache) VALUES ('email', 'email_enable', '1', 1)&quot;);
-$_CLASS['core_db']-&gt;query('INSERT INTO '.$table_prefix.&quot;config (config_section, config_name, config_value, config_cache) VALUES ('email', 'email_function_name', 'mb_mail', 1)&quot;);
+$_CLASS['core_db']-&gt;query('INSERT INTO '.$table_prefix.&quot;config (config_section, config_name, config_value, config_cache) VALUES ('email', 'email_function_name', 'mail', 1)&quot;);
 $_CLASS['core_db']-&gt;query('INSERT INTO '.$table_prefix.&quot;config (config_section, config_name, config_value, config_cache) VALUES ('email', 'smtp', '', 1)&quot;);
 $_CLASS['core_db']-&gt;query('INSERT INTO '.$table_prefix.&quot;config (config_section, config_name, config_value, config_cache) VALUES ('email', 'smtp_host', '', 1)&quot;);
 $_CLASS['core_db']-&gt;query('INSERT INTO '.$table_prefix.&quot;config (config_section, config_name, config_value, config_cache) VALUES ('email', 'smtp_port', '', 1)&quot;);

Modified: cms/trunk/install/build_tables.php
===================================================================
--- cms/trunk/install/build_tables.php	2005-09-20 21:46:50 UTC (rev 136)
+++ cms/trunk/install/build_tables.php	2005-09-21 03:53:30 UTC (rev 137)
@@ -959,4 +959,17 @@
 
 $_CLASS['core_db']-&gt;table_create('commit');
 
+
+$_CLASS['core_db']-&gt;table_create('start', $table_prefix.'forums_search_results');
+
+$_CLASS['core_db']-&gt;add_table_field_int('search_id', array('max' =&gt; 16000000));
+$_CLASS['core_db']-&gt;add_table_field_char('session_id', 40);
+field_unix_time('search_time', true);
+$_CLASS['core_db']-&gt;add_table_field_text('search_array', 16000000);
+
+$_CLASS['core_db']-&gt;add_table_index('search_id', 'primary');
+$_CLASS['core_db']-&gt;add_table_index('session_id', 'primary');
+
+$_CLASS['core_db']-&gt;table_create('commit');
+
 ?&gt;
\ No newline at end of file

Modified: cms/trunk/modules/Forums/admin/index.php
===================================================================
--- cms/trunk/modules/Forums/admin/index.php	2005-09-20 21:46:50 UTC (rev 136)
+++ cms/trunk/modules/Forums/admin/index.php	2005-09-21 03:53:30 UTC (rev 137)
@@ -49,9 +49,9 @@
 
 $_CLASS['core_blocks']-&gt;add_block($data);
 
-load_class($site_file_root.'includes/forums/auth.php', 'auth');
-require_once($site_file_root.'includes/forums/functions.php');
-require_once($site_file_root.'includes/forums/functions_admin.php');
+load_class(SITE_FILE_ROOT.'includes/forums/auth.php', 'auth');
+require_once(SITE_FILE_ROOT.'includes/forums/functions.php');
+require_once(SITE_FILE_ROOT.'includes/forums/functions_admin.php');
 
 $_CLASS['core_user']-&gt;add_lang('admin', 'Forums');
 //$_CLASS['core_user']-&gt;add_img(false, 'Forums');
@@ -59,13 +59,13 @@
 
 $file = get_variable('file', 'REQUEST', 'main');
 
-if (file_exists($site_file_root.'includes/forums/admin/'.$file.'.php'))
+if (file_exists(SITE_FILE_ROOT.'includes/forums/admin/'.$file.'.php'))
 {
-	require($site_file_root.'includes/forums/admin/'.$file.'.php');
+	require(SITE_FILE_ROOT.'includes/forums/admin/'.$file.'.php');
 }
 else
 {
-	require($site_file_root.'includes/forums/admin/main.php');
+	require(SITE_FILE_ROOT.'includes/forums/admin/main.php');
 }
 
 

Modified: cms/trunk/modules/Forums/ajax.php
===================================================================
--- cms/trunk/modules/Forums/ajax.php	2005-09-20 21:46:50 UTC (rev 136)
+++ cms/trunk/modules/Forums/ajax.php	2005-09-21 03:53:30 UTC (rev 137)
@@ -28,8 +28,8 @@
 
 header('Content-Type: text/html');
 
-require_once($site_file_root.'includes/forums/functions.php');
-load_class($site_file_root.'includes/forums/auth.php', 'auth');
+require_once(SITE_FILE_ROOT.'includes/forums/functions.php');
+load_class(SITE_FILE_ROOT.'includes/forums/auth.php', 'auth');
 
 $_CLASS['auth']-&gt;acl($_CLASS['core_user']-&gt;data);
 

Modified: cms/trunk/modules/Forums/index.php
===================================================================
--- cms/trunk/modules/Forums/index.php	2005-09-20 21:46:50 UTC (rev 136)
+++ cms/trunk/modules/Forums/index.php	2005-09-21 03:53:30 UTC (rev 137)
@@ -32,8 +32,8 @@
 
 unset($approved_files);
 
-require_once($site_file_root.'includes/forums/functions.php');
-load_class($site_file_root.'includes/forums/auth.php', 'auth');
+require_once(SITE_FILE_ROOT.'includes/forums/functions.php');
+load_class(SITE_FILE_ROOT.'includes/forums/auth.php', 'auth');
 
 $_CLASS['auth']-&gt;acl($_CLASS['core_user']-&gt;data);
 

Modified: cms/trunk/modules/Forums/main.php
===================================================================
--- cms/trunk/modules/Forums/main.php	2005-09-20 21:46:50 UTC (rev 136)
+++ cms/trunk/modules/Forums/main.php	2005-09-21 03:53:30 UTC (rev 137)
@@ -37,12 +37,12 @@
     die;
 }
 
-load_class($site_file_root.'includes/forums/auth.php', 'auth');
+load_class(SITE_FILE_ROOT.'includes/forums/auth.php', 'auth');
 
 $_CLASS['core_user']-&gt;user_setup();
 $_CLASS['core_user']-&gt;add_img();
 
-require($site_file_root.'includes/forums/functions_display.php');
+require(SITE_FILE_ROOT.'includes/forums/functions_display.php');
 display_forums('', $config['load_moderators']);
 
 // Grab group details for legend display

Modified: cms/trunk/modules/Forums/posting.php
===================================================================
--- cms/trunk/modules/Forums/posting.php	2005-09-20 21:46:50 UTC (rev 136)
+++ cms/trunk/modules/Forums/posting.php	2005-09-21 03:53:30 UTC (rev 137)
@@ -1258,7 +1258,7 @@
 
 		case 'delete_first_post':
 			$sql = 'SELECT p.post_id, p.poster_id, p.post_username, u.username 
-				FROM ' . FORUMS_POSTS_TABLE . ' p, ' . FORUMS_USERS_TABLE . &quot; u
+				FROM ' . FORUMS_POSTS_TABLE . ' p, ' . USERS_TABLE . &quot; u
 				WHERE p.topic_id = $topic_id 
 					AND p.poster_id = u.user_id 
 				ORDER BY p.post_time ASC&quot;;

Modified: cms/trunk/modules/Forums/search.php
===================================================================
--- cms/trunk/modules/Forums/search.php	2005-09-20 21:46:50 UTC (rev 136)
+++ cms/trunk/modules/Forums/search.php	2005-09-21 03:53:30 UTC (rev 137)
@@ -1,4 +1,26 @@
 &lt;?php
+/*
+||**************************************************************||
+||  Viperal CMS &#194;&#169; :												||
+||**************************************************************||
+||																||
+||	Copyright (C) 2004, 2005									||
+||  By Ryan Marshall ( Viperal )								||
+||																||
+||  Email: <A HREF="https://lists.berlios.de/mailman/listinfo/viperals-svncheckins">viperal1 at gmail.com</A>									||
+||  Site: <A HREF="http://www.viperal.com">http://www.viperal.com</A>								||
+||																||
+||**************************************************************||
+||	LICENSE: ( <A HREF="http://www.gnu.org/licenses/gpl.txt">http://www.gnu.org/licenses/gpl.txt</A> )			||
+||**************************************************************||
+||  Viperal CMS is released under the terms and conditions		||
+||  of the GNU General Public License version 2					||
+||																||
+||**************************************************************||
+
+$Id$
+*/
+
 // -------------------------------------------------------------
 //
 // $Id: search.php,v 1.108 2004/10/19 19:20:30 acydburn Exp $
@@ -46,7 +68,7 @@
 $search_child		= request_var('search_child', true);
 
 $return_chars	= request_var('return_chars', 200);
-$search_forum	= request_var('search_forum', 0);
+$search_forum	= request_var('search_forum', array(0));
 
 $sort_days	= request_var('st', 0);
 $sort_key	= request_var('sk', 't');
@@ -60,20 +82,20 @@
 gen_sort_selects($limit_days, $sort_by_text, $sort_days, $sort_key, $sort_dir, $s_limit_days, $s_sort_key, $s_sort_dir, $u_sort_param);
 
 $store_vars		= array('sort_key', 'sort_dir', 'sort_days', 'show_results', 'return_chars', 'total_match_count');
-$current_time	= time();
+$current_time	= $_CLASS['core_user']-&gt;time;
 $stopped_words	= array();
 
 // Check last search time ... if applicable
 if ($config['search_interval'])
 {
 	$sql = 'SELECT MAX(search_time) as last_time
-		FROM ' . SEARCH_TABLE.&quot;
-			WHERE session_id = '&quot; . $_CLASS['core_db']-&gt;escape($_CLASS['core_user']-&gt;data['session_id']) . '\'';
+		FROM ' . FORUMS_SEARCH_TABLE.&quot;
+			WHERE session_id = '&quot; . $_CLASS['core_db']-&gt;escape($_CLASS['core_user']-&gt;data['session_id']) . &quot;'&quot;;
 	$result = $_CLASS['core_db']-&gt;query($sql);
 
 	if ($row = $_CLASS['core_db']-&gt;fetch_row_assoc($result))
 	{
-		if ($row['last_time'] &gt; time() - $config['search_interval'])
+		if ($row['last_time'] &gt; $_CLASS['core_user']-&gt;time - $config['search_interval'])
 		{
 			trigger_error('NO_SEARCH_TIME');
 		}
@@ -84,74 +106,78 @@
 {
 	$post_id_ary = $split_words = $old_split_words = $common_words = array();
 
-	// Which forums can we view?
-	$sql_where = (sizeof($search_forum) &amp;&amp; !$search_child) ? 'WHERE forum_id IN (' . implode(', ', $search_forum) . ')' : '';
-	$sql = 'SELECT forum_id, forum_name, parent_id, forum_type, right_id, forum_password
-		FROM ' . FORUMS_TABLE . &quot;
-		$sql_where
-		ORDER BY left_id&quot;;
-	$result = $_CLASS['core_db']-&gt;query($sql);
+	$permission_array = array_keys($_CLASS['auth']-&gt;acl_getf('f_read'));
 
-	$right_id = 0;
-	$sql_forums = array();
-	while ($row = $_CLASS['core_db']-&gt;fetch_row_assoc($result))
+	if (!empty($search_forum))
 	{
-		if ($search_child)
+		$search_forum = array_unique($search_forum);
+		$difference = array_diff($search_forum, $permission_array);
+
+		// I'm sure theres a better way to do this, but it's close to midnight
+		if (!empty($difference))
 		{
-			if (!$search_forum || (in_array($row['forum_id'], $search_forum) &amp;&amp; $row['right_id'] &gt; $right_id))
+			$count = count($search_forum);
+			
+			for ($i = 0; $i &lt; $count; $i++)
 			{
-				$right_id = $row['right_id'];
+				if (!in_array($search_forum[$i], $difference))
+				{
+					$temp[] = $search_forum[$i];
+				}
 			}
-			elseif ($row['right_id'] &gt; $right_id)
-			{
-				continue;
-			}
-		}
+			$search_forum = $temp;
 
-// Fix password
-		if ($_CLASS['auth']-&gt;acl_get('f_read', $row['forum_id']) &amp;&amp; (!$row['forum_password']))
-		{
-			$sql_forums[] = $row['forum_id'];
+			unset($temp);
 		}
 	}
-	$_CLASS['core_db']-&gt;free_result($result);
+	else
+	{
+		$search_forum =&amp; $permission_array;
+	}
 
-	if (!sizeof($sql_forums))
+	if (empty($search_forum))
 	{
 		trigger_error('NO_SEARCH_RESULTS');
 	}
 
-	$sql_forums = ' AND p.forum_id IN (' . implode(', ', $sql_forums) . ')';
-	unset($search_forum);
+// This should be only intergers
+	$sql_forums = ' AND p.forum_id IN (' . implode(', ', $search_forum) . ')';
 
+	unset($search_forum, $permission_array);
 
-	if ($search_id == 'egosearch')
+	if ($search_id === 'egosearch')
 	{
 		$search_author = $_CLASS['core_user']-&gt;data['username'];
 	}
 
-
 	// Are we looking for a user?
 	$sql_author = '';
+
 	if ($search_author)
 	{
-		$sql_where = (strstr($search_author, '*') !== false) ? ' LIKE ' : ' = ';
+		$sql_where = (mb_strpos($search_author, '*') !== false) ? ' LIKE ' : ' = ';
+
 		$sql = 'SELECT user_id 
 			FROM ' . USERS_TABLE . &quot;
 			WHERE username $sql_where '&quot; . $_CLASS['core_db']-&gt;escape(preg_replace('#\*+#', '%', $search_author)) . &quot;'
-				AND user_type IN (&quot; . USER_NORMAL . ', ' . USER_FOUNDER . ')';
+				AND user_type = &quot; . USER_NORMAL;
 		$result = $_CLASS['core_db']-&gt;query($sql);
+		
+		
+		while ($row = $_CLASS['core_db']-&gt;fetch_row_assoc($result))
+		{
+			$sql_author[] = $row['user_id'];
+		}
+		$_CLASS['core_db']-&gt;free_result($result);
 
-		if (!$row = $_CLASS['core_db']-&gt;fetch_row_assoc($result))
+		if (empty($sql_author))
 		{
 			trigger_error('NO_SEARCH_RESULTS');
 		}
-		$_CLASS['core_db']-&gt;free_result($result);
 
-		$sql_author = ' p.poster_id = ' . $row['user_id'];
+		$sql_author = (count($sql_author) == 1) ?  ' p.poster_id = ' . $sql_author[0] : ' p.poster_id IN (' . implode(', ', $sql_author) . ')';
 	}
 
-	
 	if ($search_id)
 	{
 		switch ($search_id)
@@ -166,11 +192,11 @@
 					gen_sort_selects($limit_days, $sort_by_text, $sort_days, $sort_key, $sort_dir, $s_limit_days, $s_sort_key, $s_sort_dir, $u_sort_param);
 				}
 
-				$last_post_time = (gmtime() - ($sort_days * 24 * 3600));
+				$last_post_time = ($_CLASS['core_user']-&gt;time - ($sort_days * 24 * 3600));
 
 				$sql = 'SELECT DISTINCT t.topic_id
-					FROM ' . POSTS_TABLE . ' p
-					LEFT JOIN ' . TOPICS_TABLE . &quot; t ON (t.topic_approved = 1 AND p.topic_id = t.topic_id)
+					FROM ' . FORUMS_POSTS_TABLE . ' p
+					LEFT JOIN ' . FORUMS_TOPICS_TABLE . &quot; t ON (t.topic_approved = 1 AND p.topic_id = t.topic_id)
 					WHERE p.post_time &gt; $last_post_time
 						$sql_forums
 					ORDER BY t.topic_last_post_time DESC&quot;;
@@ -180,17 +206,22 @@
 				{
 					$post_id_ary[] = $row['topic_id'];
 				}
-				$_CLASS['core_db']-&gt;free_result($result);
-				break;
+				$_CLASS['core_db']-&gt;free_result($result);
 				
+				if (empty($post_id_ary))
+				{
+					trigger_error('NO_SEARCH_RESULTS');
+				}
+			break;
+				
 			case 'egosearch':
-				break;
+			break;
 
 			case 'unanswered':
 				if ($show_results == 'posts')
 				{
 					$sql = 'SELECT p.post_id 
-						FROM ' . POSTS_TABLE . ' p, ' . TOPICS_TABLE . &quot; t 
+						FROM ' . FORUMS_POSTS_TABLE . ' p, ' . FORUMS_TOPICS_TABLE . &quot; t 
 						WHERE t.topic_replies = 0
 							AND p.topic_id = t.topic_id
 							$sql_forums&quot;;
@@ -199,7 +230,7 @@
 				else
 				{
 					$sql = 'SELECT t.topic_id 
-						FROM ' . POSTS_TABLE . ' p, ' . TOPICS_TABLE . &quot; t 
+						FROM ' . FORUMS_POSTS_TABLE . ' p, ' . FORUMS_TOPICS_TABLE . &quot; t 
 						WHERE t.topic_replies = 0 
 							AND p.topic_id = t.topic_id
 							$sql_forums
@@ -214,17 +245,17 @@
 				}
 				$_CLASS['core_db']-&gt;free_result($result);
 
-				if (!sizeof($post_id_ary))
+				if (empty($post_id_ary))
 				{
 					trigger_error('NO_SEARCH_RESULTS');
 				}
-				break;
+			break;
 
 			case 'newposts':
 				if ($show_results == 'posts')
 				{
 					$sql = 'SELECT p.post_id 
-						FROM ' . POSTS_TABLE . ' p 
+						FROM ' . FORUMS_POSTS_TABLE . ' p 
 						WHERE p.post_time &gt; ' . $_CLASS['core_user']-&gt;data['user_last_visit'] . &quot;
 							$sql_forums&quot;;
 					$field = 'post_id';
@@ -232,7 +263,7 @@
 				else
 				{
 					$sql = 'SELECT t.topic_id
-						FROM ' . TOPICS_TABLE . ' t, ' . POSTS_TABLE . ' p 
+						FROM ' . FORUMS_TOPICS_TABLE . ' t, ' . FORUMS_POSTS_TABLE . ' p 
 						WHERE p.post_time &gt; ' . $_CLASS['core_user']-&gt;data['user_last_visit'] . &quot; 
 							AND t.topic_id = p.topic_id 
 							$sql_forums 
@@ -247,23 +278,25 @@
 				}
 				$_CLASS['core_db']-&gt;free_result($result);
 
-				if (!sizeof($post_id_ary))
+				if (empty($post_id_ary))
 				{
 					trigger_error('NO_SEARCH_RESULTS');
 				}
-				break;
+			break;
 		}
 	}
 	
 	if ($search_session_id)
 	{
 		$sql = 'SELECT search_array
-			FROM ' . SEARCH_TABLE . &quot;
+			FROM ' . FORUMS_SEARCH_TABLE . &quot;
 			WHERE search_id = $search_session_id
 				AND session_id = '&quot; . $_CLASS['core_db']-&gt;escape($_CLASS['core_user']-&gt;data['session_id']) . &quot;'&quot;;
 		$result = $_CLASS['core_db']-&gt;query($sql);
+		$row = $_CLASS['core_db']-&gt;fetch_row_assoc($result);
+		$_CLASS['core_db']-&gt;free_result($result);
 
-		if ($row = $_CLASS['core_db']-&gt;fetch_row_assoc($result))
+		if ($row)
 		{
 			$data = explode('#', $row['search_array']);
 
@@ -285,9 +318,11 @@
 			$sql_where = (($show_results == 'posts') ? 'p.post_id' : 't.topic_id') . ' IN (' . implode(', ', $data) . ')';
 			unset($data);
 		}
-		$_CLASS['core_db']-&gt;free_result($result);
+		else
+		{
+			$search_session_id = false;
+		}
 	}
-	// TODO: hook in fulltext_phpbb/mysql
 
 	// Are we looking for words
 	if ($search_keywords)
@@ -307,8 +342,9 @@
 		if ($fp = @fopen($_CLASS['core_user']-&gt;lang_path . '/search_synonyms.txt', 'rb'))
 		{
 			preg_match_all('#^(.*?) (.*?)$#ms', fread($fp, filesize($_CLASS['core_user']-&gt;lang_path . '/search_synonyms.txt')), $match);
-			$replace_synonym = &amp;$match[1];
-			$match_synonym = &amp;$match[2];
+			
+			$replace_synonym = $match[1];
+			$match_synonym = $match[2];
 		}
 		fclose($fp);
 
@@ -346,12 +382,12 @@
 		}
 	}
 
-	if (isset($old_split_words) &amp;&amp; sizeof($old_split_words))
+	if (!empty($old_split_words))
 	{
-		$split_words = (sizeof($split_words)) ? array_diff($split_words, $old_split_words) : $old_split_words;
+		$split_words = !empty($split_words) ? array_diff($split_words, $old_split_words) : $old_split_words;
 	}
-	
-	if (sizeof($split_words))
+
+	if (!empty($split_words))
 	{
 		// This &quot;entire&quot; section may be switched out to allow for alternative search systems
 		// such as that built-in to MySQL, MSSQL, etc. or external solutions which provide
@@ -359,23 +395,28 @@
 
 		$bool = ($search_terms == 'all') ? 'AND' : 'OR';
 		$sql_words = '';
+
 		foreach ($split_words as $word)
 		{
 			switch ($word)
 			{
 				case '-':
 					$bool = 'NOT';
-					continue;
+				break;
+
 				case '+':
 					$bool = 'AND';
-					continue;
+				break;
+
 				case '|':
 					$bool = 'OR';
-					continue;
+				break;
+
 				default:
 					$bool = ($search_terms != 'all') ? 'OR' : $bool;
 					$sql_words[$bool][] = &quot;'&quot; . preg_replace('#\*+#', '%', trim($word)) . &quot;'&quot;;
 					$bool = ($search_terms == 'all') ? 'AND' : 'OR';
+				break;
 			}
 		}
 
@@ -393,13 +434,14 @@
 
 		// Build some display specific variable strings
 		$sql_select = ($show_results == 'posts') ? 'm.post_id' : 'DISTINCT t.topic_id';
-		$sql_from = ($show_results == 'posts') ? '' : TOPICS_TABLE . ' t, ';
+		$sql_from = ($show_results == 'posts') ? '' : FORUMS_TOPICS_TABLE . ' t, ';
 		$sql_topic = ($show_results == 'posts') ? '' : 'AND t.topic_id = p.topic_id';
 		$sql_time = ($sort_days) ? 'AND p.post_time &gt;= ' . ($current_time - ($sort_days * 86400)) : '';
 		$field = ($show_results == 'posts') ? 'm.post_id' : 't.topic_id';
 
 		// Are we searching within an existing search set? Yes, then include the old ids
-		$sql_find_in = ($sql_where) ? &quot;AND $sql_where&quot; : '';
+		//$sql_find_in = ($sql_where) ? &quot;AND $sql_where&quot; : '';
+		$sql_find_in = '';
 
 		$result_ary = array();
 		foreach (array('AND', 'OR', 'NOT') as $bool)
@@ -422,7 +464,7 @@
 							$sql_and = (isset($result_ary['AND']) &amp;&amp; sizeof($result_ary['AND'])) ? &quot;AND $field IN (&quot; . implode(', ', $result_ary['AND']) . ')' : '';
 
 							$sql = &quot;SELECT $sql_select 
-								FROM $sql_from&quot; . POSTS_TABLE . ' p, ' . SEARCH_MATCH_TABLE . ' m, ' . SEARCH_WORD_TABLE . &quot; w 
+								FROM $sql_from&quot; . FORUMS_POSTS_TABLE . ' p, ' . FORUMS_SEARCH_MATCH_TABLE . ' m, ' . FORUMS_SEARCH_WORD_TABLE . &quot; w 
 								WHERE w.word_text $sql_where 
 									AND m.word_id = w.word_id 
 									AND w.word_common &lt;&gt; 1 
@@ -477,7 +519,7 @@
 
 						$sql_and = (sizeof($result_ary['AND'])) ? &quot;AND $field IN (&quot; . implode(', ', $result_ary['AND']) . ')' : '';
 						$sql = &quot;SELECT $sql_select 
-							FROM $sql_from&quot; . POSTS_TABLE . ' p, ' . SEARCH_MATCH_TABLE . ' m, ' . SEARCH_WORD_TABLE . &quot; w 
+							FROM $sql_from&quot; . FORUMS_POSTS_TABLE . ' p, ' . FORUMS_SEARCH_MATCH_TABLE . ' m, ' . FORUMS_SEARCH_WORD_TABLE . &quot; w 
 							WHERE ($sql_where) 
 								AND m.word_id = w.word_id 
 								AND w.word_common &lt;&gt; 1 
@@ -529,7 +571,7 @@
 		}
 
 		$sql = 'SELECT word_text 
-			FROM ' . SEARCH_WORD_TABLE . ' 
+			FROM ' . FORUMS_SEARCH_WORD_TABLE . ' 
 			WHERE word_text IN (' . implode(', ', array_unique(array_merge($sql_words['AND'], $sql_words['OR'], $sql_words['NOT']))) . ')
 				AND word_common = 1';
 		$result = $_CLASS['core_db']-&gt;query($sql);
@@ -540,12 +582,12 @@
 		}
 		$_CLASS['core_db']-&gt;free_result($result);
 	}
-	else if ($search_author)
+	elseif ($search_author)
 	{
-		if ($show_results == 'posts')
+		if ($show_results === 'posts')
 		{
 			$sql = 'SELECT p.post_id 
-				FROM ' . POSTS_TABLE . &quot; p 
+				FROM ' . FORUMS_POSTS_TABLE . &quot; p 
 				WHERE $sql_author 
 					$sql_forums&quot;;
 			$field = 'post_id';
@@ -553,7 +595,7 @@
 		else
 		{
 			$sql = 'SELECT t.topic_id 
-				FROM ' . TOPICS_TABLE . ' t, ' . POSTS_TABLE . &quot; p 
+				FROM ' . FORUMS_TOPICS_TABLE . ' t, ' . FORUMS_POSTS_TABLE . &quot; p 
 				WHERE $sql_author
 					$sql_forums
 					AND t.topic_id = p.topic_id 
@@ -569,32 +611,40 @@
 		$_CLASS['core_db']-&gt;free_result($result);
 	}
 
-
-	if ($post_id_ary &amp;&amp; sizeof($post_id_ary))
+	if (!empty($post_id_ary))
 	{
-		// Finish building query (for all combinations) and run it ...
+/*
+ Make uses of autoinsert for search_id
+ also rethink the why this is done, storing things more then one shouldn't be needed
+*/
 		$sql = 'SELECT session_id
-			FROM ' . SESSIONS_TABLE;
-		if ($result = $_CLASS['core_db']-&gt;query($sql))
+			FROM ' . SESSIONS_TABLE .&quot;
+			WHERE session_id &lt;&gt; '&quot; . $_CLASS['core_user']-&gt;data['session_id'] . &quot;'&quot;;
+		$result = $_CLASS['core_db']-&gt;query($sql);
+
+		$delete_search_ids = array();
+		while ($row = $_CLASS['core_db']-&gt;fetch_row_assoc($result))
 		{
-			$delete_search_ids = array();
-			while ($row = $_CLASS['core_db']-&gt;fetch_row_assoc($result))
-			{
-				$delete_search_ids[] = &quot;'&quot; . $_CLASS['core_db']-&gt;escape($row['session_id']) . &quot;'&quot;;
-			}
+			$delete_search_ids[] = &quot;'&quot; . $_CLASS['core_db']-&gt;escape($row['session_id']) . &quot;'&quot;;
+		}
 
-			if (sizeof($delete_search_ids))
-			{
-				$sql = 'DELETE FROM ' . SEARCH_TABLE . '
-					WHERE session_id NOT IN (' . implode(&quot;, &quot;, $delete_search_ids) . ')';
-				$_CLASS['core_db']-&gt;query($sql);
-			}
+		if (empty($delete_search_ids))
+		{
+			$_CLASS['core_db']-&gt;query('TRUNCATE ' . FORUMS_SEARCH_TABLE);
 		}
+		else
+		{
+			$sql = 'DELETE FROM ' . FORUMS_SEARCH_TABLE . '
+				WHERE session_id NOT IN (' . implode(', ', $delete_search_ids) . ')';
+			$_CLASS['core_db']-&gt;query($sql);
+		}
+		unset($delete_search_ids);
 
-		$total_match_count = sizeof($post_id_ary);
-		$sql_where = (($show_results == 'posts') ? 'p.post_id' : 't.topic_id') . ' IN (' . implode(', ', $post_id_ary) . ')';
+		$total_match_count = count($post_id_ary);
 
-		if (sizeof($old_split_words) &amp;&amp; array_diff($split_words, $old_split_words))
+		$sql_where = (($show_results === 'posts') ? 'p.post_id' : 't.topic_id') . ' IN (' . implode(', ', $post_id_ary) . ')';
+
+		if (!empty($old_split_words) &amp;&amp; array_diff($split_words, $old_split_words))
 		{
 			$split_words = array_merge($split_words, $old_split_words);
 		}
@@ -610,7 +660,6 @@
 		$data .= '#' . implode('#', $post_id_ary);
 		unset($post_id_ary);
 
-		srand ((double) microtime() * 1000000);
 		$search_session_id = rand();
 
 		$sql_ary = array(
@@ -620,12 +669,11 @@
 			'search_array'	=&gt; $data
 		);
 
-		$sql = 'INSERT INTO ' . SEARCH_TABLE . ' ' . $_CLASS['core_db']-&gt;sql_build_array('INSERT', $sql_ary);
-		$_CLASS['core_db']-&gt;query($sql);
+		$_CLASS['core_db']-&gt;query('INSERT INTO ' . FORUMS_SEARCH_TABLE . ' ' . $_CLASS['core_db']-&gt;sql_build_array('INSERT', $sql_ary));
 		unset($data);
 	}
 
-	if ($show_results == 'posts')
+	if ($show_results === 'posts')
 	{
 		require($site_file_root.'includes/forums/functions_posting.php');
 	}
@@ -635,11 +683,10 @@
 	}
 
 	// Look up data ...
-	$per_page = ($show_results == 'posts') ? $config['posts_per_page'] : $config['topics_per_page'];
+	$per_page = ($show_results === 'posts') ? $config['posts_per_page'] : $config['topics_per_page'];
 
 	// Grab icons
-	$icons = array();
-	obtain_icons($icons);
+	$icons = obtain_icons();
 
 	// Output header
 	$l_search_matches = ($total_match_count == 1) ? sprintf($_CLASS['core_user']-&gt;lang['FOUND_SEARCH_MATCH'], $total_match_count) : sprintf($_CLASS['core_user']-&gt;lang['FOUND_SEARCH_MATCHES'], $total_match_count);
@@ -649,11 +696,14 @@
 	$split_words = htmlspecialchars(implode(' ', $split_words));
 	$ignored_words = htmlspecialchars(implode(' ', $stopped_words));
 
-	$_CLASS['core_template']-&gt;assign(array(
+	$pagination = generate_pagination(&quot;Forums&amp;file=search&amp;search_session_id=$search_session_id&amp;search_id=$search_id&amp;hilit=$hilit&amp;$u_sort_param&quot;, $total_match_count, $per_page, $start);
+
+	$_CLASS['core_template']-&gt;assign_array(array(
 		'SEARCH_MATCHES'	=&gt; $l_search_matches,
 		'SEARCH_WORDS'		=&gt; $split_words, 
 		'IGNORED_WORDS'		=&gt; ($ignored_words) ? $ignored_words : '', 
-		'PAGINATION'		=&gt; generate_pagination(&quot;Forums&amp;file=search&amp;search_session_id=$search_session_id&amp;search_id=$search_id&amp;hilit=$hilit&amp;$u_sort_param&quot;, $total_match_count, $per_page, $start),
+		'PAGINATION'		=&gt; $pagination['formated'],
+		'PAGINATION_ARRAY'	=&gt; $pagination['array'],
 		'PAGE_NUMBER'		=&gt; on_page($total_match_count, $per_page, $start),
 		'TOTAL_MATCHES'		=&gt; $total_match_count,
 
@@ -695,7 +745,7 @@
 			$_CLASS['core_db']-&gt;free_result($result);
 	
 			$sql = 'SELECT p.*, f.forum_id, f.forum_name, t.*, u.username, u.user_sig, u.user_sig_bbcode_uid
-				FROM ' . FORUMS_TABLE . ' f, ' . TOPICS_TABLE . ' t, ' . USERS_TABLE . ' u, ' . POSTS_TABLE . &quot; p 
+				FROM ' . FORUMS_FORUMS_TABLE . ' f, ' . FORUMS_TOPICS_TABLE . ' t, ' . USERS_TABLE . ' u, ' . FORUMS_POSTS_TABLE . &quot; p 
 				WHERE $sql_where 
 					AND f.forum_id = p.forum_id
 					AND p.topic_id = t.topic_id
@@ -704,13 +754,14 @@
 		else
 		{
 			$sql = 'SELECT t.*, f.forum_id, f.forum_name
-				FROM ' . TOPICS_TABLE . ' t, ' . FORUMS_TABLE . &quot; f 
+				FROM ' . FORUMS_TOPICS_TABLE . ' t, ' . FORUMS_FORUMS_TABLE . &quot; f 
 				WHERE $sql_where 
 					AND f.forum_id = t.forum_id&quot;;
 		}
-		$sql .= ' ORDER BY ' . $sort_by_sql[$sort_key] . ' ' . (($sort_dir == 'd') ? 'DESC' : 'ASC') . &quot; LIMIT $start, $per_page&quot;;
-		$result = $_CLASS['core_db']-&gt;query($sql);
-	
+
+		$sql .= ' ORDER BY ' . $sort_by_sql[$sort_key] . ' ' . (($sort_dir == 'd') ? 'DESC' : 'ASC');
+		$result = $_CLASS['core_db']-&gt;query_limit($sql, $per_page, $start);
+
 		while ($row = $_CLASS['core_db']-&gt;fetch_row_assoc($result))
 		{
 			$forum_id = $row['forum_id'];
@@ -718,20 +769,23 @@
 	
 			$view_topic_url = &quot;Forums&amp;file=viewtopic&amp;f=$forum_id&amp;t=$topic_id&amp;hilit=$u_hilit&quot;;
 	
-			if ($show_results == 'topics')
+			if ($show_results === 'topics')
 			{
 				$replies = ($_CLASS['auth']-&gt;acl_get('m_approve', $forum_id)) ? $row['topic_replies_real'] : $row['topic_replies'];
 	
 				$folder_img = $folder_alt = $topic_type = '';
-				topic_status($row, $replies, time(), time(), $folder_img, $folder_alt, $topic_type);
-	
+				topic_status($row, $replies, $_CLASS['core_user']-&gt;time, $folder_img, $folder_alt, $topic_type);
+
+				$pagination = generate_pagination($view_topic_url, $replies, $config['posts_per_page'], 0);
+
 				$tpl_ary = array(
 					'TOPIC_AUTHOR' 		=&gt; topic_topic_author($row),
 					'FIRST_POST_TIME' 	=&gt; $_CLASS['core_user']-&gt;format_date($row['topic_time']),
 					'LAST_POST_TIME'	=&gt; $_CLASS['core_user']-&gt;format_date($row['topic_last_post_time']),
 					'LAST_VIEW_TIME'	=&gt; $_CLASS['core_user']-&gt;format_date($row['topic_last_view_time']),
 					'LAST_POST_AUTHOR' 	=&gt; ($row['topic_last_poster_name'] != '') ? $row['topic_last_poster_name'] : $_CLASS['core_user']-&gt;lang['GUEST'],
-					'PAGINATION' 		=&gt; topic_generate_pagination($replies, $view_topic_url),
+					'PAGINATION'		=&gt; $pagination['formated'],
+					'PAGINATION_ARRAY'	=&gt; $pagination['array'],
 					'REPLIES' 			=&gt; $replies,
 					'VIEWS' 			=&gt; $row['topic_views'],
 					'TOPIC_TYPE' 		=&gt; $topic_type,
@@ -741,12 +795,12 @@
 					'TOPIC_ICON_IMG'		=&gt; (!empty($icons[$row['icon_id']])) ? $icons[$row['icon_id']]['img'] : '',
 					'TOPIC_ICON_IMG_WIDTH'	=&gt; (!empty($icons[$row['icon_id']])) ? $icons[$row['icon_id']]['width'] : '',
 					'TOPIC_ICON_IMG_HEIGHT'	=&gt; (!empty($icons[$row['icon_id']])) ? $icons[$row['icon_id']]['height'] : '',
-					'ATTACH_ICON_IMG'       =&gt; ($_CLASS['auth']-&gt;acl_gets('f_download', 'u_download', $forum_id) &amp;&amp; $row['topic_attachment']) ? $_CLASS['core_user']-&gt;img('icon_attach', $_CLASS['core_user']-&gt;lang['TOTAL_ATTACHMENTS']) : '',
+					'ATTACH_ICON_IMG'       =&gt; ($_CLASS['auth']-&gt;acl_gets(array('f_download', 'u_download'), $forum_id) &amp;&amp; $row['topic_attachment']) ? $_CLASS['core_user']-&gt;img('icon_attach', $_CLASS['core_user']-&gt;lang['TOTAL_ATTACHMENTS']) : '',
 					'S_TOPIC_TYPE'			=&gt; $row['topic_type'],
 					'S_USER_POSTED'			=&gt; (!empty($row['mark_type'])) ? true : false,
 	
-					'S_TOPIC_REPORTED'		=&gt; (!empty($row['topic_reported']) &amp;&amp; $_CLASS['auth']-&gt;acl_gets('m_', $forum_id)) ? true : false,
-					'S_TOPIC_UNAPPROVED'	=&gt; (!$row['topic_approved'] &amp;&amp; $_CLASS['auth']-&gt;acl_gets('m_approve', $forum_id)) ? true : false,
+					'S_TOPIC_REPORTED'		=&gt; (!empty($row['topic_reported']) &amp;&amp; $_CLASS['auth']-&gt;acl_get('m_', $forum_id)) ? true : false,
+					'S_TOPIC_UNAPPROVED'	=&gt; (!$row['topic_approved'] &amp;&amp; $_CLASS['auth']-&gt;acl_get('m_approve', $forum_id)) ? true : false,
 					'S_IGNORE_POST'			=&gt; false,
 
 					'U_LAST_POST'		=&gt; generate_link($view_topic_url . '&amp;p=' . $row['topic_last_post_id'] . '#' . $row['topic_last_post_id'], false),
@@ -766,34 +820,34 @@
 	
 					continue;
 				}
-	
+
 				if ($row['enable_html'])
 				{
 					$row['post_text'] = preg_replace('#(&lt;!\-\- h \-\-&gt;&lt;)([\/]?.*?)(&gt;&lt;!\-\- h \-\-&gt;)#is', &quot;&lt;\\2&gt;&quot;, $row['post_text']);
 				}
-	
+
 				$row['post_text'] = censor_text($row['post_text']);
-	
+
 				decode_message($row['post_text'], $row['bbcode_uid']);
-			
+
 				if ($return_chars)
 				{
 					$row['post_text'] = (strlen($row['post_text']) &lt; $return_chars + 3) ? $row['post_text'] : substr($row['post_text'], 0, $return_chars) . '...';
 				}
-	
+
 				if ($hilit)
 				{
 					// This was shamelessly 'borrowed' from volker at multiartstudio dot de
 					// via php.net's annotated manual
 					$row['post_text'] = str_replace('\&quot;', '&quot;', substr(preg_replace('#(\&gt;(((?&gt;([^&gt;&lt;]+|(?R)))*)\&lt;))#se', &quot;preg_replace('#\b(&quot; . str_replace('\\', '\\\\', addslashes($hilit)) . &quot;)\b#i', '&lt;span class=\&quot;posthilit\&quot;&gt;\\\\1&lt;/span&gt;', '\\0')&quot;, '&gt;' .  $row['post_text'] . '&lt;'), 1, -1));
 				}
-				
+
 				$row['post_text'] = smiley_text($row['post_text']);
-				
+
 				// Replace naughty words such as farty pants
 				$row['post_subject'] = censor_text($row['post_subject']);
 				$row['post_text'] = str_replace(&quot;\n&quot;, '&lt;br /&gt;', censor_text($row['post_text']));
-				
+
 				$tpl_ary = array(
 					'POSTER_NAME'		=&gt; ($row['poster_id'] == ANONYMOUS) ? ((!empty($row['post_username'])) ? $row['post_username'] : $_CLASS['core_user']-&gt;lang['GUEST']) : $row['username'], 
 					'POST_SUBJECT'		=&gt; censor_text($row['post_subject']), 
@@ -833,62 +887,61 @@
 
 // Search forum
 $s_forums = '';
-$sql = 'SELECT forum_id, forum_name, parent_id, forum_type, left_id, right_id, forum_password
-	FROM ' . FORUMS_TABLE . '
-	ORDER BY left_id ASC';
-$result = $_CLASS['core_db']-&gt;query($sql);
 
-$right = $cat_right = $padding_inc = 0;
-$padding = $forum_list = $holding = '';
-$pad_store = array('0' =&gt; '');
-$search_forums = array();
-while ($row = $_CLASS['core_db']-&gt;fetch_row_assoc($result))
+if ($permission_array = $_CLASS['auth']-&gt;acl_getf('f_list'))
 {
-	if ($row['forum_type'] == FORUM_CAT &amp;&amp; ($row['left_id'] + 1 == $row['right_id']))
-	{
-		// Non-postable forum with no subforums, don't display
-		continue;
-	}
+	$sql = 'SELECT forum_id, forum_name, parent_id, forum_type, left_id, right_id, forum_password
+		FROM ' . FORUMS_FORUMS_TABLE . '
+			WHERE forum_id IN (' . implode(', ', array_keys($permission_array)) . ')
+			ORDER BY left_id ASC';
 
-// fix password
-	if (!$_CLASS['auth']-&gt;acl_get('f_list', $row['forum_id']) || $row['forum_type'] == FORUM_LINK || ($row['forum_password']))
+	$result = $_CLASS['core_db']-&gt;query($sql);
+	
+	$right = $cat_right = $padding_inc = 0;
+	$padding = $forum_list = $holding = '';
+	$pad_store = array('0' =&gt; '');
+	$search_forums = array();
+	
+	while ($row = $_CLASS['core_db']-&gt;fetch_row_assoc($result))
 	{
-		// if the user does not have permissions to list this forum skip
-		continue;
-	}
+		if (($row['forum_type'] == FORUM_CAT &amp;&amp; ($row['left_id'] + 1 == $row['right_id'])) || $row['forum_type'] == FORUM_LINK || ($row['forum_password']))
+		{
+			continue;
+		}
 
-	if ($row['left_id'] &lt; $right)
-	{
-		$padding .= '&nbsp; &nbsp;';
-		$pad_store[$row['parent_id']] = $padding;
-	}
-	else if ($row['left_id'] &gt; $right + 1)
-	{
-		$padding = $pad_store[$row['parent_id']];
-	}
+		if ($row['left_id'] &lt; $right)
+		{
+			$padding .= '&nbsp; &nbsp;';
+			$pad_store[$row['parent_id']] = $padding;
+		}
+		else if ($row['left_id'] &gt; $right + 1)
+		{
+			$padding = $pad_store[$row['parent_id']];
+		}
 
-	$right = $row['right_id'];
+		$right = $row['right_id'];
 
-	$selected = (!sizeof($search_forums) || in_array($row['forum_id'], $search_forums)) ? ' selected=&quot;selected&quot;' : '';
+		$selected = (empty($search_forums) || in_array($row['forum_id'], $search_forums)) ? ' selected=&quot;selected&quot;' : '';
 
-	if ($row['left_id'] &gt; $cat_right)
-	{
-		$holding = '';
-	}
+		if ($row['left_id'] &gt; $cat_right)
+		{
+			$holding = '';
+		}
 
-	if ($row['right_id'] - $row['left_id'] &gt; 1)
-	{
-		$cat_right = max($cat_right, $row['right_id']);
-
-		$holding .= '&lt;option value=&quot;' . $row['forum_id'] . '&quot;' . $selected . '&gt;' . $padding . $row['forum_name'] . '&lt;/option&gt;';
+		if ($row['right_id'] - $row['left_id'] &gt; 1)
+		{
+			$cat_right = max($cat_right, $row['right_id']);
+	
+			$holding .= '&lt;option value=&quot;' . $row['forum_id'] . '&quot;' . $selected . '&gt;' . $padding . $row['forum_name'] . '&lt;/option&gt;';
+		}
+		else
+		{
+			$s_forums .= $holding . '&lt;option value=&quot;' . $row['forum_id'] . '&quot;' . $selected . '&gt;' . $padding . $row['forum_name'] . '&lt;/option&gt;';
+			$holding = '';
+		}
 	}
-	else
-	{
-		$s_forums .= $holding . '&lt;option value=&quot;' . $row['forum_id'] . '&quot;' . $selected . '&gt;' . $padding . $row['forum_name'] . '&lt;/option&gt;';
-		$holding = '';
-	}
+	$_CLASS['core_db']-&gt;free_result($result);
 }
-$_CLASS['core_db']-&gt;free_result($result);
 unset($pad_store);
 
 // Number of chars returned
@@ -903,7 +956,7 @@
 	$s_characters .= '&lt;option value=&quot;' . $i . '&quot;' . $selected . '&gt;' . $i . '&lt;/option&gt;';
 }
 
-$_CLASS['core_template']-&gt;assign(array(
+$_CLASS['core_template']-&gt;assign_array(array(
 	'S_SEARCH_ACTION'		=&gt; generate_link('Forums&amp;file=search&amp;mode=results'),
 	'S_CHARACTER_OPTIONS'	=&gt; $s_characters,
 	'S_FORUM_OPTIONS'		=&gt; $s_forums,
@@ -913,18 +966,12 @@
 );
 
 $sql = 'SELECT search_id, search_time, search_array 
-	FROM ' . SEARCH_TABLE . '
+	FROM ' . FORUMS_SEARCH_TABLE . '
 	ORDER BY search_time DESC';
-$result = $_CLASS['core_db']-&gt;query($sql);
+$result = $_CLASS['core_db']-&gt;query_limit($sql, 5);
 
-$i = 0;
 while ($row = $_CLASS['core_db']-&gt;fetch_row_assoc($result))
 {
-	if ($i == 5)
-	{
-		break;
-	}
-
 	$data = explode('#', $row['search_array']);
 	$split_words = htmlspecialchars(implode(' ', unserialize(array_shift($data))));
 
@@ -934,7 +981,6 @@
 	}
 
 	$stopped_words = htmlspecialchars(implode(' ', unserialize(array_shift($data))));
-	unset($data);
 
 	$_CLASS['core_template']-&gt;assign_vars_array('recentsearch', array(
 		'KEYWORDS'	=&gt; $split_words,
@@ -942,11 +988,10 @@
 
 		'U_KEYWORDS'	=&gt; generate_link('Forums&amp;file=search&amp;search_keywords=' . urlencode($split_words)))
 	);
-
-	$i++;
 }
 $_CLASS['core_db']-&gt;free_result($result);
 
+unset($data, $split_words, $stopped_words);
 // Output the basic page
 
 page_header();

Modified: cms/trunk/modules/Forums/viewforum.php
===================================================================
--- cms/trunk/modules/Forums/viewforum.php	2005-09-20 21:46:50 UTC (rev 136)
+++ cms/trunk/modules/Forums/viewforum.php	2005-09-21 03:53:30 UTC (rev 137)
@@ -39,7 +39,7 @@
     die;
 }
 
-require($site_file_root.'includes/forums/functions_display.php');
+require(SITE_FILE_ROOT.'includes/forums/functions_display.php');
 
 // Start initial var setup
 $forum_id	= request_var('f', 0);
@@ -204,7 +204,7 @@
 // Do the forum Prune thang - cron type job ...
 if ($forum_data['prune_next'] &lt; time() &amp;&amp; $forum_data['enable_prune'])
 {
-	require_once($site_file_root.'includes/forums/functions_admin.php');
+	require_once(SITE_FILE_ROOT.'includes/forums/functions_admin.php');
 
 	if ($forum_data['prune_days'])
 	{

Modified: cms/trunk/modules/Forums/viewtopic.php
===================================================================
--- cms/trunk/modules/Forums/viewtopic.php	2005-09-20 21:46:50 UTC (rev 136)
+++ cms/trunk/modules/Forums/viewtopic.php	2005-09-21 03:53:30 UTC (rev 137)
@@ -482,7 +482,7 @@
 
 	if ($poll_info[0]['bbcode_bitfield'])
 	{
-		require_once($site_file_root.'includes/forums/bbcode.php');
+		require_once(SITE_FILE_ROOT.'includes/forums/bbcode.php');
 		$poll_bbcode = new bbcode();
 		
 		$size = !empty($poll_info);
@@ -829,7 +829,7 @@
 {
 	if ($_CLASS['auth']-&gt;acl_gets(array('f_download', 'u_download'), $forum_id))
 	{
-		include($site_file_root.'includes/forums/functions_display.php');
+		include(SITE_FILE_ROOT.'includes/forums/functions_display.php');
 
 		$sql = 'SELECT * 
 			FROM ' . FORUMS_ATTACHMENTS_TABLE . '
@@ -899,7 +899,7 @@
 // Instantiate BBCode if need be
 if ($bbcode_bitfield)
 {
-	require_once($site_file_root.'includes/forums/bbcode.php');
+	require_once(SITE_FILE_ROOT.'includes/forums/bbcode.php');
 	$bbcode = new bbcode($bbcode_bitfield);
 }
 


</PRE>

<!--endarticle-->
    <HR>
    <P><UL>
        <!--threads-->
	<LI>Previous message: <A HREF="000057.html">[Viperals-svncheckins] r136 - in cms/trunk: admin includes includes/display includes/forums modules modules/Control_Panel/ucp modules/Members_List modules/calender modules/calender/language modules/calender/language/en
</A></li>
	<LI>Next message: <A HREF="000059.html">[Viperals-svncheckins] r139 - in cms/trunk: includes/forums includes/forums/mcp includes/templates/modules/Forums modules/Forums
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#58">[ date ]</a>
              <a href="thread.html#58">[ thread ]</a>
              <a href="subject.html#58">[ subject ]</a>
              <a href="author.html#58">[ author ]</a>
         </LI>
       </UL>

<hr>
<a href="https://lists.berlios.de/mailman/listinfo/viperals-svncheckins">More information about the Viperals-svncheckins
mailing list</a><br>
</body></html>
